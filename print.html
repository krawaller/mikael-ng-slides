<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>The new Angular</title>

  <link rel="icon" type="image/x-icon" href="mc2/images/favicon.ico">

  <link rel="stylesheet" href="mc2/styles/print.css">
<link rel="stylesheet" href="mc2/styles/print-code.css">
  <link rel="stylesheet" href="styles/print.css">
</head>
<body>

<div id="bodycontainer">
  <div id="frontpage">
    <h1>The new Angular</h1>
    <div class="splash"><p>The king is dead, long live the king!</p>
</div>
    <img class="logo" src="mc2/images/edument_logo_blue.svg">
  </div>
  <div id="footer">
    <span id="delivery">AddSkills Sthlm, 1 feb 2018</span>
    <span id="copyright">&copy; Edument 2018</span>
  </div>
  <div id="overview">
    <h2>Course overview</h2>
    <div class="overviewlist"><div class="detailedoverview"><div><h4><span>1.</span> Introduction</h4><ol><li>Your teacher</li><li>Course structure</li><li>Manifesto</li><li>The name Angular</li><li>Hello World</li><li>The chain</li><li>Gamebook - the beginning</li></ol></div><div><h4><span>2.</span> Dependencies</h4><ol><li>CoreJS</li><li>TypeScript</li><li>ZoneJS</li><li>Reflect metadata</li><li>RxJS</li><li>SystemJS</li></ol></div><div><h4><span>3.</span> Components 101</h4><ol><li>Component basics</li><li>Component styling</li><li>Reading model values</li><li>Template expressions</li><li>Built-in directives</li><li>Gamebook - dynamism</li></ol></div><div><h4><span>4.</span> Components 102</h4><ol><li>Gamebook - state</li><li>Catching View events</li><li>Lifecycle hooks</li><li>Politics</li><li>Debugging Angular apps</li><li>Gamebook - page turning</li></ol></div><div><h4><span>5.</span> Composition</h4><ol><li>Child components</li><li>Passing data</li><li>Receiving data</li><li>Passing elements</li><li>A composition case study</li><li>Gamebook - composition</li></ol></div><div><h4><span>6.</span> Dependency injection</h4><ol><li>Dependency VS input</li><li>Injection explained</li><li>Dependencies in AngularJS</li><li>Dependencies in Angular</li><li>Providing dependencies</li><li>Non-class dependencies</li><li>Services</li><li>Gamebook - dependencies</li></ol></div></div><div><div><h4><span>7.</span> Forms</h4><ol><li>Two-way data binding</li><li>Forms</li><li>Validation</li><li>Reactive forms</li><li>Template referencing</li><li>Gamebook - extras</li></ol></div><div><h4><span>8.</span> Postludium</h4><ol><li>What's next?</li></ol></div><div><h4><span>9.</span> Appendix: Web stuff</h4><ol><li>The JavaScript language</li><li>The web as a platform</li><li>Node and NPM</li><li>CSS Selectors</li><li>Object references</li><li>Attributes vs Properties</li><li>Functional programming</li><li>Statements vs Expressions</li></ol></div><div><h4><span>10.</span> Appendix: ES2015</h4><ol><li>Versatile object definitions</li><li>Destructuring and rest</li><li>Versatile function definitions</li><li>Spreads</li><li>Modules</li><li>Classes</li><li>Decorators</li><li>Miscellaneous</li><li>Trying it out</li></ol></div><div><h4><span>11.</span> Appendix: NgModules</h4><ol><li>Introducing NgModule</li><li>Module scoping</li><li>Module motivation</li><li>Root module</li><li>AoT vs JiT</li></ol></div><div><h4><span>12.</span> Appendix: Directives</h4><ol><li>Node manipulation</li><li>Server safety</li><li>Consorting with the host</li><li>Case study - host</li><li>Structure directives</li></ol></div><div><h4><span>13.</span> Appendix: various NG</h4><ol><li>Pipes</li><li>Routing</li><li>Animations</li><li>Testing Angular</li></ol></div></div></div>
  </div>
  <div id="slides">
    <div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 1 / 13</span>
    <h2>Introduction</h2>
    <p>welcome to the jungle</p>
</p>
  </div>
  
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. Your teacher</li>
<li>2. Course structure</li>
<li>3. Manifesto</li>
<li>4. The name Angular</li>
<li>5. Hello World</li>
<li>6. The chain</li>
<li>7. Gamebook - the beginning</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>1-1.</span> Your teacher</h3>
      
    </div>
  </section>
  <section class="slide" data-pos="1-1-1">
<span class="pos">1-1-1</span>
<div class="slidecontent"><p>Let&#39;s start with the most important - <strong>me</strong>!</p>
</div></section><section class="slide" data-pos="1-1-2">
<span class="pos">1-1-2</span>
<div class="slidecontent"><p>So, who am I?</p>
<p><img src="resources/diagrams/me.svg" alt=""></p>
</div></section><section class="slide" data-pos="1-1-3">
<span class="pos">1-1-3</span>
<div class="slidecontent"><p>Reach me at...</p>
<ul>
<li>david.waller@edument.se</li>
<li>@krawaller</li>
</ul>
<p>Don&#39;t be a stranger!</p>
</div></section><section class="slide" data-pos="1-1-4">
<span class="pos">1-1-4</span>
<div class="slidecontent"><p>But, <strong>fair warning</strong> - I spend my days singing this gospel:</p>
<div class="equality">
  <img src="resources/images/js-logo.png" alt="js">
  <span>=</span>
  <img src="resources/images/heart.png" alt="heart">
</div></div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>1-2.</span> Course structure</h3>
      <p>How we&#39;ll go about things</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="1-2-1">
<span class="pos">1-2-1</span>
<div class="slidecontent"><p>The course is divided into several <strong>chapters</strong>, where you&#39;re currently in the first.</p>
<p><img src="resources/diagrams/course-structure.svg" alt="index and chapters"></p>
<p>We access the chapters from an <strong>index</strong>, giving you a <strong>birds-eye view</strong> of the entire contents.</p>
</div></section><section class="slide" data-pos="1-2-2">
<span class="pos">1-2-2</span>
<div class="slidecontent"><p>Each <strong>chapter</strong> has many <strong>sections</strong>:</p>
<p><img src="resources/diagrams/course-structure-chapter.svg" alt="index and chapters"></p>
</div></section><section class="slide" data-pos="1-2-3">
<span class="pos">1-2-3</span>
<div class="slidecontent"><p>In the <strong>printed material</strong> (or PDF) and in the <strong>presentation top-right corner</strong>, the slides are numbered <strong><code>X‑Y‑Z</code></strong> where...</p>
<ul>
<li><code>X</code> is the number of the current <strong>chapter</strong></li>
<li><code>Y</code> is the number of the section <strong>section</strong> within that chapter</li>
<li><code>Z</code> is the number of the <strong>slide</strong> within that section</li>
</ul>
</div></section><section class="slide" data-pos="1-2-4">
<span class="pos">1-2-4</span>
<div class="slidecontent"><p>Some sections are <strong>exercises</strong>, where you&#39;ll get to internalise what we&#39;ve been talking about through a 
<strong>practical task</strong>.</p>
<p>These are all <strong>tied together</strong> in that it is one single app that you will keep tinkering with.</p>
</div></section><section class="slide" data-pos="1-2-5">
<span class="pos">1-2-5</span>
<div class="slidecontent"><p>Quite a bit of material live in the <strong>Appendixes</strong>. You should take a look what&#39;s there, and we&#39;ll <strong>dive down when we need to or feel like it</strong>!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>1-3.</span> Manifesto</h3>
      <p>what we want to achieve</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="1-3-1">
<span class="pos">1-3-1</span>
<div class="slidecontent"><p>Obviously, first and foremost, this course aims to <strong>teach you about Angular</strong>.</p>
</div></section><section class="slide" data-pos="1-3-2">
<span class="pos">1-3-2</span>
<div class="slidecontent"><p>As with all our courses we strive <strong>not to focus just on the API</strong>, but mainly to <strong>provide a deep understanding</strong> for the subject.</p>
<p>In this case, the <strong>Angular way of thinking</strong>!</p>
</div></section><section class="slide" data-pos="1-3-3">
<span class="pos">1-3-3</span>
<div class="slidecontent"><p>Also, in the case of Angular, a <strong>detailed-oriented focus</strong> would be <strong>extra unfortunate</strong> as things are still <strong>changing around quite frequently</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>1-4.</span> The name Angular</h3>
      <p>Nya gamla Ullevi</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="1-4-1">
<span class="pos">1-4-1</span>
<div class="slidecontent"><p>So - <strong>Angular</strong>!</p>
<p>First lesson for the day: this is a <strong>completely new framework</strong>.</p>
<p>It is rebuilt from the ground up but <strong>borrows ideas from its predecessor</strong>, AngularJS (or Angular 1).</p>
</div></section><section class="slide" data-pos="1-4-2">
<span class="pos">1-4-2</span>
<div class="slidecontent"><p><strong>Angular v1 still lives on</strong>, and will be <strong>developed in parallel with Angular v2+</strong>.</p>
<p>Really, the new Angular could (should?) have been <strong>called something completely different</strong>.</p>
</div></section><section class="slide question" data-pos="1-4-3">
<span class="pos">1-4-3</span>
<div class="slidecontent">
<p>So - can you <strong>spot the difference</strong> between these two?</p>
<div class="equality">
<img src="resources/images/angular1.png" alt="">
<span></span>
<img src="resources/images/angular2.svg" alt="">
</div></div></section><section class="slide answer" data-pos="1-4-4">
<span class="pos">1-4-4</span>
<div class="slidecontent">
<p>Obviously;</p>
<ul>
<li>The first is the logo for <strong>AngularJS</strong></li>
<li>The second represents <strong>Angular</strong></li>
</ul>
</div></section><section class="slide" data-pos="1-4-5">
<span class="pos">1-4-5</span>
<div class="slidecontent"><p>Some more comparisons:</p>
<table class="small">
  <thead>
    <tr>
      <th></th><th>Angular v1</th><th>Angular v2+</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Official name</td>
      <td>AngularJS</td>
      <td>Angular</td>
    </tr>
    <tr>
      <td>Homepage</td>
      <td><a href="http://angularjs.org">http://angularjs.org</a></td>
      <td><a href="http://angular.io">http://angular.io</a></td>
    </tr>
    <tr>
      <td>NPM package</td>
      <td><a href="https://www.npmjs.com/package/angular">angular</a></td>
      <td><a href="https://www.npmjs.com/package/@angular/core">@angular</a></td>
    </tr>
    <tr>
      <td>Git repo</td>
      <td><a href="https://github.com/angular/angular.js">angular/angular.js</a></td>
      <td><a href="https://github.com/angular/angular">angular/angular</a></td>
    </tr>
    <tr>
      <td>version (jan 2018)</td>
      <td>1.6.8</td>
      <td>5.1.3</td>
    </tr>
  </tbody>
</table></div></section><section class="slide question" data-pos="1-4-6">
<span class="pos">1-4-6</span>
<div class="slidecontent">
<p>...isn&#39;t this <strong>hugely confusing</strong>?</p>
</div></section><section class="slide answer" data-pos="1-4-7">
<span class="pos">1-4-7</span>
<div class="slidecontent">
<p>Yes. Yes, it is.</p>
</div></section><section class="slide question" data-pos="1-4-8">
<span class="pos">1-4-8</span>
<div class="slidecontent">
<p>And since <strong>development continues on Angular1</strong> - what happens when they need a <strong>new major version</strong>?</p>
</div></section><section class="slide answer" data-pos="1-4-9">
<span class="pos">1-4-9</span>
<div class="slidecontent">
<p><img src="resources/images/smileyupsidedown.svg" style="border:none;background:inherit;max-width:200px;margin-bottom:-90px;margin-left:20px;"></p>
</div></section><section class="slide" data-pos="1-4-10">
<span class="pos">1-4-10</span>
<div class="slidecontent"><p>Because of this confusion, many opted to <strong>refer to the new framework as Angular 2</strong>, even though that is not the official name.</p>
<p>But that doesn&#39;t work anymore, since <strong>Angular &quot;2&quot; is now version 5</strong>.</p>
</div></section><section class="slide" data-pos="1-4-11">
<span class="pos">1-4-11</span>
<div class="slidecontent"><p>...and, to put a cherry on the cake, there <strong>never was a version 3</strong>.</p>
</div></section><section class="slide" data-pos="1-4-12">
<span class="pos">1-4-12</span>
<div class="slidecontent"><p>But, jokes aside - Angular is a <strong>well thought-through framework</strong> using <strong>cutting-edge technologies</strong> while still <strong>leaning on experience</strong> from AngularJS.</p>
<p>As such is it <strong>well worth getting to know</strong>. So, let&#39;s do just that!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>1-5.</span> Hello World</h3>
      <p>hello yourself!</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="1-5-1">
<span class="pos">1-5-1</span>
<div class="slidecontent"><p>There&#39;s really a <strong>whole lot to learn</strong> before we <em>can</em> say hello to the world, but - <strong>let&#39;s cheat</strong>!</p>
</div></section><section class="slide" data-pos="1-5-2">
<span class="pos">1-5-2</span>
<div class="slidecontent"><p>We&#39;ll jump <strong>straight into the deep</strong> and see what a <a href="resources/supportsite/demos/helloworld" target="_blank">Hello World</a> demo would look like!</p>
</div></section><section class="slide" data-pos="1-5-3">
<span class="pos">1-5-3</span>
<div class="slidecontent"><p>So, there was a <strong>lot of things in that code that we didn&#39;t understand</strong> at all.</p>
<pre><code>@<span class="hljs-keyword">NgModule</span>({
    <span class="hljs-selector-tag">imports</span>: <span class="hljs-selector-attr">[ BrowserModule ]</span>,
    <span class="hljs-selector-tag">declarations</span>: <span class="hljs-selector-attr">[ AppComponent ]</span>,
    <span class="hljs-selector-tag">bootstrap</span>: <span class="hljs-selector-attr">[ AppComponent ]</span>
})
<span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">AppModule</span> {}

<span class="hljs-selector-tag">platformBrowserDynamic</span>()<span class="hljs-selector-class">.bootstrapModule</span>(<span class="hljs-selector-tag">AppModule</span>);
</code></pre><p>But <strong><code>main.ts</code></strong> seems to be mainly <strong>bootstrapping stuff</strong>.</p>
</div></section><section class="slide" data-pos="1-5-4">
<span class="pos">1-5-4</span>
<div class="slidecontent"><p>And <strong><code>app.ts</code></strong> didn&#39;t really look <em>that</em> bad!</p>
<pre><code>@Component({
  selector: <span class="hljs-string">'app'</span>,
  template: <span class="hljs-string">'&lt;p&gt;Hello world!&lt;/p&gt;'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> { }</span>
</code></pre><p>If we pretend that weird <code>@</code> sign wasn&#39;t there, this looks <strong>almost decipherable</strong>!</p>
</div></section><section class="slide" data-pos="1-5-5">
<span class="pos">1-5-5</span>
<div class="slidecontent"><p>And of course, throughout this course, we will <strong>decipher all of what you just saw</strong>.</p>
<p>But now you <strong>have an idea what we&#39;re dealing with</strong>!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>1-6.</span> The chain</h3>
      <p>From source to seeing</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="1-6-1">
<span class="pos">1-6-1</span>
<div class="slidecontent"><p>In our sheltered demo setup it is a bit <strong>hard to get a feel for the setup chain</strong>, since all of that takes place behind the curtain.</p>
<p>Let&#39;s peek, at least squintingly, at <strong>what that looks like</strong> before we move on!</p>
</div></section><section class="slide" data-pos="1-6-2">
<span class="pos">1-6-2</span>
<div class="slidecontent"><p>Here is an overview of <strong>what needs to happen</strong> before the user can interact with your Angular app:</p>
<p><img src="resources/diagrams/chain-info.svg" alt=""></p>
</div></section><section class="slide" data-pos="1-6-3">
<span class="pos">1-6-3</span>
<div class="slidecontent"><p>(Although it is possible, but not advisable, to <strong>cheat</strong>)</p>
<p><img src="resources/diagrams/chain-info-shortcut.svg" alt=""></p>
</div></section><section class="slide" data-pos="1-6-4">
<span class="pos">1-6-4</span>
<div class="slidecontent"><p>So, if we don&#39;t cheat, <strong>how</strong> do we make all this happen? Let&#39;s look at a few <strong>different setups</strong>.</p>
</div></section><section class="slide" data-pos="1-6-5">
<span class="pos">1-6-5</span>
<div class="slidecontent"><p>Here&#39;s the <strong>Quickstart setup</strong>:</p>
<p><img src="resources/diagrams/chain-systemjs.svg" alt=""></p>
<p>Everything happens in the <strong>client&#39;s browser</strong>.</p>
</div></section><section class="slide" data-pos="1-6-6">
<span class="pos">1-6-6</span>
<div class="slidecontent"><p>A more typical approach is to have a <strong>build step</strong>, where we do stuff <strong>on the developer&#39;s computer</strong>. Here&#39;s a <strong>common setup</strong>:</p>
<p><img src="resources/diagrams/chain-webpack.svg" alt=""></p>
<p><strong>Transpiling and bundling</strong> are often done at the <strong>same time</strong>.</p>
</div></section><section class="slide" data-pos="1-6-7">
<span class="pos">1-6-7</span>
<div class="slidecontent"><p>An advantage of a build step is that it lets us <strong>shrink the code</strong>:</p>
<p><img src="resources/diagrams/chain-webpack-perf.svg" alt=""></p>
</div></section><section class="slide" data-pos="1-6-8">
<span class="pos">1-6-8</span>
<div class="slidecontent"><p>This is primarily done through 3 different means:</p>
<table class="deflist">
<tr><td>Minification</td><td>Remove whitespace, rename variables etc. This also obfuscates!</td></tr>
<tr><td>Compression</td><td>Using gzip or similar to pack the file</td></tr>
<tr><td>Tree shaking</td><td>Identifying and eliminating unused code from the package</td></tr>
</table></div></section><section class="slide" data-pos="1-6-9">
<span class="pos">1-6-9</span>
<div class="slidecontent"><p>We can increase performance by <strong>moving the template compiling to the build step</strong>:</p>
<p><img src="resources/diagrams/chain-precomp.svg" alt=""></p>
<p>But, we&#39;re getting ahead of ourselves!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>1-7.</span> Gamebook - the beginning</h3>
      <p>left or right, block or strike?</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="1-7-1">
<span class="pos">1-7-1</span>
<div class="slidecontent"><p>Even though we <strong>really don&#39;t know what&#39;s going on yet</strong>, let&#39;s have a quick <strong>first exercise</strong>!</p>
</div></section><section class="slide" data-pos="1-7-2">
<span class="pos">1-7-2</span>
<div class="slidecontent"><p>This will mean <strong>using techniques and tools we haven&#39;t explained yet</strong>, but, humour us and follow along anyway! :)</p>
</div></section><section class="slide" data-pos="1-7-3">
<span class="pos">1-7-3</span>
<div class="slidecontent"><p>We&#39;ll now <strong>walk through the instructions together</strong> so you know what to do.</p>
<p>But remember that you have these <strong>same exact slides in the provided material</strong>, so refer to that while you&#39;re working!</p>
</div></section><section class="slide" data-pos="1-7-4">
<span class="pos">1-7-4</span>
<div class="slidecontent"><div style="float:right;margin-left:2em;">
<img src="resources/images/ff.jpg" alt="">
</div>

<p>So! Does anyone <strong>recognizes</strong> this book cover?</p>
</div></section><section class="slide" data-pos="1-7-5">
<span class="pos">1-7-5</span>
<div class="slidecontent"><p>This is the first of the legendary <strong>Fighting Fantasy gamebooks</strong>! They work <strong>something like this</strong>:</p>
<blockquote>
<p>A dark hallway extends into the unknown. You can just make out the outline of a door to your left.</p>
<ul>
<li>to try the door, go to page 43</li>
<li>to fumble down the hallway, go to page 231</li>
</ul>
</blockquote>
</div></section><section class="slide" data-pos="1-7-6">
<span class="pos">1-7-6</span>
<div class="slidecontent"><p>Throughout this course we will <strong>learn Angular</strong> by hacking away at <strong>our own gamebook app</strong>!</p>
<p>Now, with the <a href="resources/supportsite/demos/helloworld" target="_blank">Hello World</a> demo fresh on our retinas, we&#39;ll start by just making a <strong>static example page</strong>.</p>
</div></section><section class="slide" data-pos="1-7-7">
<span class="pos">1-7-7</span>
<div class="slidecontent"><p>Your illustrous teacher will provide you with a <strong>starter kit</strong>, which you should <strong>download</strong> to your computer and <strong>open in your editor</strong>.</p>
<p>Then, moving forward, <strong>every iteration</strong> of the app will <strong>have its own folder</strong> inside the starter kit.</p>
</div></section><section class="slide" data-pos="1-7-8">
<span class="pos">1-7-8</span>
<div class="slidecontent"><p>Before we can do anything we must <strong>download the dependencies</strong>. You must...</p>
<ul>
<li><strong>open a node terminal (there&#39;s one in VSC!)</strong></li>
<li><strong>navigate to the exercises</strong></li>
<li><strong>copy the <code>_seed</code> folder</strong></li>
<li><strong>navigate into the copy</strong></li>
<li><strong>type <code>npm install</code></strong></li>
</ul>
</div></section><section class="slide list" data-pos="1-7-9">
<span class="pos">1-7-9</span>
<div class="slidecontent">
<p>In this folder you&#39;ll find a bunch of files, most of which you don&#39;t need to touch.</p>
<p>For now we only need to talk about...</p>
<ul>
<li><span>a</span><code>src/app.ts</code></li>
<li><span>b</span><code>src/module.ts</code></li>
<li><span>c</span><code>main.ts</code></li>
</ul>
</div></section><section class="slide num numA" data-pos="1-7-10">
<span class="pos">1-7-10</span>
<div class="slidecontent">
<p>The <strong><code>app.ts</code></strong> file <strong>defines and exports a single component</strong>.</p>
<p>On this small scale you could say that <strong>this is the application</strong>!</p>
<p>The <strong>only part you need to care about now</strong> is the <strong><code>template</code></strong>, which contains what should be rendered to the screen.</p>
</div></section><section class="slide" data-pos="1-7-11">
<span class="pos">1-7-11</span>
<div class="slidecontent"><p>You should <strong>change this template</strong> so that it shows a <strong>single page from a gamebook</strong>.</p>
<p>It <strong>won&#39;t have any functionality</strong> yet, just a static rendering.</p>
</div></section><section class="slide" data-pos="1-7-12">
<span class="pos">1-7-12</span>
<div class="slidecontent"><div class="needsblocklists">

<div style="float:right;margin-left:2em;">
<img src="resources/images/ffexample.png" alt="">
</div>

<p>The <strong>template should contain</strong>:</p>
<ul>
<li>An <strong>adventure title</strong> that never changes</li>
<li>A <strong>scene title</strong></li>
<li>An <strong>image</strong> (link it in using an <code>img</code> element with a <code>src</code> attribute)</li>
<li>A <strong>text</strong> describing the scene</li>
<li>A list of <strong>options</strong> (that won&#39;t be clickable yet, just make them pure text)</li>
</ul>
<p></div></p>
</div></section><section class="slide" data-pos="1-7-13">
<span class="pos">1-7-13</span>
<div class="slidecontent"><p>To <strong>prevent the image</strong> from being <strong>too large</strong>, add a quick styling to the <code>Component</code> metadata:</p>
<pre><code>styles: ['img {<span class="hljs-built_in">max</span>-<span class="hljs-built_in">width</span>: 250px; <span class="hljs-built_in">max</span>-<span class="hljs-built_in">height</span>: 200px;}']
</code></pre></div></section><section class="slide num numB" data-pos="1-7-14">
<span class="pos">1-7-14</span>
<div class="slidecontent">
<p>The <strong><code>module.ts</code></strong> will...</p>
<ul>
<li>Create a <strong>root module</strong></li>
<li>Import the <strong>needed dependencies</strong></li>
<li>Import the <strong>component</strong> from <code>app.ts</code></li>
</ul>
<p>You <strong>don&#39;t have to change anything</strong> here unless you want to add more components.</p>
</div></section><section class="slide num numC" data-pos="1-7-15">
<span class="pos">1-7-15</span>
<div class="slidecontent">
<p>Finally, <code>main.ts</code> is the <strong>bootstrapping file</strong> It will</p>
<ul>
<li>import the app module</li>
<li>bootstrap it</li>
</ul>
<p>You <strong>don&#39;t have to change anything</strong> here.</p>
</div></section><section class="slide" data-pos="1-7-16">
<span class="pos">1-7-16</span>
<div class="slidecontent"><p>After you&#39;ve <strong>finished the template</strong> it is time to <strong>bundle up</strong>!</p>
<p>For these exercises we&#39;ll be using <strong>webpack</strong>.</p>
</div></section><section class="slide" data-pos="1-7-17">
<span class="pos">1-7-17</span>
<div class="slidecontent"><p>To bundle up your app, you must type...</p>
<pre><code>npm <span class="hljs-keyword">run</span><span class="bash"> build</span>
</code></pre><p>...inside the project folder.</p>
<p>This will <strong>create <code>dist/bundle.js</code></strong>, which <strong><code>dist/index.html</code> is already wired to use</strong>.</p>
</div></section><section class="slide" data-pos="1-7-18">
<span class="pos">1-7-18</span>
<div class="slidecontent"><p>Now you can <strong>view <code>dist/index.html</code></strong> in your browser and <strong>see your app in action</strong>!</p>
<p>This is <strong>best done over a web server</strong>. The easiest way is likely to <strong>do this from inside your editor</strong> if it has that functionality.</p>
</div></section><section class="slide" data-pos="1-7-19">
<span class="pos">1-7-19</span>
<div class="slidecontent"><p>Now that we&#39;ve <strong>had a taste of creating an Angular app</strong>, we&#39;ll <strong>rewind to the actual beginning</strong> and lay out the tools and theories we need to <strong>actually understand what we just did</strong>.</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 2 / 13</span>
    <h2>Dependencies</h2>
    <p>What makes Angular tick</p>
</p>
  </div>
  <section class="slide">

<div class="slidecontent"><p>Taking a detour before getting into Angular for real, we will now tour the <strong>dependencies of the framework</strong>!</p>
</div></section>
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. CoreJS</li>
<li>2. TypeScript</li>
<li>3. ZoneJS</li>
<li>4. Reflect metadata</li>
<li>5. RxJS</li>
<li>6. SystemJS</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>2-1.</span> CoreJS</h3>
      <p>ES3 -&gt; ES5</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="2-1-1">
<span class="pos">2-1-1</span>
<div class="slidecontent"><p><a href="https://www.npmjs.com/package/core-js">CoreJS</a> is a node module that <strong>provides polyfills for ES5</strong> (and some more advanced features).</p>
<p>This means we can <strong>write code in ES5</strong>, but be sure that <strong>ES3 browsers can run it</strong>.</p>
</div></section><section class="slide" data-pos="2-1-2">
<span class="pos">2-1-2</span>
<div class="slidecontent"><p>As you can see, it is a <strong>very popular</strong> solution: </p>
<p><img src="resources/images/corejs-numbers.png" alt="numbers"></p>
</div></section><section class="slide" data-pos="2-1-3">
<span class="pos">2-1-3</span>
<div class="slidecontent"><p>CoreJS is <strong>not actually a dependency</strong> of Angular, but as your app is likely to end up as ES5 code (after having been chewed by TypeScript), CoreJS is an <strong>easy way to increase browser coverage</strong>.</p>
</div></section><section class="slide" data-pos="2-1-4">
<span class="pos">2-1-4</span>
<div class="slidecontent"><p>A <strong>normal usage</strong> of CoreJS is to <strong>pull it in via NPM</strong>, and then <strong>reference the shim file</strong> in your main <code>index.html</code> file:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../node_modules/core-js/client/shim.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="2-1-5">
<span class="pos">2-1-5</span>
<div class="slidecontent"><p>Note that since <strong>no code transpiling</strong> is taking place, <strong>only polyfilling is possible</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>2-2.</span> TypeScript</h3>
      <p>Waiter, there are types in my JavaScript!</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="2-2-1">
<span class="pos">2-2-1</span>
<div class="slidecontent"><p><a href="http://typescriptlang.org">TypeScript</a> is <strong>language</strong> that <strong>compiles to JavaSript</strong>.</p>
<p>Unlike other such languages like for example <a href="http://coffeescript.org">CoffeeScript</a>, it is a <strong>superset of JavaScript</strong>. This is important since it means that <strong>regular JavaScript is valid TypeScript</strong>.</p>
</div></section><section class="slide" data-pos="2-2-2">
<span class="pos">2-2-2</span>
<div class="slidecontent"><p>So <strong>what does TypeScript add</strong>? Many things!</p>
<p>Most importantly <strong>types</strong>, as the name suggests.</p>
</div></section><section class="slide" data-pos="2-2-3">
<span class="pos">2-2-3</span>
<div class="slidecontent"><p>We can <strong>add type annotations to variables, parameters and functions</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">let</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'foo;'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAllowedIn</span>(<span class="hljs-params">age: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;
}
</code></pre>
<p>Now, if some other code <strong>violates these annotations</strong>, TypeScript would <strong>flag this as a problem</strong>. (During compilation, or even earlier, if your editor is TypeScript-aware.)</p>
</div></section><section class="slide" data-pos="2-2-4">
<span class="pos">2-2-4</span>
<div class="slidecontent"><p>However, the <strong>real power of TypeScript</strong> is that it does <strong>static analysis</strong> of your code. So if we later typed this...</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">let</span> willHaveFun = isAllowedIn(<span class="hljs-number">16</span>);
</code></pre>
<p>...and hovered above <code>willHaveFun</code>, a TypeScript-aware editor would <strong>tell you that this is a boolean</strong>!</p>
</div></section><section class="slide" data-pos="2-2-5">
<span class="pos">2-2-5</span>
<div class="slidecontent"><p>In other words, <strong>this example code</strong>...</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">let</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'foo;'</span>
</code></pre>
<p>...was <strong>unnecessarily complex</strong>, as <strong>this would be enough</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">'foo'</span>;
</code></pre>
<p>TypeScript <strong>sees from the assignment that <code>name</code> is a string</strong>, and will treat it as such.</p>
</div></section><section class="slide" data-pos="2-2-6">
<span class="pos">2-2-6</span>
<div class="slidecontent"><p>In other words - simply by activating TypeScript we <strong>get a lot of power</strong>, even if we <strong>don&#39;t use any type annotations</strong>!</p>
</div></section><section class="slide" data-pos="2-2-7">
<span class="pos">2-2-7</span>
<div class="slidecontent"><p>TypeScript <strong>isn&#39;t strictly a dependency</strong> of Angular.</p>
<p>Yes, <strong>Angular is written in TypeScript</strong>, but that code has <strong>already been transpiled</strong> to regular JavaScript.</p>
</div></section><section class="slide" data-pos="2-2-8">
<span class="pos">2-2-8</span>
<div class="slidecontent"><p>But since <strong>we will use TypeScript in our Angular code</strong>, TypeScript should be a <strong>devDependency</strong> of our project.</p>
<p>Exactly how we use it <strong>depends on the build setup</strong>, or if we&#39;re using SystemJS.</p>
</div></section><section class="slide question" data-pos="2-2-9">
<span class="pos">2-2-9</span>
<div class="slidecontent">
<p>So... we don&#39;t have to use TypeScript. But <strong>what will we use it for</strong>?</p>
</div></section><section class="slide answer" data-pos="2-2-10">
<span class="pos">2-2-10</span>
<div class="slidecontent">
<p>The following:</p>
<ul>
<li>as an <strong>ES6 transpiler</strong></li>
<li>a few <strong>type annotations</strong> for dependency injections (more on that later)</li>
<li>for <strong>decorating classes</strong> as we saw earlier</li>
<li><strong>class property initialisation</strong> which isn&#39;t possible in regular JS (yet)</li>
</ul>
</div></section><section class="slide" data-pos="2-2-11">
<span class="pos">2-2-11</span>
<div class="slidecontent"><p>In other words, our code will <strong>mostly be normal ES6</strong>, so don&#39;t be too scared! :)</p>
</div></section><section class="slide" data-pos="2-2-12">
<span class="pos">2-2-12</span>
<div class="slidecontent"><p>In an <strong>optional part of the exercises</strong> we&#39;ll also be using <strong>TypeScript interfaces</strong>.</p>
<p>They are <strong>very powerful</strong>, but we&#39;ll just use them to define <strong>object shapes</strong>. Kind of a <strong>data type</strong>!</p>
</div></section><section class="slide" data-pos="2-2-13">
<span class="pos">2-2-13</span>
<div class="slidecontent"><p>It looks like this; in the <strong>interface definition</strong> we <strong>specify the expected properties</strong> for our object shape:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">interface</span> User {
  name: <span class="hljs-built_in">string</span>,
  age: <span class="hljs-built_in">number</span>
}
</code></pre>
</div></section><section class="slide" data-pos="2-2-14">
<span class="pos">2-2-14</span>
<div class="slidecontent"><p>Now we can <strong>use the interface as a type</strong>...</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">let</span> me: User = { name: <span class="hljs-string">"David"</span>, age: <span class="hljs-number">37</span> };
</code></pre>
<p>...and <strong>TypeScript will ensure compliance</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">let</span> you: User = { name: <span class="hljs-string">"Bob"</span> }; <span class="hljs-comment">// angry red squiggly line</span>
</code></pre>
</div></section><section class="slide" data-pos="2-2-15">
<span class="pos">2-2-15</span>
<div class="slidecontent"><p>Note that <strong>interfaces are purely a development artifact</strong>, there&#39;ll be <strong>no trace of them in the generated JS code</strong>.</p>
<p>Which means there&#39;s <strong>no performance or bloat penalty</strong> to using them, but we gain in <strong>code clarity</strong> and <strong>bug prevention</strong>!</p>
</div></section><section class="slide" data-pos="2-2-16">
<span class="pos">2-2-16</span>
<div class="slidecontent"><p>There is a lot more to say about TypeScript that is outside the scope of the usage in Angular. In fact, we have a <a href="https://edument.se/education/categories/webdevelopment/typescript">whole course just about TypeScript</a>!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>2-3.</span> ZoneJS</h3>
      <p>perimeter alarms</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="2-3-1">
<span class="pos">2-3-1</span>
<div class="slidecontent"><p><a href="https://github.com/angular/zone.js">ZoneJS</a> is an implementation of <em>zones</em> for JavaScript. A zone is...</p>
<blockquote>
<p>an execution context that persists across async tasks</p>
</blockquote>
</div></section><section class="slide question" data-pos="2-3-2">
<span class="pos">2-3-2</span>
<div class="slidecontent">
<p>Wat?!</p>
</div></section><section class="slide answer" data-pos="2-3-3">
<span class="pos">2-3-3</span>
<div class="slidecontent">
<p>Ok, ok. Imagine this simple app...</p>
<p><img src="resources/images/bottlesofbeer.png" alt=""></p>
<p>...where clicking the button increases the count by 1.</p>
</div></section><section class="slide" data-pos="2-3-4">
<span class="pos">2-3-4</span>
<div class="slidecontent"><p>Here&#39;s an <strong>implementation using React</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> Clicker = React.createClass({
  <span class="hljs-attr">getInitialState</span>: <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> ({<span class="hljs-attr">count</span>:<span class="hljs-number">3</span>}),
  more() {
    <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">count</span>:<span class="hljs-keyword">this</span>.state.count+<span class="hljs-number">1</span>})
  },
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.state.count} bottles of beer on the wall<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.more}</span>&gt;</span>Buy more<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  }
})
</code></pre>
</div></section><section class="slide" data-pos="2-3-5">
<span class="pos">2-3-5</span>
<div class="slidecontent"><p>The interesting part is the <strong>statement that is executed when we click the button</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">count</span>:<span class="hljs-keyword">this</span>.state.count+<span class="hljs-number">1</span>})
</code></pre>
<p>The <strong>only way to change the state</strong> in React is to <strong>call <code>setState</code></strong>.</p>
</div></section><section class="slide" data-pos="2-3-6">
<span class="pos">2-3-6</span>
<div class="slidecontent"><p>This also means that React <strong>only needs to update the UI when <code>setState</code> has been called</strong>, since that is the only time things can change!</p>
</div></section><section class="slide" data-pos="2-3-7">
<span class="pos">2-3-7</span>
<div class="slidecontent"><p>Here&#39;s the <strong>same app in Angular</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'clicker'</span>,
  template: <span class="hljs-string">`
    &lt;p&gt;{{count}} bottles of beer on the wall&lt;/p&gt;
    &lt;button (click)="more()"&gt;Buy more&lt;/button&gt;
  `</span>
})
<span class="hljs-keyword">class</span> Clicker {
  count = <span class="hljs-number">3</span>
  more() {
    <span class="hljs-keyword">this</span>.count++
  }
}
</code></pre>
</div></section><section class="slide" data-pos="2-3-8">
<span class="pos">2-3-8</span>
<div class="slidecontent"><p>When the button is clicked, we <strong>simply mutate an instance property</strong> directly:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">this</span>.count++
</code></pre>
</div></section><section class="slide question" data-pos="2-3-9">
<span class="pos">2-3-9</span>
<div class="slidecontent">
<p>But.. if there&#39;s no <code>setState</code> equivalent to piggyback on, <strong>how does Angular know when to update the UI</strong>?</p>
</div></section><section class="slide answer" data-pos="2-3-10">
<span class="pos">2-3-10</span>
<div class="slidecontent">
<p>Angular cheats by <strong>patching every function that can cause a change</strong>. Because there are only a finite set of times when this can happen, most importantly:</p>
<ul>
<li>DOM events</li>
<li>Timeouts and intervals</li>
<li>AJAX requests return</li>
</ul>
</div></section><section class="slide" data-pos="2-3-11">
<span class="pos">2-3-11</span>
<div class="slidecontent"><p>AngularJS did the patching by forcing developers to use <strong>Angular variants</strong> of things:</p>
<ul>
<li><strong><code>ng-click</code></strong> instead of regular <strong>click event</strong></li>
<li><strong><code>$timeout</code></strong> service instead of regular <strong><code>setTimeout</code></strong></li>
<li><strong><code>$http</code></strong> service instead of regular <strong><code>XMLHttpRequest</code></strong></li>
</ul>
</div></section><section class="slide" data-pos="2-3-12">
<span class="pos">2-3-12</span>
<div class="slidecontent"><p>These special Angular variants would <strong>call their native equivalents</strong>, but also <strong>wrap the UI updating</strong>.</p>
</div></section><section class="slide" data-pos="2-3-13">
<span class="pos">2-3-13</span>
<div class="slidecontent"><p>In Angular, we <strong>patch the native methods directly</strong> instead.</p>
<p>Except, it is actually <strong>ZoneJS who does the patching</strong> for us!</p>
</div></section><section class="slide question" data-pos="2-3-14">
<span class="pos">2-3-14</span>
<div class="slidecontent">
<p>Ok, so <strong>ZoneJS tells us when to look for changes</strong>, but - <strong>what&#39;s the point</strong>?</p>
</div></section><section class="slide answer" data-pos="2-3-15">
<span class="pos">2-3-15</span>
<div class="slidecontent">
<p>Only this: by hooking our UI update mechanics into all points where stuff can happen, we can <strong>allow devs to mutate state directly</strong>...</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">this</span>.count++
</code></pre>
<p>...instead of <strong>forcing them through a function</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">count</span>:<span class="hljs-keyword">this</span>.state.count+<span class="hljs-number">1</span>})
</code></pre>
</div></section><section class="slide" data-pos="2-3-16">
<span class="pos">2-3-16</span>
<div class="slidecontent"><p>We <strong>use zone.js</strong> either by <strong>referencing it</strong> in the html file...</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../node_modules/zone.js/dist/zone.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre><p>...or <strong><code>import</code>ing it</strong> in our app root:</p>
<pre><code><span class="hljs-keyword">import</span> `zone.js`
</code></pre></div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>2-4.</span> Reflect metadata</h3>
      <p>the story behind the story</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="2-4-1">
<span class="pos">2-4-1</span>
<div class="slidecontent"><p><a href="https://www.npmjs.com/package/reflect-metadata">Reflect Metadata</a> is...</p>
<ul>
<li>a <strong>proposal for a new <code>Reflect</code> global object</strong></li>
<li>a <strong>sample implementation of that feature</strong></li>
</ul>
</div></section><section class="slide" data-pos="2-4-2">
<span class="pos">2-4-2</span>
<div class="slidecontent"><p>The <code>Reflect</code> object houses functionality that allows you to <strong>read / write metadata</strong> to / from data structures.</p>
</div></section><section class="slide" data-pos="2-4-3">
<span class="pos">2-4-3</span>
<div class="slidecontent"><p>Now, the <strong>decorating itself</strong> and the weird @ syntax that it uses is <strong>not part of <code>Reflect</code></strong>. <code>Reflect</code> is merely a <strong>convenient tool</strong> to use in that process.</p>
</div></section><section class="slide" data-pos="2-4-4">
<span class="pos">2-4-4</span>
<div class="slidecontent"><p><strong>Decorators are a separate proposal</strong>, as well as a <strong>competing implementation by TypeScript</strong>.</p>
<p>Suffice to say that the situation is a bit of a mess.</p>
</div></section><section class="slide" data-pos="2-4-5">
<span class="pos">2-4-5</span>
<div class="slidecontent"><p>For our use case all you need to know about <code>Reflect</code> is that <strong>Angular relies on it being available</strong>, and so we must make sure that it is by <strong>referencing it</strong> in our html file...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../node_modules/reflect-metadata/Reflect.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>...or <strong><code>import</code> it</strong> into our codebase:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">'reflect-metadata'</span>
</code></pre>
</div></section><section class="slide" data-pos="2-4-6">
<span class="pos">2-4-6</span>
<div class="slidecontent"><p>In the future, when the native <code>Reflect</code> object stabilises, the plan is to do <strong>without Reflect metadata</strong>. But, we&#39;re not quite there yet.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>2-5.</span> RxJS</h3>
      <p>Everything is a stream</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="2-5-1">
<span class="pos">2-5-1</span>
<div class="slidecontent"><p>Like ZoneJS, RxJS is a <strong>PeerDependency</strong>, which again means that it is up to you to <strong>make sure it is available</strong>.</p>
</div></section><section class="slide" data-pos="2-5-2">
<span class="pos">2-5-2</span>
<div class="slidecontent"><p>However, unlike ZoneJS, you <strong>don&#39;t have to bring it into your project</strong>.</p>
<p>Just make sure it <strong>sits in <code>node_modules</code></strong>, and <strong>Angular will reference it</strong> under the hood as needed.</p>
</div></section><section class="slide" data-pos="2-5-3">
<span class="pos">2-5-3</span>
<div class="slidecontent"><p>So what does it do? RxJS is a <strong>stream library</strong>. What are those? They are frequently described as</p>
<blockquote>
<p>promises on steroids</p>
</blockquote>
<p>In other words, they are a <strong>tool for working with asynchronicity</strong>!</p>
</div></section><section class="slide" data-pos="2-5-4">
<span class="pos">2-5-4</span>
<div class="slidecontent"><p>Here are some <strong>example streams</strong>:</p>
<div id="stream_once"></div>

<div id="stream_secs"></div>

<div id="stream_tick"></div>

<div id="stream_source"></div>

<div id="stream_filter"></div></div></section><section class="slide" data-pos="2-5-5">
<span class="pos">2-5-5</span>
<div class="slidecontent"><p>This was fun! Here&#39;s <strong>a few more</strong>:</p>
<div id="stream_click"></div>

<div id="stream_speed"></div>

<div id="stream_total"></div>

<div id="stream_ping"></div>

<div id="stream_pong"></div></div></section><section class="slide" data-pos="2-5-6">
<span class="pos">2-5-6</span>
<div class="slidecontent"><p>To give you a sense of the <strong>size of RxJS</strong> - remember the <strong>super simple clicker example</strong> from when we talked about zones?</p>
<p><img src="resources/images/bottlesofbeer.png" alt=""></p>
</div></section><section class="slide" data-pos="2-5-7">
<span class="pos">2-5-7</span>
<div class="slidecontent"><p>Here&#39;s an <strong>implementation written with CycleJS</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Clicker</span>(<span class="hljs-params">{DOM}</span>)</span>{
  <span class="hljs-keyword">const</span> click$ = DOM.select(<span class="hljs-string">'button'</span>).events(<span class="hljs-string">'click'</span>)
  <span class="hljs-keyword">const</span> count$ = click$.mapTo(<span class="hljs-number">1</span>).startWith(<span class="hljs-number">3</span>).scan(
    <span class="hljs-function">(<span class="hljs-params">acc,seed</span>)=&gt;</span>(acc||<span class="hljs-number">0</span>)+seed
  )
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">DOM</span>: count$.map(<span class="hljs-function"><span class="hljs-params">count</span>=&gt;</span> div([
      div([count+ <span class="hljs-string">' bottles of beer on the wall'</span>]),
      button([<span class="hljs-string">'Buy more'</span>])
    ]))
  };
}
</code></pre>
</div></section><section class="slide" data-pos="2-5-8">
<span class="pos">2-5-8</span>
<div class="slidecontent"><p>CycleJS is a very different beast that is <strong>solely based on streams</strong> which makes for <strong>a very different programming experience</strong>, as you just saw!</p>
<p>But, the details of this are a <strong>story for another time</strong>.</p>
</div></section><section class="slide" data-pos="2-5-9">
<span class="pos">2-5-9</span>
<div class="slidecontent"><p>However, in CycleJS you can <strong>choose which stream library to use</strong>.</p>
<p>Here&#39;s a <strong>size comparison</strong> for CycleJS clicker apps between <strong><code>rxjs</code></strong> and another lib called <strong><code>xstream</code></strong>:</p>
<p><img src="resources/images/streamsizediffs.png" alt=""></p>
</div></section><section class="slide" data-pos="2-5-10">
<span class="pos">2-5-10</span>
<div class="slidecontent"><p>As you noticed, <strong><code>rxjs</code> is a beast</strong>. And as streams aren&#39;t central to Angular, there&#39;s been some <strong>critisism</strong> that rxjs needlessly <strong>bloats the size of Angular apps</strong>.</p>
</div></section><section class="slide" data-pos="2-5-11">
<span class="pos">2-5-11</span>
<div class="slidecontent"><p>But there are also those who <strong>appreciated the opportunity</strong> to use the precense of RxJS in Angular as an excuse to <strong>learn streams</strong> by finding a <strong>use in their apps</strong> for it!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>2-6.</span> SystemJS</h3>
      <p>on-demand loader</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="2-6-1">
<span class="pos">2-6-1</span>
<div class="slidecontent"><p><a href="https://github.com/systemjs/systemjs">SystemJS</a> is a</p>
<blockquote>
<p>universal dynamic module loader - loads ES6 modules, AMD, CommonJS and global scripts in the browser and NodeJS</p>
</blockquote>
</div></section><section class="slide" data-pos="2-6-2">
<span class="pos">2-6-2</span>
<div class="slidecontent"><p>This means that if your code is modularised into files using any of those formats, <strong>SystemJS</strong> will let you <strong>run that code in the browser</strong>.</p>
</div></section><section class="slide" data-pos="2-6-3">
<span class="pos">2-6-3</span>
<div class="slidecontent"><p>If your code is using <strong>modern features</strong> that need to be dumbed down for the browser, SystemJS will <strong>need a transpiler</strong>.</p>
<p>There are therefore plugins to use <strong>Babel</strong>, <strong>Traceur</strong> or <strong>TypeScript</strong>.</p>
</div></section><section class="slide" data-pos="2-6-4">
<span class="pos">2-6-4</span>
<div class="slidecontent"><p>You use SystemJS by <strong>including is as a script tag</strong> in your html file:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"node_modules/systemjs/dist/system.src.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>This will create the <code>System</code> global object.</p>
</div></section><section class="slide" data-pos="2-6-5">
<span class="pos">2-6-5</span>
<div class="slidecontent"><p>You will then likely need to do some <strong>configuring</strong>, for example giving the path to the <code>node_modules</code> directory.</p>
<pre><code class="lang-javascript">System.config(myConfigObj);
</code></pre>
<p>This is traditionally done in a <strong>separate config file</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"systemjs.config.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="2-6-6">
<span class="pos">2-6-6</span>
<div class="slidecontent"><p>Now you can <strong>start your application</strong> by <code>import</code>ing the module containing the starting point:</p>
<pre><code>System.<span class="hljs-keyword">import</span>(<span class="hljs-string">'app.js'</span>);
</code></pre></div></section><section class="slide" data-pos="2-6-7">
<span class="pos">2-6-7</span>
<div class="slidecontent"><p>Since SystemJS will be loading the non-starting files on the fly as they are needed, it <strong>works best if you load your html file with a web server</strong>.</p>
<p>Otherwise you risk being hampered by disallowed cross origin HTTP requests.</p>
</div></section><section class="slide" data-pos="2-6-8">
<span class="pos">2-6-8</span>
<div class="slidecontent"><p>So in essence, SystemJS is a way to do <strong>transpiling and bundling in the browser</strong>.</p>
<p>This is useful for <strong>quick prototyping and experimenting</strong> as it means we don&#39;t need webpack/browserify or something similar, but for <strong>production it is recommended that you serve a precompiled bundle</strong>.</p>
</div></section><section class="slide question" data-pos="2-6-9">
<span class="pos">2-6-9</span>
<div class="slidecontent">
<p>What then is the <strong>connection to Angular</strong>?</p>
</div></section><section class="slide answer" data-pos="2-6-10">
<span class="pos">2-6-10</span>
<div class="slidecontent">
<p><strong>None at all</strong>! Except that they <strong>use SystemJS for their official <a href="https://angular.io/docs/ts/latest/quickstart.html">Quickstart</a></strong></p>
<p>This is likely also the reason that it <strong>keeps popping up in 3rd party articles</strong> related to Angular.</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 3 / 13</span>
    <h2>Components 101</h2>
    <p>The building blocks</p>
</p>
  </div>
  
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. Component basics</li>
<li>2. Component styling</li>
<li>3. Reading model values</li>
<li>4. Template expressions</li>
<li>5. Built-in directives</li>
<li>6. Gamebook - dynamism</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>3-1.</span> Component basics</h3>
      <p>The primary building block</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="3-1-1">
<span class="pos">3-1-1</span>
<div class="slidecontent"><p>Unlike its predecessor AngularJS, <strong>Angular is component centric</strong>.</p>
<p>The vast <strong>majority of your code</strong> is likely to be <strong>made up by components</strong>.</p>
</div></section><section class="slide" data-pos="3-1-2">
<span class="pos">3-1-2</span>
<div class="slidecontent"><p>Much of <strong>what was housed in controllers</strong> in AngularJS has <strong>moved into components</strong> in Angular.</p>
<p>So, let&#39;s <strong>learn about components</strong>!</p>
</div></section><section class="slide" data-pos="3-1-3">
<span class="pos">3-1-3</span>
<div class="slidecontent"><p>In Angular, components are made up by <strong>two parts</strong>:</p>
<ul>
<li>A <strong>model</strong>, represented by a <strong><code>class</code></strong>, to hold <strong>values</strong>, <strong>methods</strong> and <strong>lifecycle hooks</strong>.</li>
<li>A <strong>view</strong>, represented as <strong>decorated metadata</strong> on the class, to hold <strong>template</strong> and related things.</li>
</ul>
</div></section><section class="slide" data-pos="3-1-4">
<span class="pos">3-1-4</span>
<div class="slidecontent"><p>This can be translated to the following <strong>structure map</strong>:</p>
<p><img src="resources/diagrams/component.svg" alt=""></p>
</div></section><section class="slide" data-pos="3-1-5">
<span class="pos">3-1-5</span>
<div class="slidecontent"><p>In the <strong>template</strong> we can <strong>read values from the model</strong>:</p>
<p><img src="resources/diagrams/component-read.svg" alt=""></p>
</div></section><section class="slide" data-pos="3-1-6">
<span class="pos">3-1-6</span>
<div class="slidecontent"><p>Also we can use <strong>model methods as event handlers</strong> in the template...</p>
<p><img src="resources/diagrams/component-read-write.svg" alt=""></p>
</div></section><section class="slide" data-pos="3-1-7">
<span class="pos">3-1-7</span>
<div class="slidecontent"><p>...which <strong>causes the values to change</strong> and to be <strong>read again</strong>.</p>
<p><img src="resources/diagrams/component-read-write-change.svg" alt=""></p>
<p>Thus we get a <strong>uni-directional dataflow</strong> on a component scale.</p>
</div></section><section class="slide" data-pos="3-1-8">
<span class="pos">3-1-8</span>
<div class="slidecontent"><p>We can <strong>boil the cycle down</strong> to this:</p>
<p><img src="resources/diagrams/view-model.svg" alt=""></p>
<p>Understanding this cycle is <strong>absolutely central</strong> in learning about components!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>3-2.</span> Component styling</h3>
      <p>putting on the makeup</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="3-2-1">
<span class="pos">3-2-1</span>
<div class="slidecontent"><p>As you&#39;ve already seen flash by, the <strong><code>Component</code> metadata can have a <code>styles</code> property</strong>:</p>
<pre><code><span class="hljs-string">styles:</span> [<span class="hljs-string">'h1 {text-decoration: none;}'</span>]
</code></pre><p>It should contain an <strong>array of CSS strings</strong> that will be applied.</p>
</div></section><section class="slide" data-pos="3-2-2">
<span class="pos">3-2-2</span>
<div class="slidecontent"><p>As with the templates (which we just might have forgotten to mention!), we can also <strong>refer to external files</strong>:</p>
<pre><code><span class="hljs-string">styleUrls:</span> [<span class="hljs-string">'app/css/usersection.css'</span>]
</code></pre></div></section><section class="slide question" data-pos="3-2-3">
<span class="pos">3-2-3</span>
<div class="slidecontent">
<p>But, wait a minute. If we&#39;re just throwing <strong>regular CSS</strong> at the component, then <strong>how is it scoped</strong>?</p>
<p>Won&#39;t these styles just <strong>apply to everything</strong>?</p>
</div></section><section class="slide answer" data-pos="3-2-4">
<span class="pos">3-2-4</span>
<div class="slidecontent">
<p>Excellent question! As usual, <strong>it depends</strong>. :) </p>
<p>Specifically, it depends on our selected level of <strong>view encapsulation</strong>!</p>
</div></section><section class="slide" data-pos="3-2-5">
<span class="pos">3-2-5</span>
<div class="slidecontent"><p>Angular offers <strong>two approaches</strong> for rendering components:</p>
<ul>
<li>as <strong>regular HTML</strong> (meaning no encapsulation)</li>
<li>as <strong><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM">Shadow DOM</a></strong> (meaning full encapsulation)</li>
</ul>
<p>Shadow DOM, as an elevator pitch, is a way to have <strong>tiny contained documents</strong> within the larger document.</p>
</div></section><section class="slide question" data-pos="3-2-6">
<span class="pos">3-2-6</span>
<div class="slidecontent">
<p>...you mean <strong>like <code>iframes</code></strong>?</p>
</div></section><section class="slide answer" data-pos="3-2-7">
<span class="pos">3-2-7</span>
<div class="slidecontent">
<p>No, yuck!</p>
<p>Well, ok, yes. Sort of. But with <strong>controlled ways to interact with the context</strong>.</p>
</div></section><section class="slide" data-pos="3-2-8">
<span class="pos">3-2-8</span>
<div class="slidecontent"><p>We control encapsulation through the <strong><code>encapsulation</code> metadata property</strong>. It has <strong>three possible values</strong>:</p>
<table class="deflist">
  <tr>
    <td>Native</td>
    <td>Assume <strong>native shadow DOM</strong> support in the browser (which few have)</td>
  </tr>
  <tr>
    <td>Emulated</td>
    <td>Use an Angular-included <strong>emulation of shadow DOM</strong>. This is the <strong>default</strong></td>
  </tr>
  <tr>
    <td>None</td>
    <td>Render component as <strong>regular HTML</strong></td>
  </tr>
</table></div></section><section class="slide" data-pos="3-2-9">
<span class="pos">3-2-9</span>
<div class="slidecontent"><p>There are <strong>constants for the modes</strong> on the core-provided <code>ViewEncapsulation</code> object, so configuration looks like this:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  encapsulation: ViewEncapsulation.None,
  ...
</code></pre>
</div></section><section class="slide" data-pos="3-2-10">
<span class="pos">3-2-10</span>
<div class="slidecontent"><p>The shadow DOM has some <strong>useful pseudo selectors</strong>:</p>
<ul>
<li><strong><code>:host</code></strong> matching the <strong>containing element</strong></li>
<li><strong><code>:host-context()</code></strong> which lets us <strong>test the host context</strong> </li>
</ul>
<p>Likely you&#39;ll only use <code>:host</code>.</p>
</div></section><section class="slide" data-pos="3-2-11">
<span class="pos">3-2-11</span>
<div class="slidecontent"><p>And likely you&#39;re fine with the <strong><code>Emulated</code> default</strong>, so for normal development you <strong>won&#39;t have to care at all</strong>!</p>
<p>The <strong>only things to remember</strong> are that...</p>
<ul>
<li>you can <strong>style the containing element with <code>:host</code></strong></li>
<li>styles are <strong>scoped to the component</strong> (by default)</li>
</ul>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>3-3.</span> Reading model values</h3>
      <p>and he went hither</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="3-3-1">
<span class="pos">3-3-1</span>
<div class="slidecontent"><p>Let&#39;s get this show going by looking at how the <strong>view reads values from the model</strong>!</p>
<p><img src="resources/diagrams/view-model-values.svg" alt=""></p>
</div></section><section class="slide" data-pos="3-3-2">
<span class="pos">3-3-2</span>
<div class="slidecontent"><p>The template can read values from the model by using <strong>interpolation</strong>. Anything <strong>within double braces</strong> is evaluated as a <strong>model property</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app'</span>,
  template: <span class="hljs-string">`&lt;p&gt;Hello, {{name}}!&lt;/p&gt;`</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
  name = <span class="hljs-string">'world'</span>
}
</code></pre>
<p>See also the <a href="resources/supportsite/demos/hellosomeone" target="_blank">Hello someone</a> demo.</p>
</div></section><section class="slide question" data-pos="3-3-3">
<span class="pos">3-3-3</span>
<div class="slidecontent">
<p>But <strong>what if the value isn&#39;t static</strong>? Let&#39;s say we <strong>change our model</strong> to update <code>&#39;world&#39;</code> to <code>&#39;WORLD&#39;</code> after 1 second:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> AppComponent {
  name = <span class="hljs-string">'world'</span>
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> <span class="hljs-keyword">this</span>.name=<span class="hljs-string">'WORLD'</span>,<span class="hljs-number">1000</span>)
  }
}
</code></pre>
<p>To handle this, <strong>what do we need to do</strong>?</p>
</div></section><section class="slide answer" data-pos="3-3-4">
<span class="pos">3-3-4</span>
<div class="slidecontent">
<p><strong>Nothing</strong>! This is the <code>zone</code> thing that we mentioned earlier. Zone enables Angular to <strong>check all bindings at every point in time when something might have changed</strong>, and update references accordingly.</p>
<p>See for yourself in the <a href="resources/supportsite/demos/hellochanging" target="_blank">Hello Changing</a> demo.</p>
</div></section><section class="slide" data-pos="3-3-5">
<span class="pos">3-3-5</span>
<div class="slidecontent"><p>Interpolation <strong>isn&#39;t just for text nodes</strong> - sometimes we want <strong>model values in element properties</strong> too:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app'</span>,
  template: <span class="hljs-string">`&lt;input placeholder="{{helpText}}"&gt;`</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
  helpText = <span class="hljs-string">"Enter your name..."</span> 
}
</code></pre>
</div></section><section class="slide" data-pos="3-3-6">
<span class="pos">3-3-6</span>
<div class="slidecontent"><p>Side note - remember our earlier look at the <strong>difference between a property and an attribute</strong>!</p>
<ul>
<li>an <strong>attribute</strong> is an attribute on the HTML element</li>
<li>a <strong>property</strong> is a property on the resulting DOM node.</li>
</ul>
</div></section><section class="slide" data-pos="3-3-7">
<span class="pos">3-3-7</span>
<div class="slidecontent"><p>Since we are writing HTML code you&#39;d <strong>think we&#39;re dealing with attribute</strong>, but as <strong>Angular deals exclusively with properties</strong> (well, almost) we will use that word instead.</p>
</div></section><section class="slide" data-pos="3-3-8">
<span class="pos">3-3-8</span>
<div class="slidecontent"><p>Back to interpolation - those <strong>double brackets in a string really aren&#39;t pretty</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"{{helpText}}"</span>&gt;</span>
</code></pre>
<p>But there is an <strong>alternative syntax for properties</strong> which is more explicit, namely the <strong><code>bind-</code> prefix</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">bind-placeholder</span>=<span class="hljs-string">"helpText"</span>&gt;</span>
</code></pre>
<p>These two lines are <strong>completely equivalent</strong>.</p>
</div></section><section class="slide" data-pos="3-3-9">
<span class="pos">3-3-9</span>
<div class="slidecontent"><p>The <code>bind-</code> prefix is prettier but still <strong>rather verbose</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">bind-placeholder</span>=<span class="hljs-string">"helpText"</span>&gt;</span>
</code></pre>
<p>...so quickly the <strong>bracket shorthand</strong> became popular:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> [<span class="hljs-attr">placeholder</span>]=<span class="hljs-string">"helpText"</span>&gt;</span>
</code></pre>
<p>This is still <strong>equivalent to the previous versions</strong>.</p>
</div></section><section class="slide" data-pos="3-3-10">
<span class="pos">3-3-10</span>
<div class="slidecontent"><p>See the <strong>different syntaxes side by side</strong> in the <a href="resources/supportsite/demos/property" target="_blank">Property</a> demo.</p>
<p>And note again that the <code>bind-</code> and bracket syntaxes are <strong>just for attributes</strong>. Inside a <strong>text node</strong> there is no choice, we must use <strong>double braces</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>3-4.</span> Template expressions</h3>
      <p>uncovering the lie</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="3-4-1">
<span class="pos">3-4-1</span>
<div class="slidecontent"><p>We&#39;ve now seen how to <strong>reference model properties</strong> in the view:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app'</span>,
  template: <span class="hljs-string">'&lt;p&gt;Hello {{name}}&lt;/p&gt;'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
  name = <span class="hljs-string">"Batman"</span>
}
</code></pre>
</div></section><section class="slide" data-pos="3-4-2">
<span class="pos">3-4-2</span>
<div class="slidecontent"><p>But we are actually <strong>not limited to referencing properties</strong>!</p>
<p>The code inside the interpolation/binding is called a <strong>template expression</strong>, and it is evaluated much like JavaScript:</p>
<pre><code class="lang-html">You finished {{place === 1 ? &#39;FIRST!!&#39; : &#39;in &#39;+ place + &#39; place&#39;}}
</code></pre>
</div></section><section class="slide" data-pos="3-4-3">
<span class="pos">3-4-3</span>
<div class="slidecontent"><p>But <strong>not exactly like JavaScript</strong> expressions. Here are <strong>some important limitations</strong>:</p>
<ul>
<li>we <strong>can&#39;t do side effects</strong>, only pure expressions</li>
<li>we can <strong>only reference model properties and methods</strong>, global variables are out of reach</li>
</ul>
</div></section><section class="slide list" data-pos="3-4-4">
<span class="pos">3-4-4</span>
<div class="slidecontent">
<p>There are also <strong>some additions</strong> when compared to JavaScript:</p>
<ul>
<li><span>a</span>The <strong>pipe operator</strong> </li>
<li><span>b</span>The <strong>safe navigation operator</strong></li>
</ul>
<p>Let&#39;s briefly touch on these!</p>
</div></section><section class="slide num numA" data-pos="3-4-5">
<span class="pos">3-4-5</span>
<div class="slidecontent">
<p>The <strong>pipe operator</strong> is familiar to AngularJS developers as a <strong>convenient way to call functions</strong> inside templates:</p>
<pre><code class="lang-javascript">userName | UpperCase
</code></pre>
<p>We&#39;ll dig deeper into pipes later!</p>
</div></section><section class="slide num numB" data-pos="3-4-6">
<span class="pos">3-4-6</span>
<div class="slidecontent">
<p>The <strong>safe navigation operator</strong> is recognisable from many other languages, for example <a href="http://coffeescript.org/">CoffeeScript</a>. It allows us to <strong>dig into objects without erroring</strong> if some step is undefined:</p>
<pre><code><span class="hljs-selector-tag">user</span><span class="hljs-selector-class">.address</span>?<span class="hljs-selector-class">.street</span>
</code></pre></div></section><section class="slide" data-pos="3-4-7">
<span class="pos">3-4-7</span>
<div class="slidecontent"><p>Note that this is <strong>in contrast with AngularJS</strong>, where <strong>object navigating was inherently safe</strong> in their version of the template expressions.</p>
</div></section><section class="slide" data-pos="3-4-8">
<span class="pos">3-4-8</span>
<div class="slidecontent"><p>Even though the <strong>template expressions are powerful</strong>, you should <strong>strive to keep them as simple as possible</strong>.</p>
<p>More <strong>complex logic should be done in the model</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>3-5.</span> Built-in directives</h3>
      <p>Not made to order</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="3-5-1">
<span class="pos">3-5-1</span>
<div class="slidecontent"><p>Although the <strong>subject of conversation is Components</strong>, we still <strong>need to talk about Directives</strong>. And actually, <strong>Components are a sub-group of Directives</strong>.</p>
<p>A directive, in the broad term, simply means <strong>something we put in the HTML that has special meaning</strong>. It <strong>directs the browser</strong> in how it should behave.</p>
</div></section><section class="slide" data-pos="3-5-2">
<span class="pos">3-5-2</span>
<div class="slidecontent"><p>Like with AngularJS, a big part of learning the framework means <strong>learning what is already there</strong>!</p>
<p>We&#39;ll know <strong>explore what&#39;s already there in Angular</strong>, but first a <strong>word of warning</strong>: The demos we&#39;ll see will <strong>include concepts we&#39;ve yet to explore</strong>! Don&#39;t let those get you down, we&#39;ll cover them soon enough.</p>
</div></section><section class="slide list" data-pos="3-5-3">
<span class="pos">3-5-3</span>
<div class="slidecontent">
<p>So! In the case of <strong>Angular and directives</strong>, we get <strong>five of them</strong> to use in everyday templating. There are <strong>three structural directives</strong>...</p>
<ul>
<li><span>a</span>ngFor</li>
<li><span>b</span>ngIf</li>
<li><span>c</span>ngSwitch</li>
</ul>
<p>...and <strong>two helpers</strong>:</p>
<ul>
<li><span>d</span>ngClass</li>
<li><span>e</span>ngStyle</li>
</ul>
</div></section><section class="slide num numA" data-pos="3-5-4">
<span class="pos">3-5-4</span>
<div class="slidecontent">
<p>First <strong><code>ngFor</code></strong>, which as the name implies is a helper for <strong>rendering lists</strong>: </p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let msg of messages"</span>&gt;</span>{{ msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>This will <strong>repeat the <code>div</code> for every item in the <code>messages</code> array</strong>.</p>
</div></section><section class="slide" data-pos="3-5-5">
<span class="pos">3-5-5</span>
<div class="slidecontent"><p>Noticed the scary <strong><code>*</code> character</strong> prefixing <code>ngFor</code>? That is a <strong>shorthand</strong>, which expands to this:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> <span class="hljs-attr">ngFor</span> <span class="hljs-attr">let-msg</span> [<span class="hljs-attr">ngForOf</span>]=<span class="hljs-string">"messages"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
</code></pre>
<p>All <strong>structural directives</strong>, who <strong>change the HTML structure</strong>, uses the <strong>same <code>*</code> syntax</strong>.</p>
</div></section><section class="slide" data-pos="3-5-6">
<span class="pos">3-5-6</span>
<div class="slidecontent"><p>You can <strong>see both variants</strong> of the for loop in the <a href="resources/supportsite/demos/forloop" target="_blank">Forloop</a> demo.</p>
</div></section><section class="slide num numB" data-pos="3-5-7">
<span class="pos">3-5-7</span>
<div class="slidecontent">
<p>Equally mandatory as <code>ngFor</code> is the <strong><code>ngIf</code></strong> directive, which lets you <strong>optionally display something</strong> given the truthiness of an expression.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"flag"</span>&gt;</span>I only show when flag is true!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</code></pre>
<p><strong>See this live</strong> in the <a href="resources/supportsite/demos/if" target="_blank">If</a> demo.</p>
</div></section><section class="slide" data-pos="3-5-8">
<span class="pos">3-5-8</span>
<div class="slidecontent"><p>What if we have an <strong><code>if-else</code></strong> situation? There are two approaches;</p>
<ul>
<li>Simply use <strong>two <code>ngIf</code> with inverted clauses</strong> as in the <a href="resources/supportsite/demos/ifelse" target="_blank">IfElse</a> demo.</li>
<li>Pick a connected <strong><code>ng-template</code></strong> as in the <a href="resources/supportsite/demos/ifelsetemplate" target="_blank">IfElseTemplate</a> demo.</li>
</ul>
</div></section><section class="slide num numC" data-pos="3-5-9">
<span class="pos">3-5-9</span>
<div class="slidecontent">
<p>Then <strong><code>ngSwitch</code></strong>, which of course <strong>emulates a switch statement</strong> in the template. </p>
<p>But! We&#39;re actually <strong>not going to go into detail</strong>, as <code>ngSwitch</code> is <strong>rarely useful</strong>.</p>
</div></section><section class="slide" data-pos="3-5-10">
<span class="pos">3-5-10</span>
<div class="slidecontent"><p>Such logic often <strong>belongs in the model</strong>, a subject we&#39;ll come back to.</p>
<p>If you&#39;re curious anyway, <strong>check out</strong> the <a href="resources/supportsite/demos/switch" target="_blank">Switch</a> demo.</p>
</div></section><section class="slide num numD" data-pos="3-5-11">
<span class="pos">3-5-11</span>
<div class="slidecontent">
<p>Now <strong><code>ngClass</code></strong> which can <strong>dynamically set a single style</strong>...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">class.someClass</span>]=<span class="hljs-string">"someCondition"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>...or <strong>many</strong> (keys are classes, values are conditions) :</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngClass</span>]=<span class="hljs-string">"someObject"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><strong>Try it</strong> in the <a href="resources/supportsite/demos/class-single" target="_blank">Class Single</a> and <a href="resources/supportsite/demos/class-many" target="_blank">Class Many</a> demos.</p>
</div></section><section class="slide num numE" data-pos="3-5-12">
<span class="pos">3-5-12</span>
<div class="slidecontent">
<p>Finally <strong><code>ngStyle</code></strong>! Much like with <code>ngSwitch</code> we <strong>advise against using this directive</strong> for normal usage.</p>
<p>If you want to dynamically <strong>alter the style for an element</strong> - which is what it lets you do - it is <strong>better to add/remove a CSS class</strong> with <code>ngClass</code>.</p>
</div></section><section class="slide" data-pos="3-5-13">
<span class="pos">3-5-13</span>
<div class="slidecontent"><p>There are however <strong>two good reasons</strong> for using <code>ngStyle</code>:</p>
<ul>
<li>The <strong>styles depend on state</strong> (think x- and y coordinates in a game)</li>
<li>We&#39;re doing full-blown <strong>CSS in JS</strong></li>
</ul>
</div></section><section class="slide" data-pos="3-5-14">
<span class="pos">3-5-14</span>
<div class="slidecontent"><p>But, if you are curious, <strong>check</strong> the <a href="resources/supportsite/demos/style-single" target="_blank">Style Single</a> and <a href="resources/supportsite/demos/style-many" target="_blank">Style Many</a> demos.</p>
</div></section><section class="slide" data-pos="3-5-15">
<span class="pos">3-5-15</span>
<div class="slidecontent"><p>In this course we&#39;ll be focusing mostly on Components, but there&#39;s definitely <strong>more to say on directives</strong>.</p>
<p>See the Appendix for more details!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>3-6.</span> Gamebook - dynamism</h3>
      <p>hello someone</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="3-6-1">
<span class="pos">3-6-1</span>
<div class="slidecontent"><p>Let&#39;s revisit our Gamebook project! To start off,</p>
<ol>
<li><strong>copy the folder for the first version</strong>,</li>
<li><strong>paste it</strong> right next to the first version, and</li>
<li>give it the name <strong><code>FF02-dynamic</code></strong>.</li>
</ol>
</div></section><section class="slide list" data-pos="3-6-2">
<span class="pos">3-6-2</span>
<div class="slidecontent">
<p>A static gamebook won&#39;t get us very far. Let&#39;s make it <strong>show dynamic cata</strong> instead!</p>
<p>Here&#39;s the <strong>plan</strong> - we need to:</p>
<ul>
<li><span>a</span><strong>package the scene data</strong> somewhere </li>
<li><span>b</span>make the <strong>component fetch data</strong></li>
<li><span>c</span>make the template <strong>read data from that prop</strong></li>
</ul>
</div></section><section class="slide num numA" data-pos="3-6-3">
<span class="pos">3-6-3</span>
<div class="slidecontent">
<p>Having the <strong>scene data hard-coded in the component</strong> won&#39;t get us very far.</p>
<p>Let&#39;s <strong>create a new file <code>data.ts</code></strong> for the data to live in!</p>
</div></section><section class="slide" data-pos="3-6-4">
<span class="pos">3-6-4</span>
<div class="slidecontent"><p>The data file should <strong>export a single object</strong> containing our data. But let&#39;s look ahead - we&#39;re <strong>going to need more than one scene</strong>.</p>
<p>Therefore we should make the data file <strong>contain a full <code>adventure</code></strong>!</p>
</div></section><section class="slide" data-pos="3-6-5">
<span class="pos">3-6-5</span>
<div class="slidecontent"><p>The <strong>adventure object</strong> could look something like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myAdventure = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">'A strange adventure'</span>,
  <span class="hljs-attr">scenes</span>: {
    <span class="hljs-attr">someScene</span>: { ...scene data goes here... }
    <span class="hljs-comment">// later there'll be more scenes here</span>
  }
}
</code></pre>
</div></section><section class="slide" data-pos="3-6-6">
<span class="pos">3-6-6</span>
<div class="slidecontent"><p>Note that we chose to <strong>store scenes in an object</strong> as opposed to an <strong>array</strong>. If we chose an array instead, a link to scene 7 would break if we later insert a new scene at position 4, leading to a more brittle structure.</p>
</div></section><section class="slide" data-pos="3-6-7">
<span class="pos">3-6-7</span>
<div class="slidecontent"><p>The <strong>scene object</strong> needs to contain...</p>
<ul>
<li><strong>title</strong></li>
<li><strong>img url</strong></li>
<li><strong>text</strong></li>
<li><strong>options array</strong> (a list of strings, for now)</li>
</ul>
<p>Only <strong>make one single scene</strong> for now, containing what is <strong>currently in the template</strong>.</p>
</div></section><section class="slide num numB" data-pos="3-6-8">
<span class="pos">3-6-8</span>
<div class="slidecontent">
<p>Now we <strong>adapt the component</strong> in <code>app.ts</code>:</p>
<ul>
<li><strong>Import the adventure</strong> into the file</li>
<li><strong>Add an <code>adventure</code> prop</strong> to the component</li>
<li><strong>Initialise that prop</strong> to the imported adventure data</li>
<li><strong>Add a <code>scene</code> property</strong> to the component</li>
<li><strong>Initialise that prop</strong> to the only scene in <code>this.adventure</code></li>
</ul>
</div></section><section class="slide num numC" data-pos="3-6-9">
<span class="pos">3-6-9</span>
<div class="slidecontent">
<p>Having done that, <strong>adapt the <code>template</code></strong> to <strong>read the data from the <code>scene</code> prop</strong> instead! It will end up containing a <strong>bunch of interpolations</strong> referencing <code>scene.title</code>, etc.</p>
<p>It should <strong>also show <code>adventure.title</code></strong> up top!</p>
<p>Now, the template is an <strong>actual template</strong>, capable of rendering any scene we throw at it.</p>
</div></section><section class="slide" data-pos="3-6-10">
<span class="pos">3-6-10</span>
<div class="slidecontent"><p><strong>Bundle</strong> your code as before (<code>node build nameoffolder</code> in the root), open <code>index.html</code> and <strong>make sure things still work</strong>!</p>
<p>There&#39;ll be <strong>no visible difference</strong> from the previous version, we&#39;ve just done some <strong>preparation work</strong> for what is to come.</p>
</div></section><section class="slide challenge" data-pos="3-6-11">
<span class="pos">3-6-11</span>
<div class="slidecontent"><p><strong>Challenge</strong>: If you have time over, let&#39;s employ some <strong>TypeScript power</strong>! </p>
<p>If you take on this challenge there will be <strong>further TypeScript challenges</strong> building on this one in the following exercises.</p>
</div></section><section class="slide list" data-pos="3-6-12">
<span class="pos">3-6-12</span>
<div class="slidecontent">
<p>The plan is to make use of <strong>TypeScript interfaces</strong> to get code completion for adventure and scene data!</p>
<ul>
<li><span>a</span>Create a <strong>new file</strong> to house the interfaces</li>
<li><span>b</span>Export an <strong>interface describing the scene object</strong></li>
<li><span>c</span>Export an <strong>interface describing the adventure object</strong></li>
<li><span>d</span>Make the <strong>data file use the adventure interface</strong></li>
</ul>
</div></section><section class="slide num numA" data-pos="3-6-13">
<span class="pos">3-6-13</span>
<div class="slidecontent">
<p>In a big project you would likely have <strong>one interface per file</strong>, but we can put them all in a single file. </p>
<p>Create a file for this purpose called <code>interfaces.ts</code>!</p>
</div></section><section class="slide num numB" data-pos="3-6-14">
<span class="pos">3-6-14</span>
<div class="slidecontent">
<p>In that file we first export the <strong><code>Scene</code> interface</strong>.</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Scene {
  <span class="hljs-comment">// definition in here</span>
}
</code></pre>
<p>It should <strong>specify all four properties</strong> that a scene can contain. In the definition the <strong>keys are properties</strong> and the <strong>values are types</strong>!</p>
</div></section><section class="slide" data-pos="3-6-15">
<span class="pos">3-6-15</span>
<div class="slidecontent"><p>To say that a property is an <strong>array of something</strong>, as we need to do with the options, put a <strong>pair of brackets at the end of the type</strong>:</p>
<pre><code class="lang-typescript">  options: <span class="hljs-built_in">string</span>[]
</code></pre>
</div></section><section class="slide num numC" data-pos="3-6-16">
<span class="pos">3-6-16</span>
<div class="slidecontent">
<p>Now also add an <strong><code>Adventure</code> interface</strong> to the same file, describing the two adventure properties!</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Adventures {
  <span class="hljs-comment">// definition in here</span>
}
</code></pre>
</div></section><section class="slide" data-pos="3-6-17">
<span class="pos">3-6-17</span>
<div class="slidecontent"><p>The definition of <strong>the <code>scenes</code> prop</strong> (or <code>pages</code> or whatever you&#39;ve decided to call it) is a bit special since it is an object with <strong>any number of keys where each value is a scene</strong>! This has the <strong>following special syntax</strong>:</p>
<pre><code class="lang-typescript">  scenes: {
    [index: <span class="hljs-built_in">string</span>]: Scene
  }
</code></pre>
</div></section><section class="slide num numD" data-pos="3-6-18">
<span class="pos">3-6-18</span>
<div class="slidecontent">
<p>Now, in <code>data.ts</code>, <strong>add a type annotation to the exported object</strong> saying that it is of type <code>Adventure</code>!</p>
</div></section><section class="slide" data-pos="3-6-19">
<span class="pos">3-6-19</span>
<div class="slidecontent"><p>Not that we really need it yet, but we now have <strong>code completion for our data</strong>!</p>
<p><img src="resources/images/tscodecompl.png" alt=""></p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 4 / 13</span>
    <h2>Components 102</h2>
    <p>Much wants more</p>
</p>
  </div>
  
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. Gamebook - state</li>
<li>2. Catching View events</li>
<li>3. Lifecycle hooks</li>
<li>4. Politics</li>
<li>5. Debugging Angular apps</li>
<li>6. Gamebook - page turning</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>4-1.</span> Gamebook - state</h3>
      <p>storing position</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="4-1-1">
<span class="pos">4-1-1</span>
<div class="slidecontent"><p>Before we get started on advanced component API:s, let&#39;s do a little <strong>exercise prelude</strong>!</p>
</div></section><section class="slide" data-pos="4-1-2">
<span class="pos">4-1-2</span>
<div class="slidecontent"><p>As before;</p>
<ol>
<li><strong>copy the folder of the previous version</strong>,</li>
<li><strong>paste it</strong> right next to that version, and</li>
<li>give it the name <strong><code>FF03-state</code></strong>.</li>
</ol>
</div></section><section class="slide list" data-pos="4-1-3">
<span class="pos">4-1-3</span>
<div class="slidecontent">
<p>So! The plan is to <strong>introduce <code>gameState</code></strong> to our model, which should <strong>store the progress</strong> the player makes.</p>
<p>Here&#39;s the plan:</p>
<ul>
<li><span>a</span>Design the shape of the <code>GameState</code> data</li>
<li><span>b</span>Add a <code>startState</code> prop to the <code>adventure</code> data</li>
<li><span>c</span>Add a <code>gameState</code> prop to the component</li>
<li><span>d</span>Turn <code>scene</code> into a computed property</li>
</ul>
</div></section><section class="slide num numA" data-pos="4-1-4">
<span class="pos">4-1-4</span>
<div class="slidecontent">
<p>We begin by figuring out what the <strong>state of a game session</strong> looks like.</p>
<p>It really only needs to track <strong>one single thing</strong>, namely the <strong>key of the current page</strong>!</p>
</div></section><section class="slide" data-pos="4-1-5">
<span class="pos">4-1-5</span>
<div class="slidecontent"><p>But as the future might bring more stuff, let&#39;s put that into an <strong>object</strong> so we can add more things later!</p>
<p>So our state looks something like this:</p>
<pre><code class="lang-typescript">{
  atScene: <span class="hljs-string">'corridor'</span>
}
</code></pre>
</div></section><section class="slide" data-pos="4-1-6">
<span class="pos">4-1-6</span>
<div class="slidecontent"><p>If you&#39;re following along with the TypeScript stuff we should of course <strong>create an interface</strong> for this object, called <code>GameState</code> or something similar.</p>
</div></section><section class="slide num numB" data-pos="4-1-7">
<span class="pos">4-1-7</span>
<div class="slidecontent">
<p>It makes sense for the <strong>starting state</strong> to be <strong>part of the adventure data</strong>.</p>
<p>After all, only the author of the adventure knows <strong>which page to start at</strong> (and how much gold to begin with, etc).</p>
</div></section><section class="slide" data-pos="4-1-8">
<span class="pos">4-1-8</span>
<div class="slidecontent"><p>Therefore, <strong>add a new <code>startState</code> prop to adventure</strong> in <code>data.ts</code>, containing an initial game state object with <code>atScene</code> pointing to the first page of the adventure.</p>
<p>Of course we only have one page right now, so use that as starting page!</p>
</div></section><section class="slide" data-pos="4-1-9">
<span class="pos">4-1-9</span>
<div class="slidecontent"><p>If you have an <strong><code>Adventure</code> interface</strong> that must now be <strong>updated to allow a <code>startState</code> prop</strong> of type <code>GameState</code>.</p>
</div></section><section class="slide num numC" data-pos="4-1-10">
<span class="pos">4-1-10</span>
<div class="slidecontent">
<p>Now, <strong>add a <code>gameState</code> property</strong> (or another name of your choosing) to our component class in <code>app.ts</code>, and <strong>initialise it</strong> to the start state according to the adventure.</p>
<pre><code class="lang-typescript">  gameState = <span class="hljs-keyword">this</span>.adventure.startState;
</code></pre>
</div></section><section class="slide num numD" data-pos="4-1-11">
<span class="pos">4-1-11</span>
<div class="slidecontent">
<p>Finally, let&#39;s <strong>turn our attention to the <code>scene</code> prop</strong>.</p>
<p>Right now we manually point it to the scene object inside the adventure:</p>
<pre><code><span class="hljs-attribute">  scene</span> = this.adenture.scenes[<span class="hljs-string">'corridor'</span>];
</code></pre></div></section><section class="slide" data-pos="4-1-12">
<span class="pos">4-1-12</span>
<div class="slidecontent"><p>But this doesn&#39;t make sense anymore, since the <strong>current scene can be computed</strong> by looking at <code>gameState</code> and <code>adventure</code>!</p>
<p>We might even risk introducing <strong>out-of-sync bugs</strong> if <code>gameState</code> and <code>scene</code> don&#39;t agree!</p>
</div></section><section class="slide" data-pos="4-1-13">
<span class="pos">4-1-13</span>
<div class="slidecontent"><p>We should therefore <strong>turn <code>scene</code> into a computed property</strong>.</p>
<p>Make <code>scene</code> a getter by <strong>using the <code>get</code> keyword and turning it into a method</strong>, which <strong>returns the correct scene</strong> by reading from <code>gameState</code> and <code>adventure</code>.</p>
</div></section><section class="slide" data-pos="4-1-14">
<span class="pos">4-1-14</span>
<div class="slidecontent"><p>For an <strong>example</strong> how that is done, see the <a href="resources/supportsite/demos/computedprop" target="_blank">Computed Property</a> demo.</p>
</div></section><section class="slide" data-pos="4-1-15">
<span class="pos">4-1-15</span>
<div class="slidecontent"><p>Now <strong>our small refactoring is done</strong>! Rebuild, and if it all fits together it will <strong>again work just like before</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>4-2.</span> Catching View events</h3>
      <p>What&#39;s up?</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="4-2-1">
<span class="pos">4-2-1</span>
<div class="slidecontent"><p>Now we take a look at <strong>the other half of the cycle</strong>!</p>
<p><img src="resources/diagrams/view-model-events.svg" alt=""></p>
</div></section><section class="slide" data-pos="4-2-2">
<span class="pos">4-2-2</span>
<div class="slidecontent"><p>Here is a <strong>super simple event catching example</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
    selector: <span class="hljs-string">'app'</span>,
    template: <span class="hljs-string">`
      &lt;button on-click="flag = !flag"&gt;Toggle!&lt;/button&gt;
      &lt;p&gt;Flag? {{flag}}&lt;/p&gt;
    `</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
  flag = <span class="hljs-literal">false</span>
}
</code></pre>
</div></section><section class="slide" data-pos="4-2-3">
<span class="pos">4-2-3</span>
<div class="slidecontent"><p>Take a <strong>closer look at the event handler</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">on-click</span>=<span class="hljs-string">"flag = !flag"</span>&gt;</span>Toggle!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
<p>The <code>on-click</code> attribute will be <strong>executed as code</strong> when the event happens.</p>
<p>Note that <code>on-click</code> is <strong>not a native DOM event handler</strong>. That would have been called <code>onclick</code>.</p>
</div></section><section class="slide" data-pos="4-2-4">
<span class="pos">4-2-4</span>
<div class="slidecontent"><p>But we really <strong>shouldn&#39;t mutate values in the view</strong> so let us <strong>call a method instead</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
    selector: <span class="hljs-string">'app'</span>,
    template: <span class="hljs-string">`
      &lt;button on-click="toggle()"&gt;Toggle!&lt;/button&gt;
      &lt;p&gt;Flag? {{flag}}&lt;/p&gt;
    `</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
  flag = <span class="hljs-literal">false</span>
  toggle() {
    <span class="hljs-keyword">this</span>.flag = !<span class="hljs-keyword">this</span>.flag;
  }
}
</code></pre>
</div></section><section class="slide" data-pos="4-2-5">
<span class="pos">4-2-5</span>
<div class="slidecontent"><p>Remember that we are <strong>not attaching a function</strong> but <strong>writing code that will run</strong> when the event happens. So <strong>don&#39;t write this</strong>...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">on-click</span>=<span class="hljs-string">"toggle"</span>&gt;</span>Toggle!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
<p>...since you likely mean this:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">on-click</span>=<span class="hljs-string">"toggle()"</span>&gt;</span>Toggle!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="4-2-6">
<span class="pos">4-2-6</span>
<div class="slidecontent"><p>Similar to how <code>[attr]</code> is a shortcut for <code>bind-attr</code>, we can use <strong><code>(event)</code> instead of  <code>on-event</code></strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"toggle()"</span>&gt;</span>Toggle!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="4-2-7">
<span class="pos">4-2-7</span>
<div class="slidecontent"><p>In case we are interested in event data, like if we catch a <code>keyup</code> event from an <code>input</code> element, Angular <strong>automatically creates an <code>$event</code> variable</strong> containing the DOM event object:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
    selector: <span class="hljs-string">'app'</span>,
    template: <span class="hljs-string">`
      &lt;input (keyup)="myName = $event.target.value"&gt;
      &lt;p&gt;Who am I? {{myName}}&lt;/p&gt;
    `</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
  myName: <span class="hljs-built_in">string</span>
}
</code></pre>
<p>See this in the <a href="resources/supportsite/demos/catch_event_variable" target="_blank">Catch event variable</a> demo</p>
</div></section><section class="slide" data-pos="4-2-8">
<span class="pos">4-2-8</span>
<div class="slidecontent"><p>As noted before we prefer to have <strong>value mutations in the model</strong>, so we should <strong>pass the event to the model</strong> instead:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> (<span class="hljs-attr">keyup</span>)=<span class="hljs-string">"setName($event.target.value)"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Who am I? {{myName}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</code></pre>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> AppComponent {
  myName: <span class="hljs-built_in">string</span>
  setName(txt) {
    <span class="hljs-keyword">this</span>.myName = txt;
  }
}
</code></pre>
</div></section><section class="slide" data-pos="4-2-9">
<span class="pos">4-2-9</span>
<div class="slidecontent"><p>Much like the <strong>template expressions</strong> are <em>sort of</em> JavaScript, so are the <strong>template statements</strong> that we use as event handlers. Most importantly, they also can <strong>only reach values and methods on the model</strong>.</p>
<p>There are <strong>more details</strong> in the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#!#template-statements">Template statement</a> sections of the official docs.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>4-3.</span> Lifecycle hooks</h3>
      <p>the lifespan milestones</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="4-3-1">
<span class="pos">4-3-1</span>
<div class="slidecontent"><p>We won&#39;t be using them in our project or go into too much detail, but we&#39;d be amiss if we didn&#39;t mention the <strong>lifecycle hooks</strong>.</p>
<p>These are magical method names that will be <strong>invoked at certain points</strong> in the lifecycle of a directive.</p>
</div></section><section class="slide" data-pos="4-3-2">
<span class="pos">4-3-2</span>
<div class="slidecontent"><p>For example, <strong><code>ngOnInit</code></strong> is called after the first render, and <strong><code>ngOnDestroy</code></strong> when it leaves the DOM.</p>
<p>You can see the <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">full list of methods</a> in the official docs, together with a demo component that shows off them all.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>4-4.</span> Politics</h3>
      <p>let&#39;s talk about the elephant</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="4-4-1">
<span class="pos">4-4-1</span>
<div class="slidecontent"><p>Let&#39;s zoom out for a while and <strong>discuss what we&#39;ve just learned</strong>. All of those directives can be called a <strong>DSL for templating</strong>, and <strong>most templating solutions have corresponding solutions</strong>.</p>
</div></section><section class="slide" data-pos="4-4-2">
<span class="pos">4-4-2</span>
<div class="slidecontent"><p>The reason is simple - we&#39;re <strong>working in HTML</strong> which <strong>isn&#39;t a logical language</strong>, but since we <strong>need logic</strong> in our template we <strong>have to add it</strong> somehow.</p>
</div></section><section class="slide" data-pos="4-4-3">
<span class="pos">4-4-3</span>
<div class="slidecontent"><p>This is in stark <strong>contrast to React</strong>, which <strong>expresses the templates in JavaScript</strong>. If you <strong>need a loop</strong> in a React component, you&#39;ll use a <strong>regular JavaScript loop</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Chores = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>)</span>{
  <span class="hljs-keyword">var</span> renderedChores = props.chores.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chore,n</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{n}</span>&gt;</span>{chore}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;
  });
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>My chores:<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>{renderedChores}<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
</div></section><section class="slide" data-pos="4-4-4">
<span class="pos">4-4-4</span>
<div class="slidecontent"><p>But! Since we need to <strong>output HTML</strong> in the end, React instead has a <strong>DSL for expressing nested data in JS</strong>, namely the weird xml syntax you saw inside the return statement.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>My chores:<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>{renderedChores}<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);
</code></pre>
</div></section><section class="slide" data-pos="4-4-5">
<span class="pos">4-4-5</span>
<div class="slidecontent"><p>Because here&#39;s the <strong>foundational problem</strong> - we...</p>
<ul>
<li><strong>express UI:s as nested data</strong></li>
<li><strong>perform logic to define the UI</strong></li>
</ul>
<p>...so we need <strong>both logic and nested data at the same time</strong>.</p>
</div></section><section class="slide" data-pos="4-4-6">
<span class="pos">4-4-6</span>
<div class="slidecontent"><p>It all <strong>boils down to this</strong>:</p>
<p><img src="resources/diagrams/theappproblem.svg" alt=""></p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>4-5.</span> Debugging Angular apps</h3>
      <p>bug hunting tools &amp; tricks</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="4-5-1">
<span class="pos">4-5-1</span>
<div class="slidecontent"><p>When debugging Angular apps, <strong>regular JS debugging tricks</strong> still apply to a large extent.</p>
<p>And the king of those is; make sure that you <strong>know the browser dev tools</strong>!</p>
</div></section><section class="slide list" data-pos="4-5-2">
<span class="pos">4-5-2</span>
<div class="slidecontent">
<p>We&#39;ll walk through <strong>three tips</strong> for debugging Angular apps:</p>
<ul>
<li><span>a</span>Augury</li>
<li><span>b</span>Bound JSON output</li>
<li><span>c</span>Logger services</li>
</ul>
</div></section><section class="slide num numA" data-pos="4-5-3">
<span class="pos">4-5-3</span>
<div class="slidecontent">
<p><a href="https://augury.angular.io/">Angular Augury</a> is a <strong>Chrome dev tools extension</strong> for Angular debugging, serving much the same purpose as Ng-Inspector and Batarang for AngularJS.</p>
<p><img src="resources/images/augury-logo.svg" style="max-width:100px; border: none; background-color: inherit;"></p>
</div></section><section class="slide" data-pos="4-5-4">
<span class="pos">4-5-4</span>
<div class="slidecontent"><p>Here&#39;s an in-action <strong>screenshot</strong> of what Augury looks like:</p>
<p><img src="resources/images/augury-action.png" alt=""></p>
</div></section><section class="slide" data-pos="4-5-5">
<span class="pos">4-5-5</span>
<div class="slidecontent"><p>As you can see, Augury shows us</p>
<ul>
<li>The <strong>component tree</strong></li>
<li>Component <strong>state</strong></li>
</ul>
<p>It also gives us powerful tooling around <strong>dependency graphs</strong> and <strong>route overviews</strong>.</p>
</div></section><section class="slide" data-pos="4-5-6">
<span class="pos">4-5-6</span>
<div class="slidecontent"><p>For components with <strong><code>Output</code></strong>s, Augury let&#39;s you <strong>trigger outputs</strong> for easy experimenting:</p>
<p><img src="resources/images/augury-output.png" alt=""></p>
</div></section><section class="slide" data-pos="4-5-7">
<span class="pos">4-5-7</span>
<div class="slidecontent"><p>Augury also has a <strong>bunch of other features</strong> that makes it well worth getting to know.</p>
<p>Of course, given the fickle nature of Angular, Augury is in <strong>heavy development</strong>.</p>
</div></section><section class="slide" data-pos="4-5-8">
<span class="pos">4-5-8</span>
<div class="slidecontent"><p>Also, note that <strong>Augury requires a web server</strong> to function! It <strong>won&#39;t work over the <code>file://</code> protocol</strong>.</p>
</div></section><section class="slide num numB" data-pos="4-5-9">
<span class="pos">4-5-9</span>
<div class="slidecontent">
<p>Now for a neat trick to <strong>debug component state</strong>!</p>
<p>Take our gamebook project for example, which now has <code>gameState</code>:</p>
<pre><code class="lang-typescript">gameState: GameState = {
  atScene: <span class="hljs-keyword">this</span>.adventure.startsAt
}
</code></pre>
</div></section><section class="slide" data-pos="4-5-10">
<span class="pos">4-5-10</span>
<div class="slidecontent"><p>Imagine how later on it will become <strong>much more complex</strong>:</p>
<pre><code class="lang-typescript">gameState: GameState = {
  atScene: <span class="hljs-keyword">this</span>.adventure.startsAt,
  gold: <span class="hljs-number">5</span>,
  inventory: [<span class="hljs-string">'sword'</span>, <span class="hljs-string">'shield'</span>],
  hp: <span class="hljs-number">12</span>,
  xp: <span class="hljs-number">3</span>
}
</code></pre>
</div></section><section class="slide" data-pos="4-5-11">
<span class="pos">4-5-11</span>
<div class="slidecontent"><p>It is quite common for apps to be <strong>driven by a central state</strong> like this, and for that state to <strong>change frequently</strong>.</p>
<p>Debugging will then often mean to <strong>check the contents of that state</strong>. How do we easily do that?</p>
</div></section><section class="slide" data-pos="4-5-12">
<span class="pos">4-5-12</span>
<div class="slidecontent"><p>A <strong>naïve way</strong> to debug this would be to sprinkle...</p>
<pre><code class="lang-typescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.gameState);
</code></pre>
<p>...in various places. This works ok, but quickly becomes <strong>cumbersome</strong>.</p>
</div></section><section class="slide" data-pos="4-5-13">
<span class="pos">4-5-13</span>
<div class="slidecontent"><p>Now for the trick: by <strong>adding this line to the template</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>{{gameState | json}}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
</code></pre>
<p>...we get a <strong>see the state live</strong> directly in the view!</p>
<p><img src="resources/images/jsondebug.png" alt=""></p>
</div></section><section class="slide" data-pos="4-5-14">
<span class="pos">4-5-14</span>
<div class="slidecontent"><p>Try this out in the <a href="resources/supportsite/demos/jsondebug" target="_blank">JSON debug</a> demo!</p>
<p>AngularJS developers will recognise this, as the <strong>exact same thing was possible in AngularJS</strong>!</p>
</div></section><section class="slide num numC" data-pos="4-5-15">
<span class="pos">4-5-15</span>
<div class="slidecontent">
<p>While debugging an app, you inevitably start <strong>sprinkling <code>console.log</code> calls</strong> here and there.</p>
<p>And, equally inevitably, <strong>forget to remove some of them</strong> before production...</p>
</div></section><section class="slide" data-pos="4-5-16">
<span class="pos">4-5-16</span>
<div class="slidecontent"><p>To <strong>mitigate that</strong>, and to <strong>allow for more powerful logging features</strong>, it is common practice to instead use a <strong><code>Logger</code> service</strong>.</p>
<p>In its simplest form this just <strong>implements a <code>log</code> method</strong>:</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> {</span>
  <span class="hljs-built_in">log</span>(msg: any)   { console.<span class="hljs-built_in">log</span>(msg); }
}
</code></pre></div></section><section class="slide" data-pos="4-5-17">
<span class="pos">4-5-17</span>
<div class="slidecontent"><p>You would then inject this into your component or whatnot...</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">private</span> logger: Logger)</span><span class="hljs-comment">{}</span></span>
</code></pre><p>...and use the logging where needed:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">someComplexMethod</span><span class="hljs-params">()</span></span>{
  let result = <span class="hljs-comment">/* complex calculation */</span>
  this<span class="hljs-selector-class">.logger</span><span class="hljs-selector-class">.log</span>(result)
}
</code></pre></div></section><section class="slide" data-pos="4-5-18">
<span class="pos">4-5-18</span>
<div class="slidecontent"><p>Using a <code>Logger</code>service in this way means that you...</p>
<ul>
<li>can ship a <strong>&quot;mute&quot; <code>Logger</code></strong> in production instead of removing log statements</li>
<li>hook in <strong>other functionality</strong> such as <strong>writing logs to files</strong>, etc</li>
</ul>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>4-6.</span> Gamebook - page turning</h3>
      <p>Actual interaction</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="4-6-1">
<span class="pos">4-6-1</span>
<div class="slidecontent"><p>As before;</p>
<ol>
<li><strong>copy the folder of the previous version</strong>,</li>
<li><strong>paste it</strong> right next to that version, and</li>
<li>give it the name <strong><code>FF04-interaction</code></strong>.</li>
</ol>
</div></section><section class="slide list" data-pos="4-6-2">
<span class="pos">4-6-2</span>
<div class="slidecontent">
<p>The time has finally come to <strong>implement page turning</strong>! Here&#39;s the plan;</p>
<ul>
<li><span>a</span><strong>Add more scenes</strong> to the <code>adventure</code> data</li>
<li><span>b</span>Turn the <strong>option data into objects</strong> with links</li>
<li><span>c</span>Make <strong>option clicking</strong> update game state</li>
</ul>
</div></section><section class="slide num numA" data-pos="4-6-3">
<span class="pos">4-6-3</span>
<div class="slidecontent">
<p>To turn between pages we <strong>need more than one page</strong>, so <strong>add a few more</strong> to the adventure in the <code>data.ts</code> file!</p>
<pre><code>const adventure = {
  title: <span class="hljs-string">'A strange adventure'</span>,
  startState: {atScene: <span class="hljs-string">'house'</span>},
  scenes: {
    house: { ... },
    road: { ... },
    ambush: { ... },
    ...
  }
}
</code></pre></div></section><section class="slide num numB" data-pos="4-6-4">
<span class="pos">4-6-4</span>
<div class="slidecontent">
<p>We must also <strong>turn the option strings into objects</strong>, since they need to contain both</p>
<ul>
<li>the <strong>text</strong> to show</li>
<li>which <strong>scene to move to</strong></li>
</ul>
<p>So for each link, turn them into objects and <strong>add the key to the target scene</strong>!</p>
</div></section><section class="slide" data-pos="4-6-5">
<span class="pos">4-6-5</span>
<div class="slidecontent"><p>Again, if you&#39;re using <strong>TypeScript interfaces</strong> you must <strong>update</strong> those.</p>
<p>To <strong>avoid the <code>Scene</code> interface growing too complex</strong> you could <strong>add a new <code>Option</code> interface</strong>, and adapt <code>Scene</code> to use that for the options!</p>
</div></section><section class="slide num numC" data-pos="4-6-6">
<span class="pos">4-6-6</span>
<div class="slidecontent">
<p>Finally the time has come to <strong>make the options clickable</strong>!</p>
<ul>
<li>add a <strong><code>changeScene</code></strong> method to the component that <strong>expects an option object</strong> and <strong>updates <code>gameState</code></strong> accordingly</li>
<li>use that method as <strong>clickhandler for options</strong> with <code>(click)</code>. If you are typescripting, the clickhandler parameter type should be an <code>Option</code>!</li>
</ul>
</div></section><section class="slide" data-pos="4-6-7">
<span class="pos">4-6-7</span>
<div class="slidecontent"><p>Since we&#39;ve <strong>already wired <code>scene</code> to read from <code>gameState</code></strong> in the previous exercise, we&#39;re <strong>all done</strong>! <strong>Reward yourself</strong> by trying out your <strong>fully playable adventure</strong>.</p>
<p>Although a humble beginning, you now have <strong>all the needed parts to make a full game book</strong>!</p>
</div></section><section class="slide" data-pos="4-6-8">
<span class="pos">4-6-8</span>
<div class="slidecontent"><p>...<strong>ignoring</strong> the likely <strong>wishes for more functionality</strong> such as health points, inventory etc...</p>
</div></section><section class="slide" data-pos="4-6-9">
<span class="pos">4-6-9</span>
<div class="slidecontent"><p>Now that we have state that we manipulate, don&#39;t forget to <strong>use the debug tactics</strong> you&#39;ve learned about!</p>
</div></section><section class="slide challenge" data-pos="4-6-10">
<span class="pos">4-6-10</span>
<div class="slidecontent"><p><strong>Challenge</strong>: If you sailed through all of that, how about implementing an <strong>automatic reset</strong> for game-ending scenes with no options?</p>
<p>And parhaps also adding some <strong>dramatic background-color</strong> to the end-game scenes while we&#39;re at it?</p>
</div></section><section class="slide" data-pos="4-6-11">
<span class="pos">4-6-11</span>
<div class="slidecontent"><p>How would we go about all this? Well, we need to <strong>show a restart link</strong> when the scene has no options.</p>
<p>For our <strong>model</strong>, this means we can:</p>
<ul>
<li>add a <strong><code>gameOver</code> getter</strong> that returns <code>true</code> if there are no options in the scene</li>
<li>add a <strong><code>resetGame</code> method</strong> that sets <code>gameState</code> to <code>startState</code> from <code>adventure</code></li>
</ul>
</div></section><section class="slide" data-pos="4-6-12">
<span class="pos">4-6-12</span>
<div class="slidecontent"><p>And in our <strong>view</strong>:</p>
<ul>
<li>add a <strong>reset option <code>&lt;li&gt;</code></strong>  that<ul>
<li>only show if <code>gameOver</code> is true</li>
<li>calls <code>resetGame</code> when clicked</li>
</ul>
</li>
<li><strong>wrap the whole template</strong> in a <code>div</code></li>
<li>add a dynamic <strong><code>dead</code> class</strong> to the <code>div</code> using <code>[class.dead]=&quot;gameOver&quot;</code></li>
<li>add a <strong>style for the <code>.dead</code> class</strong></li>
</ul>
</div></section><section class="slide" data-pos="4-6-13">
<span class="pos">4-6-13</span>
<div class="slidecontent"><p>If you&#39;ve followed along, it is very likely that you now have a bug where <strong>nothing happens when we click <code>reset</code></strong>. What is going on?!</p>
</div></section><section class="slide" data-pos="4-6-14">
<span class="pos">4-6-14</span>
<div class="slidecontent"><p>Here&#39;s a <strong>clue</strong>: use the <code>&lt;pre&gt;</code> debug trick to show <strong><code>adventure.startState</code></strong> on the screen. That object should of course never change, but, does it, perhaps? Why, and how do we prevent it?</p>
</div></section><section class="slide" data-pos="4-6-15">
<span class="pos">4-6-15</span>
<div class="slidecontent"><p>Eventually we probably also want to have dead ends that doesn&#39;t mean that the player died but that he <strong>finished the adventure successfully</strong>. How would we <strong>distinguish between wins and losses</strong>?</p>
<p>We leave that as a challenge challenge for you to ponder after the course! :)</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 5 / 13</span>
    <h2>Composition</h2>
    <p>Combining components</p>
</p>
  </div>
  
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. Child components</li>
<li>2. Passing data</li>
<li>3. Receiving data</li>
<li>4. Passing elements</li>
<li>5. A composition case study</li>
<li>6. Gamebook - composition</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>5-1.</span> Child components</h3>
      <p>Spawning children</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="5-1-1">
<span class="pos">5-1-1</span>
<div class="slidecontent"><p>So, finally - how do we <strong>render one component from another</strong> in Angular? The answer has <strong>two parts</strong>:</p>
<ul>
<li>make sure the <strong>child component is visible to the parent</strong> from an <code>NgModule</code> perspective</li>
<li>include <strong>markup in the parent template</strong> that <strong>matches the child selector</strong></li>
</ul>
</div></section><section class="slide" data-pos="5-1-2">
<span class="pos">5-1-2</span>
<div class="slidecontent"><p><strong>Component selectors</strong> are mostly <strong>element types</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'myCustomComp'</span>,
  template: <span class="hljs-string">'...'</span>
})
</code></pre>
<p>To use this component, our <strong>markup must contain</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">myCustomComp</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">myCustomComp</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="5-1-3">
<span class="pos">5-1-3</span>
<div class="slidecontent"><p>But technically we can use <strong>any CSS selector</strong>, including <strong>targetting attributes</strong> like the built-in directives:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'[myCustomComp]'</span>,
  template: <span class="hljs-string">'...'</span>
})
</code></pre>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">myCustomComp</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="5-1-4">
<span class="pos">5-1-4</span>
<div class="slidecontent"><p>But, as stated, <strong>element types are the most common</strong>.</p>
<p>Which incidentally means that <strong>usage of Angular components</strong> is <strong>identical to <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web Components</a></strong>.</p>
<p>This <strong>opens some interesting possibilities</strong>, but we <strong>won&#39;t explore that further in this course</strong>.</p>
</div></section><section class="slide" data-pos="5-1-5">
<span class="pos">5-1-5</span>
<div class="slidecontent"><p>It is <strong>also identical</strong> to the relation between the <strong>root component and the main index page</strong>! Our root components have <strong>all used this selector</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app'</span>,
  template: <span class="hljs-string">'...'</span>
})
</code></pre>
<p>...and in the main <code>index.html</code> files you find this:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">app</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">app</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="5-1-6">
<span class="pos">5-1-6</span>
<div class="slidecontent"><p>Again, composition works in the <strong>exact same way</strong>.</p>
<p><strong>See it in action</strong> in the <a href="resources/supportsite/demos/composition" target="_blank">Composition</a> demo, or the <a href="resources/supportsite/demos/composition_scoped" target="_blank">Composition Scoped</a> which uses components from different <code>NgModules</code>.</p>
</div></section><section class="slide" data-pos="5-1-7">
<span class="pos">5-1-7</span>
<div class="slidecontent"><p>Btw, did you notice the <strong>style definition in the root</strong> in the demo?</p>
<pre><code class="lang-css">:host /deep/ span {
  border: 1px solid black; padding: 3px;
}
</code></pre>
<p>As you might guess, the <strong><code>/deep/</code> selector</strong> means we <strong>dig into the encapsulation of our children</strong> to be able to style them too.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>5-2.</span> Passing data</h3>
      <p>pouring down</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="5-2-1">
<span class="pos">5-2-1</span>
<div class="slidecontent"><p>Time to start exploring <strong>parent-child communication</strong>, and specifically, how <strong>parents give input to their children</strong>!</p>
<p><img src="resources/diagrams/parchildcom-input.svg" alt=""></p>
</div></section><section class="slide" data-pos="5-2-2">
<span class="pos">5-2-2</span>
<div class="slidecontent"><p>The syntax is actually rather ingenious - with an <strong><code>@Input</code> decorator</strong> we can <strong>mark a property as an input</strong>:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> </span>{
  <span class="hljs-meta">@Input()</span> someProp
  aPrivateProp
}
</code></pre></div></section><section class="slide" data-pos="5-2-3">
<span class="pos">5-2-3</span>
<div class="slidecontent"><p>After having done so, the <code>someProp</code> property can be <strong>bound to in the parent template</strong>:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">child</span> [<span class="hljs-attr">someProp</span>]=<span class="hljs-string">"myVariable"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
</code></pre></div></section><section class="slide" data-pos="5-2-4">
<span class="pos">5-2-4</span>
<div class="slidecontent"><p>We can also <strong>alias the property name</strong> if we for some reason want to have the input named differently:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> Child {
  <span class="hljs-meta">@Input</span>(<span class="hljs-string">'aliasedProp'</span>) someProp
}
</code></pre>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> [<span class="hljs-attr">aliasedProp</span>]=<span class="hljs-string">"myVariable"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="5-2-5">
<span class="pos">5-2-5</span>
<div class="slidecontent"><p>And as the <strong>bound property is a normal class property</strong>, we can also <strong>use a setter</strong>:</p>
<pre><code><span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">Child</span> {
  <span class="hljs-attribute">aPrivateProp</span>: string
  @<span class="hljs-built_in">Input</span>() set <span class="hljs-built_in">exposedProp</span>(fromMum){
    this.aPrivateProp = fromMum
  }
}
</code></pre><p>It looks exactly the <strong>same as before</strong> from the outside:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> [<span class="hljs-attr">exposedProp</span>]=<span class="hljs-string">"cleanYourRoom"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="5-2-6">
<span class="pos">5-2-6</span>
<div class="slidecontent"><p>You can see <strong>all three variants</strong> in action in the <a href="resources/supportsite/demos/childinput" target="_blank">Child input</a> demo.</p>
</div></section><section class="slide" data-pos="5-2-7">
<span class="pos">5-2-7</span>
<div class="slidecontent"><p>If we <strong>tried to bind to <code>aPrivateProp</code></strong> which hasn&#39;t been exposed via <code>@Input</code>, or a non-existent property, <strong>Angular would throw an error</strong>:</p>
<p><img src="resources/images/inputerror.png" alt=""></p>
<p>Notice how it <strong>points out the offending input</strong> with an <code>[ERROR-&gt;]</code> marker.</p>
</div></section><section class="slide" data-pos="5-2-8">
<span class="pos">5-2-8</span>
<div class="slidecontent"><p>Interestingly, this is the <strong>exact same error</strong> we&#39;d see for <code>ngModel</code> if we <strong>forgot the <code>FormsModule</code></strong>!</p>
<p><img src="resources/images/inputnoformerror.png" alt=""></p>
</div></section><section class="slide" data-pos="5-2-9">
<span class="pos">5-2-9</span>
<div class="slidecontent"><p>That makes sense since <strong>native <code>input</code> elements have no <code>ngModel</code> prop</strong>. </p>
<p>But it also <strong>reveals some interesting facts</strong>:</p>
<ul>
<li><strong>directives can have inputs too</strong></li>
<li>we have <strong>already been using inputs</strong> without knowing it!</li>
</ul>
</div></section><section class="slide" data-pos="5-2-10">
<span class="pos">5-2-10</span>
<div class="slidecontent"><p>For example, we <strong>use <code>ngIf</code> by feeding it an expression</strong>:</p>
<pre><code>&lt;<span class="hljs-keyword">div</span> *ngIf=<span class="hljs-string">"someFlag"</span>&gt;
  shown only <span class="hljs-keyword">if</span> `someFlag` <span class="hljs-keyword">is</span> truthy!
&lt;/<span class="hljs-keyword">div</span>&gt;
</code></pre><p>Obviously <strong><code>ngIf</code> uses <code>[ngIf]</code> as selector</strong>, but if what we saw earlier is true, it must <strong>also define <code>ngIf</code> as an input</strong>!</p>
</div></section><section class="slide" data-pos="5-2-11">
<span class="pos">5-2-11</span>
<div class="slidecontent"><p>And <strong>sure enough</strong>, in the <a href="https://github.com/angular/angular/blob/2.0.2/modules/%40angular/common/src/directives/ng_if.ts#L9-L51">source code</a> we see this:</p>
<pre><code><span class="hljs-meta">@Directive</span>({selector: <span class="hljs-string">'[ngIf]'</span>})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> NgIf {
  <span class="hljs-keyword">private</span> _hasView: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">...</span>) {}
  <span class="hljs-meta">@Input</span>()
  <span class="hljs-keyword">set</span> ngIf(condition: <span class="hljs-built_in">any</span>) {
    ...
  }
}
</code></pre></div></section><section class="slide" data-pos="5-2-12">
<span class="pos">5-2-12</span>
<div class="slidecontent"><p>So the <strong>old AngularJS cliché still holds true</strong>;</p>
<blockquote>
<p>Angular is built with Angular</p>
</blockquote>
<p>Like in AngularJS, Angular defines a <strong>central infrastructure</strong>, and then uses that both to <strong>create built-in helpers</strong> and <strong>allow developer-made building blocks</strong>.</p>
</div></section><section class="slide" data-pos="5-2-13">
<span class="pos">5-2-13</span>
<div class="slidecontent"><p>Btw, wanna now how to <strong>easily find the source code</strong> for some part of Angular? Easy:</p>
<ul>
<li>Go to the <strong><a href="https://angular.io/docs/ts/latest/api/">official API docs</a></strong></li>
<li>Type in the <strong>name of the part in the search field</strong></li>
<li>Click to <strong>get to the dedicated page</strong></li>
<li>Find the <strong>source link in the bottom-right corner</strong></li>
</ul>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>5-3.</span> Receiving data</h3>
      <p>here you go</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="5-3-1">
<span class="pos">5-3-1</span>
<div class="slidecontent"><p>Time to explore the other side of parenthood - <strong>children output</strong>!</p>
<p><img src="resources/diagrams/parchildcom-output.svg" alt=""></p>
</div></section><section class="slide question" data-pos="5-3-2">
<span class="pos">5-3-2</span>
<div class="slidecontent">
<p>Let me guess -  we <strong>mark child properties with an <code>@Output</code> decorator</strong>?</p>
</div></section><section class="slide answer" data-pos="5-3-3">
<span class="pos">5-3-3</span>
<div class="slidecontent">
<p>You&#39;ve got it! :)</p>
<p>But still, there&#39;s <strong>far more to the story</strong>...</p>
</div></section><section class="slide" data-pos="5-3-4">
<span class="pos">5-3-4</span>
<div class="slidecontent"><p>Because if we were just to <strong>expose a regular property</strong>...</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> </span>{
  <span class="hljs-meta">@Output()</span> someProp = <span class="hljs-string">'foo'</span>
}
</code></pre><p>...how would we <strong>connect to that in the parent</strong>?</p>
</div></section><section class="slide" data-pos="5-3-5">
<span class="pos">5-3-5</span>
<div class="slidecontent"><p>A naïve approach could be a <strong>simple two-way data binding</strong> through simply <strong>binding to a prop in the parent</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> (<span class="hljs-attr">someProp</span>)=<span class="hljs-string">'parentProp'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
</code></pre>
<p>But this would <strong>fall apart quickly</strong>. What if I <strong>don&#39;t want to store the value</strong> but simply <strong>act when something happens</strong>?</p>
<p>And <strong>how would I know when the value changes</strong>?</p>
</div></section><section class="slide" data-pos="5-3-6">
<span class="pos">5-3-6</span>
<div class="slidecontent"><p>We&#39;ve actually <strong>already seen output from a parent perspective</strong> when we learned about <strong>event handling</strong>!</p>
<p>There we were taught that for outputs we <strong>don&#39;t use template expressions</strong> but <strong>template statements</strong>!</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> (<span class="hljs-attr">someProp</span>)=<span class="hljs-string">'catchOutput($event);'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
</code></pre>
<p>We also saw that <strong>in this statement we can access <code>$event</code></strong> which <strong>contains the message from the child</strong>.</p>
</div></section><section class="slide" data-pos="5-3-7">
<span class="pos">5-3-7</span>
<div class="slidecontent"><p>This makes sense - now I have <strong>code that triggers upon receiving the message</strong>, and I can <strong>do what I want</strong>.</p>
<p>And as you&#39;ve already figured out, there&#39;s <strong>no difference to child component output</strong> and <strong>outputs from input elements</strong>.</p>
</div></section><section class="slide" data-pos="5-3-8">
<span class="pos">5-3-8</span>
<div class="slidecontent"><p>Because the <strong>inputs are clad with the <code>ngModel</code> directive</strong>, who apparently are using <code>@Output</code>s under the hood.</p>
<p>Again,</p>
<blockquote>
<p>Angular is built with Angular</p>
</blockquote>
</div></section><section class="slide question" data-pos="5-3-9">
<span class="pos">5-3-9</span>
<div class="slidecontent">
<p>So, can you <strong>guess what <code>@Output</code>s look like</strong> in children?</p>
<p>You&#39;ve already seen the answer, <strong>way back in the beginning of the course</strong>...</p>
</div></section><section class="slide answer" data-pos="5-3-10">
<span class="pos">5-3-10</span>
<div class="slidecontent">
<p>Now we finally get to see the main reason <strong>why Angular needs RxJS</strong> - you see, <strong>outputs are implemented through streams</strong>!</p>
</div></section><section class="slide" data-pos="5-3-11">
<span class="pos">5-3-11</span>
<div class="slidecontent"><p>Thinking about it this makes a whole lot of sense - <strong>streams are an asynchronous chain of events</strong>, which is <strong>exactly what child outputs are</strong> too!</p>
</div></section><section class="slide" data-pos="5-3-12">
<span class="pos">5-3-12</span>
<div class="slidecontent"><p>In <strong>Angular</strong> this means that <strong>output properties are <code>EventEmitter</code>s</strong>, which are <strong>streams that emit events of a given type</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Output</span>() whine = <span class="hljs-keyword">new</span> EventEmitter&lt;<span class="hljs-built_in">string</span>&gt;()
</code></pre>
<p>Using this the <strong>child will emit events</strong> to the parent:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">this</span>.whine.emit(<span class="hljs-keyword">this</span>.msg);
</code></pre>
<p><strong>See this in action</strong> in the <a href="resources/supportsite/demos/childoutput" target="_blank">Child output</a> demo.</p>
</div></section><section class="slide" data-pos="5-3-13">
<span class="pos">5-3-13</span>
<div class="slidecontent"><p>And, speaking on <code>ngModel</code> - if we were to peek at that source, <strong>what could we expect</strong>?</p>
<ul>
<li>it should have an <strong><code>@Input</code> named <code>ngModel</code></strong></li>
<li>it should have an <strong><code>@Output</code> named <code>ngModelChange</code></strong> (because of what the banana box syntax actually means)</li>
<li>it is likely <strong>very complex</strong> :P</li>
</ul>
</div></section><section class="slide" data-pos="5-3-14">
<span class="pos">5-3-14</span>
<div class="slidecontent"><p>And indeed, if we <a href="https://github.com/angular/angular/blob/2.0.2/modules/%40angular/forms/src/directives/ng_model.ts#L108">go look</a>, that is <strong>exactly what we find</strong>!</p>
</div></section><section class="slide" data-pos="5-3-15">
<span class="pos">5-3-15</span>
<div class="slidecontent"><p>Speaking of <strong>streams</strong> - we should also add that you <strong>can use them more heavily in your own code</strong> too.</p>
<p>For an example, check out the <a href="resources/supportsite/demos/submitname_streams" target="_blank">Submitname with Streams</a> demo!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>5-4.</span> Passing elements</h3>
      <p>Here you go, my child</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="5-4-1">
<span class="pos">5-4-1</span>
<div class="slidecontent"><p>When we looked at <strong>composition</strong>, we noted <strong>how parents and children communicate</strong>.</p>
<p>But there is a scenario we haven&#39;t covered yet - what happens when we <strong>pass elements to a child</strong>?</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>What will happen to me?<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="5-4-2">
<span class="pos">5-4-2</span>
<div class="slidecontent"><p>Unless the child actively captures those elements, <strong>they will just disappear</strong>.</p>
<p>However the child <strong>can capture the elements</strong> by including this in its template:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span>
</code></pre>
<p>See this in action in the <a href="resources/supportsite/demos/passingelements" target="_blank">Passing elements</a> demo.</p>
</div></section><section class="slide" data-pos="5-4-3">
<span class="pos">5-4-3</span>
<div class="slidecontent"><p>The child can also <strong>split the elements up</strong> and show them in <strong>different places</strong> using the <code>select</code> attribute on <code>ng-content</code>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span> <span class="hljs-attr">select</span>=<span class="hljs-string">'header'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span> <span class="hljs-attr">select</span>=<span class="hljs-string">'footer'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span>
</code></pre>
<p>See this in action in the <a href="resources/supportsite/demos/passingelements_split" target="_blank">Passing split elements</a> demo.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>5-5.</span> A composition case study</h3>
      <p>Building a sharable component</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="5-5-1">
<span class="pos">5-5-1</span>
<div class="slidecontent"><p>In an Angular application <strong>components are your primary building block</strong>. It therefore stands to reason that you should <strong>consider each component API carefully</strong>:</p>
<ul>
<li>what <strong><code>@Input</code>s</strong> does it need?</li>
<li>what <strong><code>@Output</code>s</strong> does it provide?</li>
</ul>
</div></section><section class="slide" data-pos="5-5-2">
<span class="pos">5-5-2</span>
<div class="slidecontent"><p>To wrap our brains around this, let&#39;s do a <strong>small case study</strong> where we <strong>implement a stand-alone UI component</strong> meant to be <strong>integrated into other apps</strong>.</p>
<p>We&#39;ll be making a <strong>confirmation button</strong>!</p>
</div></section><section class="slide" data-pos="5-5-3">
<span class="pos">5-5-3</span>
<div class="slidecontent"><p>It is meant to be <strong>used as a confirmation button in a form</strong>:</p>
<p><img src="resources/images/confirm-standby.png" alt=""></p>
</div></section><section class="slide" data-pos="5-5-4">
<span class="pos">5-5-4</span>
<div class="slidecontent"><p>But of course it is not just a regular button: when the <strong>user clicks the button</strong> it should <strong>allow confirmation and cancel</strong>:</p>
<p><img src="resources/images/confirm-really.png" alt=""></p>
<p>Only if the <strong>user chooses <code>confirm</code></strong> should the <strong>parent be notified</strong>, otherwise it just <strong>reverts to the previous standby mode</strong>.</p>
</div></section><section class="slide" data-pos="5-5-5">
<span class="pos">5-5-5</span>
<div class="slidecontent"><p>Additionally we should <strong>allow the parent to disable the button</strong> if whatever data we&#39;re confirming is invalid, for instance if the field is empty:</p>
<p><img src="resources/images/confirm-disabled.png" alt=""></p>
</div></section><section class="slide" data-pos="5-5-6">
<span class="pos">5-5-6</span>
<div class="slidecontent"><p>So let&#39;s <strong>consider the API</strong> for this! We&#39;ll need...</p>
<ul>
<li>an <strong><code>@Output</code></strong> to emit <strong>confirmations</strong> to</li>
<li>an <strong><code>@Input</code></strong> for <strong>whether or not we&#39;re disabled</strong></li>
</ul>
</div></section><section class="slide" data-pos="5-5-7">
<span class="pos">5-5-7</span>
<div class="slidecontent"><p>Internally we&#39;ll also need to <strong>track our current <code>mode</code></strong>, which can be</p>
<ul>
<li><strong>standby</strong> - showing submit button</li>
<li><strong>disabled</strong> - button should be greyed out</li>
<li><strong>confirm</strong> - showing confirm and cancel</li>
</ul>
</div></section><section class="slide" data-pos="5-5-8">
<span class="pos">5-5-8</span>
<div class="slidecontent"><p>So the <strong>map for the component</strong> would be something like this:</p>
<p><img src="resources/diagrams/confirmcomp.svg" alt=""></p>
</div></section><section class="slide" data-pos="5-5-9">
<span class="pos">5-5-9</span>
<div class="slidecontent"><p>With our <strong>three modes in mind</strong>, we could <strong>implement the template</strong> like so:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"mode !== 'confirm'"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"maybe()"</span> [<span class="hljs-attr">disabled</span>]=<span class="hljs-string">"mode === 'disabled'"</span>&gt;</span>
    Submit
  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"mode === 'confirm'"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"changedmymind()"</span>&gt;</span>Cancel<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"yesimsure()"</span>&gt;</span>Confirm<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</code></pre></div></section><section class="slide" data-pos="5-5-10">
<span class="pos">5-5-10</span>
<div class="slidecontent"><p>And here&#39;s the <strong>model to match</strong> that:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfirmComponent</span> </span>{
  mode: <span class="hljs-string">'standby'</span> | <span class="hljs-string">'disabled'</span> | <span class="hljs-string">'confirm'</span> = <span class="hljs-string">'standby'</span>
  <span class="hljs-meta">@Output()</span> confirm = new EventEmitter&lt;void&gt;()
  <span class="hljs-meta">@Input()</span> <span class="hljs-keyword">set</span> disabled(bool: boolean){
    <span class="hljs-keyword">this</span>.mode = bool ? <span class="hljs-string">'disabled'</span> : <span class="hljs-string">'standby'</span>
  }
  maybe() { <span class="hljs-keyword">this</span>.mode = <span class="hljs-string">'confirm'</span> }
  changedmymind() { <span class="hljs-keyword">this</span>.mode = <span class="hljs-string">'standby'</span> }
  yesimsure() { <span class="hljs-keyword">this</span>.confirm.emit(); <span class="hljs-keyword">this</span>.mode = <span class="hljs-string">'standby'</span> }
}
</code></pre></div></section><section class="slide" data-pos="5-5-11">
<span class="pos">5-5-11</span>
<div class="slidecontent"><p>Note how we&#39;re <strong>not explicitly tracking disabled</strong>, instead <strong>that input is a setter</strong> which manipulates <code>mode</code> accordingly:</p>
<pre><code>@Input() <span class="hljs-function"><span class="hljs-keyword">set</span> <span class="hljs-title">disabled</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span>: boolean</span>)</span>{
  <span class="hljs-keyword">this</span>.mode = <span class="hljs-keyword">bool</span> ? <span class="hljs-string">'disabled'</span> : <span class="hljs-string">'standby'</span>
}
</code></pre><p>This pattern is <strong>somewhat common</strong> - an input <strong>doesn&#39;t have to be something we store</strong>, but can be <strong>used as a signal from the outside world</strong>.</p>
</div></section><section class="slide" data-pos="5-5-12">
<span class="pos">5-5-12</span>
<div class="slidecontent"><p>You can <strong>try the component out</strong> in the <a href="resources/supportsite/demos/confirm" target="_blank">Confirm</a> demo.</p>
<p>And again, the point of this little case study was to <strong>highlight the component perspective</strong>. Think of your app in terms of components, and think carefully about <strong>how they interact</strong>.</p>
</div></section><section class="slide" data-pos="5-5-13">
<span class="pos">5-5-13</span>
<div class="slidecontent"><p>There is an <strong>alternative solution</strong> using a <strong>lifecycle hook</strong> instead of a getter here: <a href="resources/supportsite/demos/confirm_hook" target="_blank">Confirm-Hook</a></p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>5-6.</span> Gamebook - composition</h3>
      <p>Matryoshka time</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="5-6-1">
<span class="pos">5-6-1</span>
<div class="slidecontent"><p>As before;</p>
<ol>
<li><strong>copy the folder of the previous version</strong>,</li>
<li><strong>paste it</strong> right next to that version, and</li>
<li>give it the name <strong><code>FF05-components</code></strong>.</li>
</ol>
</div></section><section class="slide" data-pos="5-6-2">
<span class="pos">5-6-2</span>
<div class="slidecontent"><p>Let&#39;s <strong>clean up our code</strong> a bit by using the <strong>component composition techniques</strong> we just learned about!</p>
</div></section><section class="slide" data-pos="5-6-3">
<span class="pos">5-6-3</span>
<div class="slidecontent"><p>Specifically, we&#39;re going to <strong>abstract out a <code>SceneComponent</code></strong> from the <code>AppComponent</code>:</p>
<p><img src="resources/diagrams/scenecomp.svg" alt=""></p>
<p><code>SceneComponent</code> is <strong>given a <code>scene</code> object</strong> to render as input, and will <strong>output <code>option</code> objects</strong> when they are clicked.</p>
</div></section><section class="slide list" data-pos="5-6-4">
<span class="pos">5-6-4</span>
<div class="slidecontent">
<p>In other words, we need to...</p>
<ul>
<li><span>a</span>Create a <strong>new <code>scene.ts</code> file</strong> for <code>SceneComponent</code></li>
<li><span>b</span><strong>Update <code>AppComponent</code></strong> to use the new component</li>
<li><span>c</span><strong>Update the <code>NgModule</code> in main.ts</strong> to expose the new component</li>
</ul>
</div></section><section class="slide num numA" data-pos="5-6-5">
<span class="pos">5-6-5</span>
<div class="slidecontent">
<p>Since <strong><code>scene.ts</code> will contain much of what is now in <code>app.ts</code></strong>, let&#39;s <strong>make a copy of <code>app.ts</code></strong> and call it <code>scene.ts</code>!</p>
</div></section><section class="slide" data-pos="5-6-6">
<span class="pos">5-6-6</span>
<div class="slidecontent"><p>In <strong><code>scene.ts</code></strong> we then need to...</p>
<ul>
<li><strong>Change the selector to something else</strong></li>
<li><strong>Change the component name</strong> to <code>SceneComponent</code></li>
<li><strong>Remove game status</strong>, that will reside in <code>AppComponent</code>.</li>
<li><strong>Remove the <code>adventure</code> import</strong>, we don&#39;t need that</li>
<li><strong>Change <code>scene</code> to be an <code>@Input</code></strong></li>
<li><strong>Make the clickhandler an <code>@Output</code></strong></li>
<li>Change the handler to <strong>emit clicked option objects</strong></li>
<li><strong>Remove the adventure title</strong> from the template</li>
</ul>
</div></section><section class="slide num numB" data-pos="5-6-7">
<span class="pos">5-6-7</span>
<div class="slidecontent">
<p>Back in <strong><code>app.ts</code></strong> we must..</p>
<ul>
<li>Change the template to <strong>use the scene element</strong></li>
<li>But still show the <strong>adventure title</strong> above the scene</li>
<li>Feed the scene element <strong>the current <code>scene</code></strong></li>
<li><strong>Connect the scene element output to the click handler</strong></li>
</ul>
</div></section><section class="slide" data-pos="5-6-8">
<span class="pos">5-6-8</span>
<div class="slidecontent"><p>If you took on the <strong>reset option challenge</strong> in the earlier exercise, we <strong>need <code>gameOver</code> state in both</strong> <code>AppComponent</code> and <code>SceneComponent</code>, and probably a <strong>new <code>Output</code> from <code>scene</code></strong> for the reset clicking.</p>
<p>Alternatively, have the reset button in the <code>AppComponent</code> template instead, separate from the scene options.</p>
</div></section><section class="slide num numC" data-pos="5-6-9">
<span class="pos">5-6-9</span>
<div class="slidecontent">
<p>Finally, for <code>SceneComponent</code> to be available in the <code>AppComponent</code> template, we must <strong>add it to the <code>Declarations</code> array</strong> of our module in <code>module.ts</code>.</p>
</div></section><section class="slide" data-pos="5-6-10">
<span class="pos">5-6-10</span>
<div class="slidecontent"><p>Now, after all that work, <strong>bundle</strong> and <strong>fire up the new version</strong>.</p>
<p>And if everything went according to plan, <strong>things will work exactly as before</strong>!</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 6 / 13</span>
    <h2>Dependency injection</h2>
    <p>Providing the ingredients</p>
</p>
  </div>
  
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. Dependency VS input</li>
<li>2. Injection explained</li>
<li>3. Dependencies in AngularJS</li>
<li>4. Dependencies in Angular</li>
<li>5. Providing dependencies</li>
<li>6. Non-class dependencies</li>
<li>7. Services</li>
<li>8. Gamebook - dependencies</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>6-1.</span> Dependency VS input</h3>
      <p>What do we actually mean?</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="6-1-1">
<span class="pos">6-1-1</span>
<div class="slidecontent"><p>Take a look at this <strong>hypothetical function</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> complexLib <span class="hljs-keyword">from</span> <span class="hljs-string">'complexLib'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunction</span>(<span class="hljs-params">arg1,arg2</span>)</span>{
  <span class="hljs-comment">/*
    Somehow calculate `result` using `arg1`,
    `arg2` and methods on `complexLib`
  */</span>
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
</div></section><section class="slide" data-pos="6-1-2">
<span class="pos">6-1-2</span>
<div class="slidecontent"><p>If we were to <strong>graph <code>someFunction</code></strong>, it might look like this:</p>
<p><img src="resources/diagrams/somefunction.svg" alt=""></p>
</div></section><section class="slide" data-pos="6-1-3">
<span class="pos">6-1-3</span>
<div class="slidecontent"><p>But although that <strong>maps the full signature</strong>, it doesn&#39;t capture the <strong>dependency on <code>complexLib</code></strong>. Here&#39;s the <strong>complete truth</strong>:</p>
<p><img src="resources/diagrams/somefunction-full.svg" alt=""></p>
</div></section><section class="slide" data-pos="6-1-4">
<span class="pos">6-1-4</span>
<div class="slidecontent"><p>As <code>someFunction</code> is currently implemented there is a <strong>big problem with <code>testability</code></strong>, since we <strong>cannot control the dependencies</strong>.</p>
</div></section><section class="slide" data-pos="6-1-5">
<span class="pos">6-1-5</span>
<div class="slidecontent"><p>Ideally we would just want to test that <code>someFunction</code> <strong>calls the correct methods on <code>complexLib</code></strong>, given the values of the inputs.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> complexLib = myMock <span class="hljs-comment">// someFunction won't use this! :(</span>

<span class="hljs-keyword">let</span> result = someFunction(testval1,testval2)

assert.equal(result,expectedResult)
assert.equal(myMock.usedMethod.firstCall,expectedArgs)
</code></pre>
<p>But, how do we <strong>make <code>someFunction</code> use <code>myMock</code></strong>?</p>
</div></section><section class="slide list" data-pos="6-1-6">
<span class="pos">6-1-6</span>
<div class="slidecontent">
<p>Let&#39;s use this simple example to explore <strong>4 options to handle the dependency</strong>:</p>
<ul>
<li><span>a</span>in the signature</li>
<li><span>b</span>in a prop</li>
<li><span>c</span>in the context</li>
<li><span>d</span>with a constructor</li>
</ul>
</div></section><section class="slide num numA" data-pos="6-1-7">
<span class="pos">6-1-7</span>
<div class="slidecontent">
<p>We could simply <strong>change the signature</strong> from this...</p>
<pre><code><span class="hljs-function"><span class="hljs-title">someFunction</span><span class="hljs-params">(arg1, arg2)</span></span>
</code></pre><p>...to this: </p>
<pre><code><span class="hljs-function"><span class="hljs-title">someFunction</span><span class="hljs-params">(arg1, arg2, complexLib)</span></span>
</code></pre></div></section><section class="slide" data-pos="6-1-8">
<span class="pos">6-1-8</span>
<div class="slidecontent"><p>Now that the <strong><code>complexLib</code> implementation is passed in</strong>, we can easily <strong>use a mock</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> result = someFunction(testval1, testval2, myMock)

assert.equal(result,expectedResult)
assert.equal(myMock.usedMethod.firstCall,expectedArgs)
</code></pre>
</div></section><section class="slide" data-pos="6-1-9">
<span class="pos">6-1-9</span>
<div class="slidecontent"><p>This works, and is probably the <strong>easiest solution</strong>. Now <code>someFunction</code> is <strong>easily testable</strong> and <strong>not tied to a specific <code>complexLib</code> implementation</strong>. Loose coupling!</p>
</div></section><section class="slide" data-pos="6-1-10">
<span class="pos">6-1-10</span>
<div class="slidecontent"><p>The downside is that we have <strong>mixed inputs with dependencies</strong> in the signature, which isn&#39;t super intutitive.</p>
<p>But <code>someFunction</code> is a <strong>function</strong>, and they only have <strong>one natural point of entry</strong> - the parameters!</p>
</div></section><section class="slide num numB" data-pos="6-1-11">
<span class="pos">6-1-11</span>
<div class="slidecontent">
<p>We could <strong>attach them as props on the function</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> complexLib <span class="hljs-keyword">from</span> <span class="hljs-string">'complexLib'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunction</span>(<span class="hljs-params">arg1,arg2</span>)</span>{
  <span class="hljs-comment">/*
    Somehow calculate `result` using `arg1`, `arg2`
    and methods on `someFunction.complexLib`
  */</span>
  <span class="hljs-keyword">return</span> result;
}
someFunction.complexLib = complexLib
</code></pre>
</div></section><section class="slide" data-pos="6-1-12">
<span class="pos">6-1-12</span>
<div class="slidecontent"><p>Now we would <strong>test it like thus</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> oldImplementation = someFunction.complexLib
someFunction.comlexLib = myMock

<span class="hljs-keyword">let</span> result = someFunction(testval1, testval2)

assert.equal(result,expectedResult)
assert.equal(myMock.usedMethod.firstCall,expectedArgs)

someFunction.complexLib = oldImplementation
</code></pre>
<p>It works, but it is <strong>not very convenient</strong>.</p>
</div></section><section class="slide num numC" data-pos="6-1-13">
<span class="pos">6-1-13</span>
<div class="slidecontent">
<p>Or we could <strong>use the context</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunction</span>(<span class="hljs-params">arg1,arg2</span>)</span>{
  <span class="hljs-comment">/*
    Somehow calculate `result` using `arg1`, `arg2`
    and methods on `this.complexLib`
  */</span>
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
</div></section><section class="slide" data-pos="6-1-14">
<span class="pos">6-1-14</span>
<div class="slidecontent"><p>Now you would have to <strong>call <code>someFunction</code> like thus</strong>:</p>
<pre><code><span class="hljs-keyword">import</span> complexLib <span class="hljs-keyword">from</span> <span class="hljs-string">'complexLib'</span>
<span class="hljs-keyword">let</span> result = someFunction.call({complexLib}, arg1, arg2)
</code></pre><p>Not much better!</p>
</div></section><section class="slide" data-pos="6-1-15">
<span class="pos">6-1-15</span>
<div class="slidecontent"><p>We can improve the situation by <strong>defaulting to a private reference</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> complexLib <span class="hljs-keyword">from</span> <span class="hljs-string">'complexLib'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunction</span>(<span class="hljs-params">arg1,arg2</span>)</span>{
  <span class="hljs-comment">/*
    Somehow calculate `result` using `arg1`, `arg2`
    and methods on `this.complexLib || complexLib`
  */</span>
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
</div></section><section class="slide" data-pos="6-1-16">
<span class="pos">6-1-16</span>
<div class="slidecontent"><p>Now a <strong>normal call is normal again</strong>:</p>
<pre><code>let result = someFunction(<span class="hljs-name">arg1</span>, arg2)
</code></pre><p>...while <strong>testing is still possible</strong>:</p>
<pre><code><span class="hljs-keyword">let</span> result = someFunction.<span class="hljs-keyword">call</span>({complexLi<span class="hljs-variable">b:myMock</span>}, arg1, arg2)
</code></pre></div></section><section class="slide num numD" data-pos="6-1-17">
<span class="pos">6-1-17</span>
<div class="slidecontent">
<p>A final example - we could <strong>provide someFunction from a constructor</strong> to which we pass in the dependency:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSomeFunc</span><span class="hljs-params">(dep)</span></span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(arg1,arg)</span></span>{
    <span class="hljs-comment">// calc result using `dep`</span>
    <span class="hljs-keyword">return</span> result;
  }
}
</code></pre></div></section><section class="slide" data-pos="6-1-18">
<span class="pos">6-1-18</span>
<div class="slidecontent"><p><strong>Normal usage</strong> will now look like this:</p>
<pre><code><span class="hljs-attribute">let someFunc</span> = getSomeFunc(complexLib);
<span class="hljs-attribute">let result</span> = someFunc(arg1, arg2);
</code></pre><p>...while we <strong>test like so</strong>:</p>
<pre><code><span class="hljs-attribute">let someFunc</span> = getSomeFunc(myMock);
<span class="hljs-attribute">let result</span> = someFunc(arg1, arg2);
</code></pre></div></section><section class="slide" data-pos="6-1-19">
<span class="pos">6-1-19</span>
<div class="slidecontent"><p>All of these setups sort of work, but all have downsides. The important thing is to...</p>
<ul>
<li><strong>understand the difference</strong> between input and dependency</li>
<li><strong>not have a tight coupling</strong> to dependencies in your implementation</li>
</ul>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>6-2.</span> Injection explained</h3>
      <p>needles aren&#39;t that scary</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="6-2-1">
<span class="pos">6-2-1</span>
<div class="slidecontent"><p>Now we will take a look at <strong>dependency injection</strong> as a concept!</p>
</div></section><section class="slide list" data-pos="6-2-2">
<span class="pos">6-2-2</span>
<div class="slidecontent">
<p>In essence, the <strong>idea</strong> is that if we can</p>
<ul>
<li><span>a</span><strong>separate dependencies from inputs</strong>, and</li>
<li><span>b</span><strong>explain what dependencies we need</strong>, then</li>
<li><span>c</span>the <strong>dependencies are injected automatically</strong>!</li>
</ul>
</div></section><section class="slide num numA" data-pos="6-2-3">
<span class="pos">6-2-3</span>
<div class="slidecontent">
<p>Borrowing from an earlier example, imagine a system where <strong>all functions have the following syntax</strong>:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">everyFunction</span>(<span class="hljs-params">...args, dependencies</span>)</span>
</code></pre></div></section><section class="slide" data-pos="6-2-4">
<span class="pos">6-2-4</span>
<div class="slidecontent"><p>In other words, the <strong>last argument is an object with dependencies</strong>.</p>
<p>Thus we have <strong>achieved separation</strong> between dependencies and inputs.</p>
</div></section><section class="slide num numB" data-pos="6-2-5">
<span class="pos">6-2-5</span>
<div class="slidecontent">
<p>Now also imagine that every function somehow <strong>specifies what dependencies it needs</strong>, perhaps with a <strong>definition object on the function</strong>:</p>
<pre><code class="lang-javascript">someFunction.neededDeps = {
  <span class="hljs-attr">lib</span>: <span class="hljs-string">'dependencyID'</span>,
  <span class="hljs-attr">anotherLib</span>: <span class="hljs-string">'anotherDependencyID'</span>
}
</code></pre>
</div></section><section class="slide" data-pos="6-2-6">
<span class="pos">6-2-6</span>
<div class="slidecontent"><p>Which would mean that <strong><code>someFunction</code> expects to be called thusly</strong>:</p>
<pre><code class="lang-javascript">someFunction(arg1,arg2,arg3,{
  <span class="hljs-attr">lib</span>: instanceOfLib,
  <span class="hljs-attr">anotherLib</span>: instanceOfAnotherLib
})
</code></pre>
</div></section><section class="slide num numC" data-pos="6-2-7">
<span class="pos">6-2-7</span>
<div class="slidecontent">
<p>Finally, imagine that we <strong>abstract out the dependency providing</strong> to a helper function:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">callWithDeps</span><span class="hljs-params">(someFunction,arg1,arg2,arg3)</span></span>
</code></pre><p>It is now <strong>up to <code>callWithDeps</code> to call <code>someFunction</code></strong> with the needed <strong>dependencies</strong>!</p>
</div></section><section class="slide" data-pos="6-2-8">
<span class="pos">6-2-8</span>
<div class="slidecontent"><p>Internally, <code>callWithDeps</code> would</p>
<ol>
<li><strong>look at the <code>neededDeps</code> prop</strong> of the provided function.</li>
<li>use the <strong>dependencyID:s</strong> to <strong>procure dep instances</strong> from some kind of <strong>repository</strong></li>
<li><strong>call the function with the deps</strong></li>
</ol>
</div></section><section class="slide" data-pos="6-2-9">
<span class="pos">6-2-9</span>
<div class="slidecontent"><p>Of course this assumes that the <strong>dependencies have been registered in the repository</strong> with the corresponding ID:s.</p>
</div></section><section class="slide question" data-pos="6-2-10">
<span class="pos">6-2-10</span>
<div class="slidecontent">
<p>Ok, so we abstract out the dependency providing. Fine. <strong>What is the point</strong>?</p>
</div></section><section class="slide answer" data-pos="6-2-11">
<span class="pos">6-2-11</span>
<div class="slidecontent">
<p>There&#39;s many! Here&#39;s a few:</p>
<ul>
<li>It makes usage <strong>convenient</strong> (if done right)</li>
<li>We can <strong>manipulate the repo</strong> in a testing scenario to <strong>provide mocks</strong></li>
<li>The <strong>repository becomes a recipe for the app</strong></li>
<li>It makes <strong>static analysis</strong> of the app easier, enabling things like <strong>dependency graphs</strong>.</li>
</ul>
</div></section><section class="slide" data-pos="6-2-12">
<span class="pos">6-2-12</span>
<div class="slidecontent"><p>Also, in our example we played around with <strong>dependencies for function calls</strong>.</p>
<p>But in our Angular code we declare <strong>dependencies for instantiation</strong>, which makes more sense to leave to the system. Subsequent usage of the instance isn&#39;t affected.</p>
</div></section><section class="slide" data-pos="6-2-13">
<span class="pos">6-2-13</span>
<div class="slidecontent"><p>A final note: <strong>dependency injection</strong> (DI), and <strong>inversion of control</strong> (IoC) which DI is an example of, are <strong>design patterns</strong> with <strong>exact definitions</strong> that we haven&#39;t religiously adhered to in our explanations.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>6-3.</span> Dependencies in AngularJS</h3>
      <p>Writing a wishlist yesterday</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="6-3-1">
<span class="pos">6-3-1</span>
<div class="slidecontent"><p>Already back in <strong>AngularJS</strong> we <strong>had dependency injection</strong>. </p>
<p>In order to understand the new Angular implementation we will first <strong>explore AngularJS&#39;s solution</strong>!</p>
</div></section><section class="slide" data-pos="6-3-2">
<span class="pos">6-3-2</span>
<div class="slidecontent"><p>AngularJS used a very simple system: the <strong>constructor function parameters</strong> were used as <strong>dependency ID:s</strong>.</p>
</div></section><section class="slide" data-pos="6-3-3">
<span class="pos">6-3-3</span>
<div class="slidecontent"><p>So when AngularJS needs to <strong>call this constructor</strong>:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myConstructor</span><span class="hljs-params">(someDepName, anotherDepName)</span></span>{
  <span class="hljs-comment">// doing stuff</span>
}
</code></pre><p>...it would <strong>look in the repository</strong> for dependencies named <strong><code>someDepName</code></strong> and <strong><code>anotherDepName</code></strong>.</p>
</div></section><section class="slide" data-pos="6-3-4">
<span class="pos">6-3-4</span>
<div class="slidecontent"><p>So if you had previously <strong>registered resources</strong>...</p>
<pre><code><span class="hljs-keyword">module</span>.service(<span class="hljs-string">'myService'</span>, definition)
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">value</span>(<span class="hljs-string">'someConst'</span>, <span class="hljs-number">42</span>)
</code></pre></div></section><section class="slide" data-pos="6-3-5">
<span class="pos">6-3-5</span>
<div class="slidecontent"><p>...then your constructor could simply <strong>name these resources</strong>:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myConstructor</span><span class="hljs-params">(myService, someConst)</span></span>{
  <span class="hljs-comment">// doing stuff</span>
}
</code></pre><p>...and they <strong>would be provided to you</strong>.</p>
</div></section><section class="slide" data-pos="6-3-6">
<span class="pos">6-3-6</span>
<div class="slidecontent"><p>There was also a bunch of <strong>built-in resources</strong> that you could name:</p>
<pre><code class="lang-javascript">[<span class="hljs-string">'$scope'</span>,<span class="hljs-string">'$rootScope'</span>,<span class="hljs-string">'$http'</span>, ...]
</code></pre>
<p>The <code>$</code> character signifies that this is built-in and not user defined.</p>
</div></section><section class="slide question" data-pos="6-3-7">
<span class="pos">6-3-7</span>
<div class="slidecontent">
<p>Wait. So the parameters are resource ID:s. I get a <strong>reference to the function</strong>. But how do I <strong>derive the parameter names</strong> from that? There is no <code>func.params</code> thing, is there?</p>
</div></section><section class="slide answer" data-pos="6-3-8">
<span class="pos">6-3-8</span>
<div class="slidecontent">
<p>No, <strong>there isn&#39;t</strong>, and I&#39;m glad you asked!</p>
<p>So, the black magic they&#39;re using is a <strong>weirdness with string casting</strong> in JavaScript.</p>
</div></section><section class="slide" data-pos="6-3-9">
<span class="pos">6-3-9</span>
<div class="slidecontent"><p>For example, if we try to <strong>cast an object to a string</strong>...</p>
<pre><code class="lang-javascript">myObj.toString()
</code></pre>
<p>...we get this <strong>completely useless output</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-string">"[object Object]"</span>
</code></pre>
</div></section><section class="slide" data-pos="6-3-10">
<span class="pos">6-3-10</span>
<div class="slidecontent"><p>But, if we <strong>cast a function to a string</strong>...</p>
<pre><code class="lang-javascript">myFunc.toString()
</code></pre>
<p>...we get the <strong>source code as a string</strong>!</p>
<pre><code class="lang-javascript"><span class="hljs-string">"function myFunc(anArg, anotherArg, aThirdArg){ ... }"</span>
</code></pre>
</div></section><section class="slide" data-pos="6-3-11">
<span class="pos">6-3-11</span>
<div class="slidecontent"><p>So attacking that string with some <strong>regex magic</strong>...</p>
<pre><code class="lang-javascript">myFunc.toString().match(<span class="hljs-regexp">/^[^(]*\((.*?)\)/</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-regexp">/, */</span>)
</code></pre>
<p>...we get a <strong>list of parameter names</strong>!</p>
<pre><code class="lang-javascript">[<span class="hljs-string">'anArg'</span>, <span class="hljs-string">'anotherArg'</span>, <span class="hljs-string">'aThirdArg'</span>]
</code></pre>
<p>This is <strong>what AngularJS does under the hood</strong>.</p>
</div></section><section class="slide" data-pos="6-3-12">
<span class="pos">6-3-12</span>
<div class="slidecontent"><p>Zooming out: the dependency injection in AngularJS was <strong>widely appreciated</strong>. But it was also <strong>criticised</strong>:</p>
<ul>
<li>The <strong>reliance on parameter spelling is brittle</strong></li>
<li>More <strong>advanced provider gymnastics</strong> was hard</li>
</ul>
<p>Both these issues were <strong>addressed in the new Angular version</strong>!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>6-4.</span> Dependencies in Angular</h3>
      <p>Writing a wishlist today</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="6-4-1">
<span class="pos">6-4-1</span>
<div class="slidecontent"><p>Recall the <strong><code>someFunction</code> example</strong>, where we </p>
<ul>
<li>highlighted the importance to <strong>distinguish between inputs and dependencies</strong></li>
<li>showed that this is <strong>difficult to do for functions</strong> since they only have one entry point</li>
<li>said that <strong>dependencies often end up in the signature</strong> for this reason</li>
</ul>
</div></section><section class="slide" data-pos="6-4-2">
<span class="pos">6-4-2</span>
<div class="slidecontent"><p>In Angular, <strong>all application parts</strong> - whether actual <code>Components</code> or <code>Directives</code> or whatnot - <strong>are classes</strong>...</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeApplicationPart</span> </span>{
  <span class="hljs-keyword">constructor</span>(){ ... }
  someProp = initialVal
  someMethod(){ ... }
}
</code></pre>
<p>...which, in contrast to regular function, means we have <strong>many potential entry point</strong>!</p>
</div></section><section class="slide" data-pos="6-4-3">
<span class="pos">6-4-3</span>
<div class="slidecontent"><p>The <strong>inputs</strong> (and <strong>outputs</strong>) in an Angular component are <strong>decorated properties</strong>...</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeApplicationPart</span> </span>{
  <span class="hljs-keyword">constructor</span>(){ ... }
  @Input someProp = initialVal <span class="hljs-comment">// &lt;--- input!</span>
  @Output() anotherProp = <span class="hljs-keyword">new</span> Emitter&lt;someType&gt;() <span class="hljs-comment">// &lt;--- output!</span>
  someMethod(){ ... }
}
</code></pre>
</div></section><section class="slide" data-pos="6-4-4">
<span class="pos">6-4-4</span>
<div class="slidecontent"><p>...while <strong>dependencies</strong> have a very natural home in the <strong>constructor signature</strong>!</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeApplicationPart</span> </span>{
  <span class="hljs-keyword">constructor</span>(dep1, dep2){ ... } <span class="hljs-comment">// &lt;--- our dependencies</span>
  @Input someProp = initialVal
  @Output() anotherProp = <span class="hljs-keyword">new</span> Emitter&lt;someType&gt;()
  someMethod(){ ... }
}
</code></pre>
<p>Let&#39;s now dig into exactly <strong>how</strong> they are listed!</p>
</div></section><section class="slide" data-pos="6-4-5">
<span class="pos">6-4-5</span>
<div class="slidecontent"><p>First off, the <strong>dependency ID:s are not just pure strings</strong> as in Angular1.</p>
<p>We now call them <strong>tokens</strong>, and most often they are <strong>the class we want an instance from</strong>.</p>
</div></section><section class="slide" data-pos="6-4-6">
<span class="pos">6-4-6</span>
<div class="slidecontent"><p>In an <strong>ES6 version</strong> (that is, non-TypeScript) we <strong>add the token as metadata</strong> using a <strong>decorator</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeApplicationPart</span> </span>{
  <span class="hljs-keyword">constructor</span>(
    @Inject(Dep1Class) dep1,
    @Inject(Dep2Class) dep2
  ){ ... }
}
</code></pre>
</div></section><section class="slide" data-pos="6-4-7">
<span class="pos">6-4-7</span>
<div class="slidecontent"><p>In a <strong>TypeScript version</strong> we just do <strong>regular type annotation</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> SomeApplicationPart {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">dep1: Dep1Class, dep2: Dep2Class</span>) {...}
}
</code></pre>
<p>The <strong>token</strong> and <strong>type</strong> are one and the same!</p>
<p>Even React lovers grudgingly admit that this syntax is <strong>supremely elegant</strong>!</p>
</div></section><section class="slide" data-pos="6-4-8">
<span class="pos">6-4-8</span>
<div class="slidecontent"><p>If you want the dependencies to <strong>become props on the instance</strong>, typescript has the <strong><code>public</code></strong> keyword</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> SomeApplicationPart {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">dep1: Dep1Class, <span class="hljs-keyword">public</span> dep2: Dep2Class</span>) {...}
}

instance.dep1 <span class="hljs-comment">// undefined</span>
instance.dep2 <span class="hljs-comment">// Dep2Class instance</span>
</code></pre>
<p>We can also use <strong><code>private</code></strong>, and then they&#39;re <strong>not available in the template</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>6-5.</span> Providing dependencies</h3>
      <p>the delivery service</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="6-5-1">
<span class="pos">6-5-1</span>
<div class="slidecontent"><p>So now we know <strong>how dependencies are specified</strong>.</p>
<p>Time to see <strong>how they are provided</strong>!</p>
</div></section><section class="slide" data-pos="6-5-2">
<span class="pos">6-5-2</span>
<div class="slidecontent"><p>As you might have guessed, the vehicle for this is <strong>NgModule</strong>.</p>
<p>Every module can list resources for dependency injection in their <strong><code>providers</code></strong> metadata property.</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@NgModule</span>({
  providers: [provider1, provider2, ...]
})
</code></pre>
</div></section><section class="slide" data-pos="6-5-3">
<span class="pos">6-5-3</span>
<div class="slidecontent"><p>A <code>provider</code> is an <strong>object</strong> that...</p>
<ul>
<li><strong>mentions a dependency token</strong> and</li>
<li><strong>explains how to get it</strong></li>
</ul>
</div></section><section class="slide" data-pos="6-5-4">
<span class="pos">6-5-4</span>
<div class="slidecontent"><p>The <strong>most common configuration</strong> looks like this:</p>
<pre><code class="lang-javascript">{ <span class="hljs-attr">provide</span>: SomeClass, <span class="hljs-attr">useClass</span>: SomeClass }
</code></pre>
<p>Note that...</p>
<ul>
<li>the <strong><code>provide</code></strong> prop contains the <strong>token</strong>, and</li>
<li>the <strong><code>useClass</code></strong> prop mentions the <strong>class to be instantiated</strong>.</li>
</ul>
</div></section><section class="slide" data-pos="6-5-5">
<span class="pos">6-5-5</span>
<div class="slidecontent"><p>Because <strong>using the wanted class as a token is so common</strong>, Angular lets you use this:</p>
<pre><code><span class="hljs-attribute">SomeClass</span>
</code></pre><p>...as a shorthand for this:</p>
<pre><code>{ <span class="hljs-attribute">provide</span>: SomeClass, useClass: SomeClass }
</code></pre></div></section><section class="slide list" data-pos="6-5-6">
<span class="pos">6-5-6</span>
<div class="slidecontent">
<p>So there are <strong>three parts to DI</strong>:</p>
<ul>
<li><span>a</span>Declaring the <strong>class to be injected</strong></li>
<li><span>b</span><strong>Providing the dependency</strong> in <code>NgModule</code></li>
<li><span>c</span>Use it as <strong>construction parameter</strong> in a component.</li>
</ul>
<p>Let&#39;s see all this in action!</p>
</div></section><section class="slide num numA" data-pos="6-5-7">
<span class="pos">6-5-7</span>
<div class="slidecontent">
<p>Here&#39;s the super useful <strong>class we want to inject</strong>:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dependency</span> </span>{
  foo = <span class="hljs-string">'bar'</span>
}
</code></pre><p>An instance would get a prop <code>foo</code> with the value <code>&#39;bar&#39;</code>.</p>
</div></section><section class="slide num numB" data-pos="6-5-8">
<span class="pos">6-5-8</span>
<div class="slidecontent">
<p>To <strong>make <code>Dependency</code> available</strong> we register it in an <code>NgModule</code>:</p>
<pre><code><span class="hljs-variable">@NgModule</span>({
    <span class="hljs-attribute">imports</span>:      [ BrowserModule ],
    <span class="hljs-attribute">declarations</span>: [ AppComponent ],
    <span class="hljs-attribute">bootstrap</span>:    [ AppComponent ],
    <span class="hljs-attribute">providers</span>:    [ Dependency ] <span class="hljs-comment">// [ {provides: Dependency, useClass: Dependency} ]</span>
})
class AppModule {}
</code></pre></div></section><section class="slide num numC" data-pos="6-5-9">
<span class="pos">6-5-9</span>
<div class="slidecontent">
<p>Now we can <strong>inject it into a component</strong>:</p>
<pre><code><span class="hljs-variable">@Component</span>({
  <span class="hljs-attribute">selector</span>: <span class="hljs-string">'app'</span>,
  <span class="hljs-attribute">template</span>: <span class="hljs-built_in">`Value from dependency: {{dep.foo}}`</span>,
})
export class AppComponent {
  <span class="hljs-selector-tag">constructor</span>(public <span class="hljs-attribute">dep</span>: Dependency) {}
}
</code></pre><p>You can <strong>see this in action</strong> in the <a href="resources/supportsite/demos/injection_class" target="_blank">Class Dependency</a> demo!</p>
</div></section><section class="slide" data-pos="6-5-10">
<span class="pos">6-5-10</span>
<div class="slidecontent"><p>Note that <strong>providers aren&#39;t limited by lines of sight</strong>. Unless you take specific measures, <strong>all providers are visible in all modules</strong>.</p>
<p>This is by design; normally you want all components to <strong>share a single instance</strong> of your service.</p>
</div></section><section class="slide" data-pos="6-5-11">
<span class="pos">6-5-11</span>
<div class="slidecontent"><p>This means that when you want to <strong>test your components</strong> (or directives or other part), we <strong>use test-specific providers</strong>.</p>
</div></section><section class="slide" data-pos="6-5-12">
<span class="pos">6-5-12</span>
<div class="slidecontent"><p>Unlike in AngularJS, the <strong>built-in injectables</strong> are <strong>not automatically available</strong>! You have to manually <strong>import the module they live in</strong>.</p>
<p>For example, the <strong><code>http</code> service</strong> is provided by the <strong><code>HttpModule</code></strong>, which must be <strong>imported by your module</strong>.</p>
</div></section><section class="slide" data-pos="6-5-13">
<span class="pos">6-5-13</span>
<div class="slidecontent"><p>The <strong>robust and flexible dependency injection</strong> is one of Angular&#39;s <strong>main advantage over other frameworks</strong> such as React, which lacks an equivalent system.</p>
</div></section><section class="slide" data-pos="6-5-14">
<span class="pos">6-5-14</span>
<div class="slidecontent"><p>So it might <strong>seem abstract and hard</strong>, but <strong>take the time to get to know it</strong> as it will be well worth the effort!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>6-6.</span> Non-class dependencies</h3>
      <p>not as classy anymore</p>
</p>
    </div>
  </section>
  <section class="slide question" data-pos="6-6-1">
<span class="pos">6-6-1</span>
<div class="slidecontent">
<p>We just saw the elegant solution to <strong>providing class instances</strong> by using <strong>the token as the type</strong> for the parameter.</p>
<p>But, what if we want to provide, say <strong>a constant</strong>?</p>
</div></section><section class="slide answer" data-pos="6-6-2">
<span class="pos">6-6-2</span>
<div class="slidecontent">
<p>For this you would provide <strong><code>useValue</code></strong> instead of <code>useClass</code>:</p>
<pre><code>{<span class="hljs-attribute">provide</span>: MyToken, useValue: <span class="hljs-number">42</span>}
</code></pre><p>But you already noticed the bigger problem - <strong>what should <code>MyToken</code> be</strong>?</p>
</div></section><section class="slide" data-pos="6-6-3">
<span class="pos">6-6-3</span>
<div class="slidecontent"><p>We could imagine making a <strong>dummy class</strong>:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyToken</span> </span>{}
</code></pre><p>And <strong>use that as type</strong> in the component:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(val: MyToken)</span></span>
</code></pre></div></section><section class="slide" data-pos="6-6-4">
<span class="pos">6-6-4</span>
<div class="slidecontent"><p>Or we could just use a <strong>string constant</strong>:</p>
<pre><code><span class="hljs-keyword">const</span> MyToken = <span class="hljs-string">'SOME_UNIQUE_STRING'</span>
</code></pre></div></section><section class="slide list" data-pos="6-6-5">
<span class="pos">6-6-5</span>
<div class="slidecontent">
<p>But there are <strong>two problems</strong> with these solutions:</p>
<ul>
<li><span>a</span>There&#39;s a <strong>type mismatch</strong>. We claim <code>val</code> is a <code>MyToken</code>, but it is a number!</li>
<li><span>b</span><strong>Dummy classes are inelegant</strong> and <strong>magic strings dangerous</strong>.</li>
</ul>
</div></section><section class="slide num numA" data-pos="6-6-6">
<span class="pos">6-6-6</span>
<div class="slidecontent">
<p>We solve the <strong>type mismatch</strong> by using the <strong><code>Inject</code> decorator</strong> we saw earlier for the non-typescript version:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(@Inject(MyToken)</span> <span class="hljs-title">val</span>:</span> number) <span class="hljs-comment">{}</span>
</code></pre></div></section><section class="slide" data-pos="6-6-7">
<span class="pos">6-6-7</span>
<div class="slidecontent"><p>Now the <strong>token is supplied as metadata</strong>, and we have a <strong>true type annotation</strong>.</p>
<p>Not as sleek as when the token was the type, but for good reason - the <strong>token isn&#39;t the type</strong> here!</p>
</div></section><section class="slide num numB" data-pos="6-6-8">
<span class="pos">6-6-8</span>
<div class="slidecontent">
<p>Regarding tokens for non-class dependencies, Angular has an <strong><code>InjectionToken</code></strong> creator for this purpose:</p>
<pre><code><span class="hljs-keyword">const</span> MyToken = InjectionToken(<span class="hljs-string">'someDescriptiveString'</span>);

<span class="hljs-comment">// Typed version</span>
<span class="hljs-keyword">const</span> MyToken = InjectionToken&lt;SomeType&gt;(<span class="hljs-string">'someDescriptiveString'</span>);
</code></pre></div></section><section class="slide" data-pos="6-6-9">
<span class="pos">6-6-9</span>
<div class="slidecontent"><p>Previously there was an <strong><code>OpaqueToken</code></strong>, but that has been deprecated and replaced by <code>InjectionToken</code>.</p>
</div></section><section class="slide" data-pos="6-6-10">
<span class="pos">6-6-10</span>
<div class="slidecontent"><p>If you need more control, there&#39;s also a <strong><code>useFactory</code> option</strong> where you supply a function, and the <strong>returned value is provided</strong>.</p>
<pre><code>{<span class="hljs-attribute">provide</span>: MyToken, useFactory: ()=&gt; <span class="hljs-number">42</span>}
</code></pre><p>Try it in the <a href="resources/supportsite/demos/injection_value_opaque" target="_blank">Constant Dependency</a> demo!</p>
</div></section><section class="slide" data-pos="6-6-11">
<span class="pos">6-6-11</span>
<div class="slidecontent"><p>For when you need <strong>other dependencies injected into the factory</strong> you need to <strong>list the tokens in the <code>deps</code> prop</strong>.</p>
<pre><code>{
  <span class="hljs-attribute">provide</span>: MyToken,
  useFactory: (someDep)=&gt; someDep.<span class="hljs-built_in">doSomething</span>(),
  deps: [SomeDepToken]
}
</code></pre><p>See this in action in the <a href="resources/supportsite/demos/injection_value_factory_dep" target="_blank">Dependency Factory</a> demo!</p>
</div></section><section class="slide" data-pos="6-6-12">
<span class="pos">6-6-12</span>
<div class="slidecontent"><p>A final note: don&#39;t hesitate to <strong>use dependency injection for constants</strong>!</p>
<p>It might <strong>seem like overkill</strong>, but the...</p>
<ul>
<li><strong>fine-grained control</strong> and</li>
<li><strong>code predictability</strong></li>
</ul>
<p>..that you gain is hard to beat!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>6-7.</span> Services</h3>
      <p>where are they?</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="6-7-1">
<span class="pos">6-7-1</span>
<div class="slidecontent"><p>Let&#39;s take a brief moment to discuss the word <strong><code>Service</code></strong>.</p>
<p>In <strong>AngularJS they meant something specific</strong> - it was a <strong>type of building block</strong> that we explicitly defined on our modules, alongside <code>controllers</code> and <code>directives</code> and the rest.</p>
<p>Yet so far we&#39;ve seen <strong>no mention of them in the new Angular</strong>!</p>
</div></section><section class="slide" data-pos="6-7-2">
<span class="pos">6-7-2</span>
<div class="slidecontent"><p>That is simply because we <strong>don&#39;t need the concept</strong>. Angular lets us <strong>provide whatever values we want</strong> through registering providers in our modules.</p>
<p>Where those values come from is <strong>completely up to us</strong>.</p>
</div></section><section class="slide" data-pos="6-7-3">
<span class="pos">6-7-3</span>
<div class="slidecontent"><p>Still, the <strong>term <code>Service</code> has carried over to Angular</strong>, even though it has <strong>no technical meaning</strong>.</p>
<p>It simply means <strong>a <code>class</code> available for injection</strong>.</p>
</div></section><section class="slide" data-pos="6-7-4">
<span class="pos">6-7-4</span>
<div class="slidecontent"><p>As with AngularJS, there are a whole slew of <strong>built-in &quot;services&quot;</strong>.</p>
<p>And just like with directives, a big part of <strong>learning Angular</strong> means <strong>learning what is already there</strong> and <strong>when to use it</strong>.</p>
</div></section><section class="slide" data-pos="6-7-5">
<span class="pos">6-7-5</span>
<div class="slidecontent"><p>If your <strong>dependency has dependencies</strong>, we need to <strong>mark it with the <code>Injectable</code> decorator</strong> to let Angular know that this class also needs to be part of the dependency graph.</p>
<pre><code><span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> Dependency {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> foo:Dependency2</span>){}
}
</code></pre></div></section><section class="slide" data-pos="6-7-6">
<span class="pos">6-7-6</span>
<div class="slidecontent"><p>Although <strong>dependencies with dependencies might seem a special case</strong>, make note;</p>
<ul>
<li>This is actually where <strong>DI really shines</strong>, as managing this manually is hard</li>
<li>It <strong>isn&#39;t that uncommon</strong>. For example, your custom service might use the http service.</li>
</ul>
</div></section><section class="slide list" data-pos="6-7-7">
<span class="pos">6-7-7</span>
<div class="slidecontent">
<p>Typically, a service will...</p>
<ul>
<li><span>a</span><strong>own a piece of data</strong> that is of interest to many components</li>
<li><span>b</span>allow components to <strong>subscribe to that data</strong></li>
<li><span>c</span>allow components to <strong>update the data</strong>, and notify all subscribers when that happen</li>
</ul>
</div></section><section class="slide num numA" data-pos="6-7-8">
<span class="pos">6-7-8</span>
<div class="slidecontent">
<p>The data will be a <strong>private variable</strong> within the service class:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">class</span> serviceExample {
  <span class="hljs-keyword">private</span> data = someInitialValue;
}
</code></pre>
<p>It is <strong>not directly accessible</strong> from the outside.</p>
</div></section><section class="slide num numB" data-pos="6-7-9">
<span class="pos">6-7-9</span>
<div class="slidecontent">
<p>Instead, the service provides a <strong>subscription service</strong>:</p>
<pre><code class="lang-typescript">  <span class="hljs-keyword">private</span> listeners: <span class="hljs-built_in">Function</span>[] = [];
  subscribe(callback: <span class="hljs-built_in">Function</span>){
    <span class="hljs-keyword">this</span>.listeners.push(callback);
    callback(<span class="hljs-keyword">this</span>.data); <span class="hljs-comment">// also serve them the data as is right now</span>
  }
</code></pre>
</div></section><section class="slide" data-pos="6-7-10">
<span class="pos">6-7-10</span>
<div class="slidecontent"><p>Components will <strong>call <code>.subscribe</code> with a callback</strong> which will be called with the data whenever the data updates.</p>
<p>Typically, in that callback, the component will <strong>store a local reference</strong> to the data:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">constructor</span>(<span class="hljs-params">service: Service</span>){
  service.subscribe(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-keyword">this</span>.data = data);
}
</code></pre>
</div></section><section class="slide" data-pos="6-7-11">
<span class="pos">6-7-11</span>
<div class="slidecontent"><p>The service usually has a private <code>notifyListeners</code> method that will call all currently registered subscribers with the fresh data:</p>
<pre><code class="lang-typescript">  <span class="hljs-keyword">private</span> notifyListeners(){
    <span class="hljs-keyword">this</span>.listeners.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-keyword">this</span>.data));
  }
</code></pre>
</div></section><section class="slide num numC" data-pos="6-7-12">
<span class="pos">6-7-12</span>
<div class="slidecontent">
<p>Finally, the service usually exposes an <strong>.updateData</strong> method which will...</p>
<ul>
<li>update the private data</li>
<li>call the <code>.notifyListeners</code> method</li>
</ul>
<pre><code class="lang-typescript">  updateData(newData){
    <span class="hljs-keyword">this</span>.data = newData;
    <span class="hljs-keyword">this</span>.notifyListeners();
  }
</code></pre>
</div></section><section class="slide" data-pos="6-7-13">
<span class="pos">6-7-13</span>
<div class="slidecontent"><p>Here&#39;s the <strong>full source</strong> for our typical example service:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">class</span> serviceExample {
  <span class="hljs-keyword">private</span> data = someInitialValue;
  <span class="hljs-keyword">private</span> listeners: <span class="hljs-built_in">Function</span>[] = [];
  subscribe(callback: <span class="hljs-built_in">Function</span>){
    <span class="hljs-keyword">this</span>.listeners.push(callback);
    callback(<span class="hljs-keyword">this</span>.data); <span class="hljs-comment">// also serve them the data as is right now</span>
  }
  updateData(newData){
    <span class="hljs-keyword">this</span>.data = newData;
    <span class="hljs-keyword">this</span>.notifyListeners();
  }
  <span class="hljs-keyword">private</span> notifyListeners(){
    <span class="hljs-keyword">this</span>.listeners.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-keyword">this</span>.data));
  }
}
</code></pre>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>6-8.</span> Gamebook - dependencies</h3>
      <p>Lethal injection</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="6-8-1">
<span class="pos">6-8-1</span>
<div class="slidecontent"><p>You know the drill;</p>
<ol>
<li><strong>copy the folder of the previous version</strong>,</li>
<li><strong>paste it</strong> right next to that version, and</li>
<li>give it the name <strong><code>FF06-dependencies</code></strong>.</li>
</ol>
</div></section><section class="slide" data-pos="6-8-2">
<span class="pos">6-8-2</span>
<div class="slidecontent"><p>So! If <strong>dependency injection</strong> is as cool as they say, we&#39;d better <strong>use it in our gamebook app</strong>!</p>
<p>To try our hand at this, we&#39;re going to implement a <strong><code>StateHandler</code></strong> service.</p>
</div></section><section class="slide" data-pos="6-8-3">
<span class="pos">6-8-3</span>
<div class="slidecontent"><p>This service will <strong>take over responsibilities from <code>app.ts</code></strong>, primarily the <strong>ownership of <code>gameState</code></strong>.</p>
<p>Instead, <code>app.ts</code> and <code>scene.ts</code> will have to <strong>subscribe</strong> to the data on the service, much like example you just saw.</p>
</div></section><section class="slide" data-pos="6-8-4">
<span class="pos">6-8-4</span>
<div class="slidecontent"><p>However, instead of making the components subscribe and update <code>GameState</code>, consider this; in the components we...</p>
<ul>
<li>use <code>GameState</code> only to calculate <code>CurrentScene</code></li>
<li>update <code>GameState</code> after selecting an <code>Option</code></li>
</ul>
</div></section><section class="slide" data-pos="6-8-5">
<span class="pos">6-8-5</span>
<div class="slidecontent"><p>So, let&#39;s reflect that in our service API! We should let components...</p>
<ul>
<li><strong>subscribe to <code>Scene</code></strong>, not <code>GameState</code> (thus moving the getter logic to the service)</li>
<li><strong>submit an <code>Option</code></strong>, not <code>GameState</code> (and let the service figure out the updated state)</li>
</ul>
<p>If you did the <strong>reset challenge</strong> then we also need a separate <code>.reset</code> method on the service.</p>
</div></section><section class="slide list" data-pos="6-8-6">
<span class="pos">6-8-6</span>
<div class="slidecontent">
<p>So, here&#39;s the masterplan!</p>
<ul>
<li><span>a</span><strong>add a <code>statehandler.ts</code> file</strong> with the service</li>
<li><span>b</span><strong>expose the service in <code>NgModule</code></strong></li>
<li><span>c</span><strong>use it in <code>SceneComponent</code></strong></li>
<li><span>d</span><strong>use it in <code>AppComponent</code></strong></li>
</ul>
</div></section><section class="slide num numA" data-pos="6-8-7">
<span class="pos">6-8-7</span>
<div class="slidecontent">
<p>Here&#39;s a <strong>skeleton for <code>statehandler.ts</code></strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> StateHandler {
  <span class="hljs-keyword">private</span> listeners: <span class="hljs-built_in">Function</span>[] <span class="hljs-comment">// all interested callbacks</span>
  <span class="hljs-keyword">private</span> gameState: GameState <span class="hljs-comment">// current state</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">get</span> currentScene() { ... } <span class="hljs-comment">// calculate using `gameState` + adventure</span>
  <span class="hljs-keyword">private</span> notifyListeners() { ... } <span class="hljs-comment">// call all callbacks with `currentScene`</span>
  subscribeToScene(cb: <span class="hljs-built_in">Function</span>) { ... } <span class="hljs-comment">// add listener</span>
  executeOption(opt: Option) { ... } <span class="hljs-comment">// update state, notify listeners</span>
  reset() { ... } <span class="hljs-comment">// reset to adventure startstate, notify listeners</span>
}
</code></pre>
</div></section><section class="slide num numB" data-pos="6-8-8">
<span class="pos">6-8-8</span>
<div class="slidecontent">
<p>With the <code>stateHandler</code> created, we must <strong>add it to the <code>providers</code> array</strong> in the root <code>NgModule</code>:</p>
<pre><code class="lang-typescript">providers: [ StateHandler ]
</code></pre>
<p>We&#39;ll use the <strong>normal shorthand where the class is also the token</strong>.</p>
</div></section><section class="slide num numC" data-pos="6-8-9">
<span class="pos">6-8-9</span>
<div class="slidecontent">
<p>Now we turn to <code>SceneComponent</code>, which should get the <strong>service injected</strong>. And:</p>
<ul>
<li>Instead of <strong>receiving <code>currentScene</code> as an input</strong> it should <strong>subscribe via the service</strong></li>
<li>Instead of <strong>emitting <code>Option</code> as an output</strong> it should <strong>send it to the service</strong></li>
</ul>
<p>In other words, it will <strong>no longer have inputs or outputs</strong>!</p>
</div></section><section class="slide num numD" data-pos="6-8-10">
<span class="pos">6-8-10</span>
<div class="slidecontent">
<p>...which also means that <strong><code>AppComponent</code> becomes skinnier</strong> since it no longer needs to pass stuff to <code>SceneComponent</code>.</p>
<p>In fact, it doesn&#39;t even need the service either! Unless you made it <strong>apply special graphics to GameOver scenes</strong>, in which case we do need to subscribe to <code>Scene</code> from the service.</p>
</div></section><section class="slide" data-pos="6-8-11">
<span class="pos">6-8-11</span>
<div class="slidecontent"><p><strong>Build, reload</strong>, and see if <strong>all still works like before</strong>!</p>
</div></section><section class="slide challenge" data-pos="6-8-12">
<span class="pos">6-8-12</span>
<div class="slidecontent"><p><strong>Challenge</strong>: If you have time left over, let&#39;s <strong>clean up a code smell</strong>!</p>
<p>Right now we&#39;re <strong><code>import</code>ing the <code>adventure</code> data</strong> in <code>app.ts</code> to use it inside <code>AppComponent</code>, and in <code>statehandler.ts</code> to initiate game state in the <code>StateHandler</code> service.</p>
<p>We should inject the adventure to those places instead!</p>
</div></section><section class="slide" data-pos="6-8-13">
<span class="pos">6-8-13</span>
<div class="slidecontent"><p>This will likely involve an <strong>InjectionToken</strong> defined in a separate file, that you refer to in the <code>NgModules</code> providers array as well as in the <code>AppComponent</code>.</p>
<p>If you need, peek again at the <a href="resources/supportsite/demos/injection_value_opaque" target="_blank">Inject non-class</a> demo.</p>
</div></section><section class="slide challenge" data-pos="6-8-14">
<span class="pos">6-8-14</span>
<div class="slidecontent"><p><strong>Challenge</strong>: And here&#39;s a neat one - why not <strong>make <code>stateHandler</code> load and save to localStorage</strong>?</p>
<p>In other words - when you go to the next page, and <strong>reload</strong>, your <strong>state should be saved</strong>!</p>
</div></section><section class="slide" data-pos="6-8-15">
<span class="pos">6-8-15</span>
<div class="slidecontent"><p>Two lines of code that <strong>might come in handy</strong> for this:</p>
<pre><code class="lang-typescript"><span class="hljs-built_in">JSON</span>.parse( localStorage.getItem(SAVEKEY) || <span class="hljs-string">"{}"</span> ) <span class="hljs-comment">// loading</span>
</code></pre>
<p>...and...</p>
<pre><code class="lang-typescript">localStorage.setItem( SAVEKEY, <span class="hljs-built_in">JSON</span>.stringify(state) );
</code></pre>
<p>...where <code>SAVEKEY</code> is some unique string identifier.</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 7 / 13</span>
    <h2>Forms</h2>
    <p>we all love them</p>
</p>
  </div>
  
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. Two-way data binding</li>
<li>2. Forms</li>
<li>3. Validation</li>
<li>4. Reactive forms</li>
<li>5. Template referencing</li>
<li>6. Gamebook - extras</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>7-1.</span> Two-way data binding</h3>
      <p>Going both ways at once</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="7-1-1">
<span class="pos">7-1-1</span>
<div class="slidecontent"><p>Before we can even begin to get into forms, we need to talk about <strong>two-way data binding</strong>. In essence, making a <strong>form element synced to a model value</strong>.</p>
</div></section><section class="slide" data-pos="7-1-2">
<span class="pos">7-1-2</span>
<div class="slidecontent"><p>Previously we went <strong>full circle</strong> in the communication:</p>
<p><img src="resources/diagrams/view-model.svg" alt=""></p>
</div></section><section class="slide" data-pos="7-1-3">
<span class="pos">7-1-3</span>
<div class="slidecontent"><p>But there is a <strong>common special case</strong> that warrants extra mention - what if an element in the UI wants to <strong>both display and mutate</strong> a value?</p>
</div></section><section class="slide" data-pos="7-1-4">
<span class="pos">7-1-4</span>
<div class="slidecontent"><p>Here is the <strong>simplest possible example</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"name"</span> (<span class="hljs-attr">input</span>)=<span class="hljs-string">"name = $event.target.value"</span>&gt;</span>
</code></pre>
<p>The <code>input</code> element both <strong>reads and writes to the <code>name</code> model variable</strong>.</p>
</div></section><section class="slide" data-pos="7-1-5">
<span class="pos">7-1-5</span>
<div class="slidecontent"><p>This means that <strong>if <code>name</code> was changed by someone else, the element would update</strong>!</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
  Edit name:
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"name"</span> (<span class="hljs-attr">input</span>)=<span class="hljs-string">"name = $event.target.value"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"name = 'Batman'"</span>&gt;</span>put on costume<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I'm {{name}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</code></pre>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> AppComponent {
  name = <span class="hljs-string">'Bruce'</span>
}
</code></pre>
</div></section><section class="slide" data-pos="7-1-6">
<span class="pos">7-1-6</span>
<div class="slidecontent"><p>We just did two-way binding on a <strong>text field</strong>...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
  [<span class="hljs-attr">value</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">input</span>)=<span class="hljs-string">"val = $event.target.value"</span>&gt;</span>
</code></pre>
<p>...but it works equally well on <strong>other input types</strong>, for instance a <strong>check box</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
  [<span class="hljs-attr">checked</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">change</span>)=<span class="hljs-string">"val = $event.target.checked"</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="7-1-7">
<span class="pos">7-1-7</span>
<div class="slidecontent"><p>If we compare them...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
  [<span class="hljs-attr">value</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">input</span>)=<span class="hljs-string">"val = $event.target.value"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
  [<span class="hljs-attr">checked</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">change</span>)=<span class="hljs-string">"val = $event.target.checked"</span>&gt;</span>
</code></pre>
<p>...we see that <strong>3 things differ</strong> depending on input type:</p>
<ul>
<li>The <strong>property name</strong> to bind to</li>
<li>The <strong>event name</strong> to listen to</li>
<li>The <strong>value location</strong> in the event object</li>
</ul>
</div></section><section class="slide" data-pos="7-1-8">
<span class="pos">7-1-8</span>
<div class="slidecontent"><p>To help <strong>abstract away these differences</strong>, Angular comes with a <strong>prebuilt <code>ngModel</code> directive</strong>. Our previous examples...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
  [<span class="hljs-attr">value</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">input</span>)=<span class="hljs-string">"val = $event.target.value"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
  [<span class="hljs-attr">checked</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">change</span>)=<span class="hljs-string">"val = $event.target.checked"</span>&gt;</span>
</code></pre>
<p>...would <strong>become this</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
  [<span class="hljs-attr">ngModel</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">ngModelChange</span>)=<span class="hljs-string">"val = $event"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
  [<span class="hljs-attr">ngModel</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">ngModelChange</span>)=<span class="hljs-string">"val = $event"</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="7-1-9">
<span class="pos">7-1-9</span>
<div class="slidecontent"><p>Looking at the new code in detail...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
  [<span class="hljs-attr">ngModel</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">ngModelChange</span>)=<span class="hljs-string">"val = $event"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
  [<span class="hljs-attr">ngModel</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">ngModelChange</span>)=<span class="hljs-string">"val = $event"</span>&gt;</span>
</code></pre>
<p>...we see that <code>ngModel</code> <strong>dealt with the 3 differences</strong> like this:</p>
<ul>
<li>The <strong>property</strong> is exposed as <code>ngModel</code></li>
<li>The <strong>event</strong> is exposed as <code>ngModelChange</code></li>
<li>The event object becomes the <strong>value</strong></li>
</ul>
</div></section><section class="slide question" data-pos="7-1-10">
<span class="pos">7-1-10</span>
<div class="slidecontent">
<p>Wait - sometimes there are <strong>many different events</strong> we could bind to, like on a text field.</p>
<p><strong>How does <code>ngModel</code> decide the exact event</strong>?</p>
</div></section><section class="slide answer" data-pos="7-1-11">
<span class="pos">7-1-11</span>
<div class="slidecontent">
<p>Good question! It always go for the <strong>real-time approach</strong>.</p>
</div></section><section class="slide question" data-pos="7-1-12">
<span class="pos">7-1-12</span>
<div class="slidecontent">
<p>And, the <strong>homogenisation</strong> offered by <code>ngModel</code> seems like a <strong>very small win</strong>. What&#39;s the big deal?</p>
<p>We&#39;re all web developers, we know what events and properties to bind to!</p>
</div></section><section class="slide answer" data-pos="7-1-13">
<span class="pos">7-1-13</span>
<div class="slidecontent">
<p>Again a good question! The win would indeed be small, if not for the fact that <strong>this exact pattern</strong>...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> [<span class="hljs-attr">ngModel</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">ngModelChange</span>)=<span class="hljs-string">"val = $event"</span>&gt;</span>
</code></pre>
<p>...can be expressed with the <strong><code>bindon-</code> syntax</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">bindon-ngModel</span>=<span class="hljs-string">"val"</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="7-1-14">
<span class="pos">7-1-14</span>
<div class="slidecontent"><p>...and the <strong><code>bindon-</code> syntax</strong>...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">bindon-ngModel</span>=<span class="hljs-string">"val"</span>&gt;</span>
</code></pre>
<p>...has a <strong>shorthand</strong>!</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"val"</span>&gt;</span>
</code></pre>
<p>This is lovingly called the <strong>banana box syntax</strong>.</p>
</div></section><section class="slide" data-pos="7-1-15">
<span class="pos">7-1-15</span>
<div class="slidecontent"><p>So just to come full circle, our <strong>two previous examples</strong>...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
  [<span class="hljs-attr">value</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">input</span>)=<span class="hljs-string">"val = $event.target.value"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
  [<span class="hljs-attr">checked</span>]=<span class="hljs-string">"val"</span> (<span class="hljs-attr">change</span>)=<span class="hljs-string">"val = $event.target.checked"</span>&gt;</span>
</code></pre>
<p>...would <strong>become this</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"val"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checked"</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"val"</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="7-1-16">
<span class="pos">7-1-16</span>
<div class="slidecontent"><p>To use <code>ngModel</code> you must have <strong>imported <code>FormsModule</code></strong> into your app module.</p>
<pre><code><span class="hljs-keyword">import</span> { FormsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;

@NgModule({
    imports: [ BrowserModule, FormsModule ],
    <span class="hljs-regexp">//</span> ...<span class="hljs-keyword">and</span> the rest
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> {}</span>
</code></pre></div></section><section class="slide" data-pos="7-1-17">
<span class="pos">7-1-17</span>
<div class="slidecontent"><p>We <strong>recap this whole syntax trip</strong> in the <a href="resources/supportsite/demos/twoway" target="_blank">Two-way Databinding</a> demo.</p>
</div></section><section class="slide question" data-pos="7-1-18">
<span class="pos">7-1-18</span>
<div class="slidecontent">
<p>Would it be fair to say that <strong><code>ngModel</code> could have been called <code>ngModelValue</code></strong>, since it <strong>connects one value in the model to an input</strong>? </p>
<p><img src="resources/diagrams/ngmodelvalue.svg" alt=""></p>
</div></section><section class="slide answer" data-pos="7-1-19">
<span class="pos">7-1-19</span>
<div class="slidecontent">
<p><strong>Yes</strong>!!</p>
<p>(...although it <strong>also does more things</strong>, as we&#39;ll see later on when we talk about <strong>forms</strong>...)</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>7-2.</span> Forms</h3>
      <p>fill in the blanks</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="7-2-1">
<span class="pos">7-2-1</span>
<div class="slidecontent"><p>There are <strong>two different takes</strong> on forms in Angular:</p>
<ul>
<li><strong>Template-driven forms</strong> where the definitions are in the template. Similar to AngularJS, and likely the most common way of doing it.</li>
<li><strong>Reactive forms</strong> (sometimes called model-driven) where the definition is in the class. More testable, scales better, but also more verbose.</li>
</ul>
<p>We&#39;ll <strong>focus primarily on template-driven forms</strong>, although with a quick look at reactive forms later on.</p>
</div></section><section class="slide question" data-pos="7-2-2">
<span class="pos">7-2-2</span>
<div class="slidecontent">
<p>Looking at the <a href="https://angular.io/docs/ts/latest/guide/forms.html">Forms section in the official docs</a>, or the index of any Angular book, there seems to be <strong>a whole lot to say about forms</strong>.</p>
<p>Yet <strong>you only offer one measly section</strong>, how come?</p>
</div></section><section class="slide answer" data-pos="7-2-3">
<span class="pos">7-2-3</span>
<div class="slidecontent">
<p>Mainly because we&#39;re <strong>staying true to our manifesto</strong> - we want to <strong>explain the way of thinking</strong>, but not <strong>lose too much time on details</strong>.</p>
<p>With forms you need to <strong>grokk the basic setup</strong>, which we&#39;re walking through here, after which it is easy enough to fill in the details.</p>
</div></section><section class="slide" data-pos="7-2-4">
<span class="pos">7-2-4</span>
<div class="slidecontent"><p>Also, we actually have <strong>three sections</strong>, as we&#39;ll be looking at validation and reactive forms separately. :)</p>
</div></section><section class="slide list" data-pos="7-2-5">
<span class="pos">7-2-5</span>
<div class="slidecontent">
<p>So, now we&#39;re going to <strong>dig into template-driven forms</strong>! Specifically, we&#39;ll talk about:</p>
<ul>
<li><span>a</span>the <strong><code>ngForm</code> directive</strong></li>
<li><span>b</span><strong>hooking up inputs</strong></li>
<li><span>c</span><strong>aggregated info</strong></li>
<li><span>d</span><strong>generated classes</strong></li>
</ul>
</div></section><section class="slide num numA" data-pos="7-2-6">
<span class="pos">7-2-6</span>
<div class="slidecontent">
<p>The <strong><code>ngForm</code> directive</strong> is at the heart of it all. Angular will <strong>automatically create it on form elements</strong>.</p>
<p>In other words, if we snoop at the <a href="https://github.com/angular/angular/blob/2.0.2/modules/%40angular/forms/src/directives/ng_form.ts#L62">source code</a>, we should see <strong><code>form</code> used as selector</strong>!</p>
</div></section><section class="slide" data-pos="7-2-7">
<span class="pos">7-2-7</span>
<div class="slidecontent"><p>The <code>ngForm</code> directive contains a <strong>whole lot of functionality</strong> related to the form. Commonly you&#39;ll want to <strong>hook into this within the form</strong>, which is why it is a common practice to <strong>set a reference to it</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> #<span class="hljs-attr">f</span>=<span class="hljs-string">"ngForm"</span>&gt;</span>
</code></pre>
</div></section><section class="slide num numB" data-pos="7-2-8">
<span class="pos">7-2-8</span>
<div class="slidecontent">
<p>To <strong>make inputs part of the <code>ngForm</code> aggregation</strong>, we must:</p>
<ul>
<li><strong>use the <code>ngModel</code> directive</strong>, even if not bound to anything</li>
<li>give it a <strong>name</strong>, as in regular HTML</li>
</ul>
<pre><code>&lt;<span class="hljs-selector-tag">input</span> name=<span class="hljs-string">"lastName"</span> ngModel&gt;
</code></pre></div></section><section class="slide num numC" data-pos="7-2-9">
<span class="pos">7-2-9</span>
<div class="slidecontent">
<p>Now, through <code>ngModel</code>, we can <strong>access aggregated info</strong> for the whole form and do things like <strong>checking overall validity</strong>...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> [<span class="hljs-attr">disabled</span>]=<span class="hljs-string">"!f.form.valid"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Submit"</span>&gt;</span>
</code></pre>
<p>...or <strong>accessing individual values</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"checkName(f.value.lastName)"</span>&gt;</span>
</code></pre>
</div></section><section class="slide num numD" data-pos="7-2-10">
<span class="pos">7-2-10</span>
<div class="slidecontent">
<p>Also, much like in AngularJS, there are lots of <strong>auto-generated CSS classes</strong> to make life easier:</p>
<ul>
<li><code>ng-pristine</code> and <code>ng-dirty</code></li>
<li><code>ng-untouched</code> and <code>ng-touched</code></li>
<li><code>ng-valid</code> and <code>ng-invalid</code></li>
</ul>
<p>These are applied to the <strong>form element</strong> as well as <strong>individual form controls</strong>.</p>
</div></section><section class="slide" data-pos="7-2-11">
<span class="pos">7-2-11</span>
<div class="slidecontent"><p><strong>See it all in action</strong> in the <a href="resources/supportsite/demos/form" target="_blank">Form</a> demo!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>7-3.</span> Validation</h3>
      <p>Attaching the polygraph</p>
</p>
    </div>
  </section>
  <section class="slide list" data-pos="7-3-1">
<span class="pos">7-3-1</span>
<div class="slidecontent">
<p>Now for some <strong>words on validation</strong>! Specifically we&#39;ll discuss</p>
<ul>
<li><span>a</span>disabling native validation</li>
<li><span>b</span>mimicking HTML5 validation</li>
<li><span>c</span>checking validity</li>
<li><span>d</span>writing custom validation</li>
</ul>
</div></section><section class="slide num numA" data-pos="7-3-2">
<span class="pos">7-3-2</span>
<div class="slidecontent">
<p>Modern browsers all have <strong>native validation behaviour</strong>, tying in to the HTML5 validation attributes. So if an <strong>input looks like this</strong>...</p>
<pre><code>&lt;<span class="hljs-selector-tag">input</span> required&gt;
</code></pre><p>...and the input is <strong>empty</strong>, the browser would <strong>somehow hint that it is currently invalid</strong>.</p>
</div></section><section class="slide" data-pos="7-3-3">
<span class="pos">7-3-3</span>
<div class="slidecontent"><p>But in a web app you likely <strong>want control over that yourself</strong>! Fortunately HTML5 has an <strong>attribute to opt out</strong> - just attach <strong><code>novalidate</code></strong> on the form:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> #<span class="hljs-attr">f</span>=<span class="hljs-string">"ngForm"</span> <span class="hljs-attr">novalidate</span>&gt;</span>
</code></pre>
</div></section><section class="slide num numB" data-pos="7-3-4">
<span class="pos">7-3-4</span>
<div class="slidecontent">
<p>As you might have guessed, the <code>FormsModule</code> includes <strong>directives for all HTML5 validation arguments</strong>;</p>
<ul>
<li>required</li>
<li>minlength</li>
<li>maxlength</li>
<li>pattern</li>
</ul>
</div></section><section class="slide" data-pos="7-3-5">
<span class="pos">7-3-5</span>
<div class="slidecontent"><p>In other words, <strong>simply use the attributes as you normally would</strong>, and they will be picked up by Angular.</p>
</div></section><section class="slide num numC" data-pos="7-3-6">
<span class="pos">7-3-6</span>
<div class="slidecontent">
<p>And, as we already spoiled in the previous section, you can <strong>access aggregated validation</strong> through <code>ngForm</code>, checking...</p>
<ul>
<li><strong>validity of individual elements</strong> or</li>
<li>the <strong>form as a whole</strong>.</li>
</ul>
</div></section><section class="slide num numD" data-pos="7-3-7">
<span class="pos">7-3-7</span>
<div class="slidecontent">
<p>Of course, still true to the...</p>
<blockquote>
<p>Angular is built with Angular</p>
</blockquote>
<p>...adage, the <strong>API that these directives were implemented with</strong> is <strong>available to you</strong>.</p>
<p>Which means we can build <strong>custom validation</strong>!</p>
</div></section><section class="slide" data-pos="7-3-8">
<span class="pos">7-3-8</span>
<div class="slidecontent"><p>Custom validators are simply <strong>directives</strong> that <strong>implement this <code>validate</code> method</strong>:</p>
<pre><code>validate(ctrl: FormControl){
  // <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">if</span> valid, <span class="hljs-keyword">otherwise</span> { [category]: {valid: <span class="hljs-literal">false</span>} }
}
</code></pre></div></section><section class="slide" data-pos="7-3-9">
<span class="pos">7-3-9</span>
<div class="slidecontent"><p>To <strong>make Angular understand that the directive is a validator</strong>, we must dance this dance:</p>
<pre><code>@Directive({
  selector: '[<span class="hljs-string">myattribname</span>][<span class="hljs-symbol">ngModel</span>]',
  providers: [{
<span class="hljs-code">    provide: NG_VALIDATORS,</span>
<span class="hljs-code">    useExisting: forwardRef(() =&gt; MyClassName),</span>
<span class="hljs-code">    multi: true</span>
  }]
})
class MyClassName { ... }
</code></pre><p>This is <strong>likely to change</strong>, perhaps by introducing a new <code>@Validator</code> decorator.</p>
</div></section><section class="slide" data-pos="7-3-10">
<span class="pos">7-3-10</span>
<div class="slidecontent"><p>You can <strong>see an example of this</strong> in the <a href="resources/supportsite/demos/validation" target="_blank">Custom validation</a> demo.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>7-4.</span> Reactive forms</h3>
      <p>let the model do the driving</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="7-4-1">
<span class="pos">7-4-1</span>
<div class="slidecontent"><p>See:</p>
<ul>
<li><a href="resources/supportsite/demos/form_reactive" target="_blank">Reactive form</a> demo</li>
<li><a href="resources/supportsite/demos/validation_reactive" target="_blank">Reactive validation</a> demo</li>
</ul>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>7-5.</span> Template referencing</h3>
      <p>strings attached</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="7-5-1">
<span class="pos">7-5-1</span>
<div class="slidecontent"><p>Consider a <strong>simple app</strong> where we have</p>
<ul>
<li>the <strong>latest submitted name</strong></li>
<li>an <strong>input field</strong> where you can type a new name</li>
<li>a <strong>button which submits</strong> the input content</li>
</ul>
<p><img src="resources/images/submission.png" alt=""></p>
</div></section><section class="slide" data-pos="7-5-2">
<span class="pos">7-5-2</span>
<div class="slidecontent"><p>This is a (slightly) <strong>more difficult problem</strong> than just doing a two-way data binding. Back then the <strong>change listener and value belong to the same element</strong>.</p>
<p><img src="resources/diagrams/moredifficult.svg" alt=""></p>
<p>But now they are on <strong>different elements</strong>!</p>
</div></section><section class="slide" data-pos="7-5-3">
<span class="pos">7-5-3</span>
<div class="slidecontent"><p>We solve it in the <a href="resources/supportsite/demos/submitname_binding" target="_blank">Submit binding</a> demo by <strong>tracking the field content</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"fieldValue"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"submitName()"</span>&gt;</span>Submit!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Latest submission: {{submission}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</code></pre>
<p>...and <strong>use that for submission</strong> on clicks:</p>
<pre><code class="lang-typescript">submitName() {
  <span class="hljs-keyword">this</span>.submission = <span class="hljs-keyword">this</span>.fieldValue;
}
</code></pre>
</div></section><section class="slide" data-pos="7-5-4">
<span class="pos">7-5-4</span>
<div class="slidecontent"><p>You could however argue that this is somewhat <strong>unclean</strong>, as <strong><code>fieldValue</code> isn&#39;t really part of our model</strong>.</p>
<p>Still, we <strong>must have access to the field contents</strong>. Is there perhaps a way to <strong>reference</strong> the field to query its value?</p>
</div></section><section class="slide" data-pos="7-5-5">
<span class="pos">7-5-5</span>
<div class="slidecontent"><p>Indeed there is, and they&#39;re called <strong>refs</strong>! Add it like this:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref-field</span>&gt;</span>
</code></pre>
<p>...and we can <strong>use that reference in siblings or children</strong> in the template:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"submitName(field.value)"</span>&gt;</span>click!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="7-5-6">
<span class="pos">7-5-6</span>
<div class="slidecontent"><p>Much like with <code>bind-</code> and <code>on-</code>, there is a <strong>shorthand for the <code>ref-</code> prefix</strong>...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref-field</span>&gt;</span>
</code></pre>
<p>...that uses the <strong><code>#</code> character instead</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> #<span class="hljs-attr">field</span>&gt;</span>
</code></pre>
<p><strong>Try this out</strong> in the <a href="resources/supportsite/demos/submitname_ref" target="_blank">Submit Reference</a> demo.</p>
</div></section><section class="slide" data-pos="7-5-7">
<span class="pos">7-5-7</span>
<div class="slidecontent"><p>We can also <strong>reach refences from the model</strong> by using the <strong><code>@ViewChild</code></strong> decorator:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> AppComponent {
  fetchedValue: <span class="hljs-built_in">string</span>
  <span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'field'</span>) input: ElementRef
  submitName() {
    <span class="hljs-keyword">this</span>.fetchedValue = <span class="hljs-keyword">this</span>.input.nativeElement.value;
  }
}
</code></pre>
<p>Now we <strong>don&#39;t have to pass the reference from the template</strong>, which feels a bit cleaner. <strong>Try this out</strong> in the <a href="resources/supportsite/demos/submitname_viewchild" target="_blank">Submit ViewChild</a> demo.</p>
</div></section><section class="slide" data-pos="7-5-8">
<span class="pos">7-5-8</span>
<div class="slidecontent"><p>We should also note that <strong><code>@ViewChild</code> can find node by other means than references</strong>, the API is very flexible.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>7-6.</span> Gamebook - extras</h3>
      <p>i want more</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="7-6-1">
<span class="pos">7-6-1</span>
<div class="slidecontent"><p>As per usual;</p>
<ol>
<li><strong>copy the folder of the previous version</strong>,</li>
<li><strong>paste it</strong> right next to that version, and</li>
<li>give it the name <strong><code>FF07-moremoremore</code></strong>.</li>
</ol>
</div></section><section class="slide" data-pos="7-6-2">
<span class="pos">7-6-2</span>
<div class="slidecontent"><p>The smart thing would be to <strong>leave well enough alone</strong>, but that wouldn&#39;t be any fun.</p>
<p>Instead, let&#39;s find an excuse to <strong>cram a form into our app</strong> somewhere! How about allowing the player to <strong>name his character</strong> and have the <strong>name be used in the adventure</strong>?</p>
</div></section><section class="slide" data-pos="7-6-3">
<span class="pos">7-6-3</span>
<div class="slidecontent"><p>It could look <strong>something like this</strong>:</p>
<p><img src="resources/images/nameform.png" alt=""></p>
</div></section><section class="slide" data-pos="7-6-4">
<span class="pos">7-6-4</span>
<div class="slidecontent"><p>Ideally we would want to <strong>display the form when the game starts</strong>, but that would require a bunch of other changes.</p>
<p>So let&#39;s go with simply <strong>always showing the form up top</strong>, as in the previous screenshot.</p>
</div></section><section class="slide list" data-pos="7-6-5">
<span class="pos">7-6-5</span>
<div class="slidecontent">
<p>Here&#39;s the plan:</p>
<ul>
<li><span>a</span><strong>add <code>name</code> to <code>gameState</code></strong></li>
<li><span>b</span>create a <strong><code>NameForm</code> component</strong></li>
<li><span>c</span><strong>hook up <code>NameForm</code></strong> to <code>AppComponent</code></li>
<li><span>d</span>make <strong><code>SceneComponent</code> receive <code>gameState</code></strong></li>
<li><span>e</span>put <strong>name placeholders in adventure data</strong></li>
<li><span>f</span>make a <strong>playername pipe</strong></li>
<li><span>g</span>have <strong><code>SceneComponent</code> use the pipe</strong></li>
<li><span>h</span><strong>wire everything up</strong></li>
</ul>
</div></section><section class="slide num numA" data-pos="7-6-6">
<span class="pos">7-6-6</span>
<div class="slidecontent">
<p>First we must <strong>change <code>gameState</code></strong> to also <strong>contain the name</strong>. This means...</p>
<ul>
<li>make the <strong>default state contain a name</strong> in the <code>StateHandler</code> load method</li>
<li>update the <strong>TypeScript interface</strong> if you&#39;re using those</li>
</ul>
</div></section><section class="slide num numB" data-pos="7-6-7">
<span class="pos">7-6-7</span>
<div class="slidecontent">
<p>Now for the tough part - creating a <strong><code>NameForm</code> component</strong>!</p>
<p><img src="resources/diagrams/formcomp.svg" alt=""></p>
<p>It will</p>
<ul>
<li>receive the <strong>current name as input</strong></li>
<li><strong>output the new name</strong> on form submission</li>
</ul>
</div></section><section class="slide" data-pos="7-6-8">
<span class="pos">7-6-8</span>
<div class="slidecontent"><p>In other words, the <strong><code>NameForm</code> class</strong> should look something like this:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> NameForm {
  <span class="hljs-meta">@Input</span>() currentName: <span class="hljs-built_in">string</span>
  <span class="hljs-meta">@Output</span>() newName = <span class="hljs-keyword">new</span> EventEmitter&lt;<span class="hljs-built_in">string</span>&gt;()
  onSubmit(plrname: <span class="hljs-built_in">string</span>){
    <span class="hljs-keyword">this</span>.newName.emit(plrname)
  }
}
</code></pre>
</div></section><section class="slide" data-pos="7-6-9">
<span class="pos">7-6-9</span>
<div class="slidecontent"><p>The <strong><code>NameForm</code> template</strong> is of course the complicated part, but you can <strong>steal pretty much everything</strong> from the <a href="resources/supportsite/demos/form" target="_blank">Form</a> demo!</p>
<p>As in the demo you should have <strong>some simple validation</strong>, like a minimum (and maybe maximum) character count.</p>
</div></section><section class="slide num numC" data-pos="7-6-10">
<span class="pos">7-6-10</span>
<div class="slidecontent">
<p>Now let&#39;s <strong>use <code>NameForm</code> in <code>AppComponent</code></strong>! This means...</p>
<ul>
<li><strong>adding <code>NameForm</code> to the template</strong></li>
<li><strong>passing in the current name</strong></li>
<li>creating a <strong><code>newName</code> method that updates <code>gameState</code></strong> (and remember to save!)</li>
<li><strong>hook up <code>newName</code> to <code>NameForm</code> output</strong></li>
</ul>
</div></section><section class="slide num numD" data-pos="7-6-11">
<span class="pos">7-6-11</span>
<div class="slidecontent">
<p>Since the <strong><code>SceneComponent</code> will need the player name</strong>, we might as well <strong>pass it all of <code>gameState</code></strong>.</p>
<p>Normally we&#39;d be <strong>wary to share too much</strong>, but it stands to reason that <strong>future state</strong> such as inventory, health, etc, would <strong>also be shown in the scene view</strong>.</p>
</div></section><section class="slide num numE" data-pos="7-6-12">
<span class="pos">7-6-12</span>
<div class="slidecontent">
<p>Time to <strong>update the adventure data</strong> to use the name! Add a <code>PLAYERNAME</code> placeholder to relevant positions in the texts.</p>
</div></section><section class="slide num numF" data-pos="7-6-13">
<span class="pos">7-6-13</span>
<div class="slidecontent">
<p>Now we need to <strong>create a pipe to exchange the placeholder</strong>!</p>
<p>If you haven&#39;t already, look at the <strong>Pipe section</strong> in the <strong>Appendix Various chapter</strong>, and also the <strong><a href="resources/supportsite/demos/pipe" target="_blank">Pipe</a> demo</strong>.</p>
</div></section><section class="slide" data-pos="7-6-14">
<span class="pos">7-6-14</span>
<div class="slidecontent"><p>Our pipe should take a block of text and <strong>replace <code>PLAYERNAME</code> with the current name</strong>.</p>
<p>How do we get hold of playername? Why, by using the <strong>StateHandler service</strong> of course!</p>
</div></section><section class="slide" data-pos="7-6-15">
<span class="pos">7-6-15</span>
<div class="slidecontent"><p>Note that to force our pipe to be applied whenever something changes, we <strong>must set it to be impure</strong> (see the last part of the Pipe section).</p>
</div></section><section class="slide num numG" data-pos="7-6-16">
<span class="pos">7-6-16</span>
<div class="slidecontent">
<p>With that done we must <strong>use the pipe in the <code>SceneComponent</code> template</strong> where we display the scene text:</p>
<pre><code>{{currentScene.desc | plrname}}
</code></pre></div></section><section class="slide num numH" data-pos="7-6-17">
<span class="pos">7-6-17</span>
<div class="slidecontent">
<p>Finally we must wire things up by <strong>updating our <code>NgModule</code></strong> to <strong>expose the <code>NameForm</code> and the new pipe</strong>.</p>
</div></section><section class="slide" data-pos="7-6-18">
<span class="pos">7-6-18</span>
<div class="slidecontent"><p>That was a long treck, but now you should have a <strong>fully functioning personalised adventure</strong>, increasing the immersion a thousand times! :)</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 8 / 13</span>
    <h2>Postludium</h2>
    <p>♫♪ Tiiime tooo saay goodbyyyye ♩♪</p>
</p>
  </div>
  
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. What's next?</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>8-1.</span> What's next?</h3>
      <p>Where to go from here</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="8-1-1">
<span class="pos">8-1-1</span>
<div class="slidecontent"><p>So, now that you&#39;re about to be <strong>thrown out into the cold</strong>, let&#39;s talk about <strong>where to go from here</strong> for continued Angular support!</p>
</div></section><section class="slide" data-pos="8-1-2">
<span class="pos">8-1-2</span>
<div class="slidecontent"><p>We&#39;ve already bounced around in the <strong><a href="https://angular.io/docs/ts/latest/">official docs</a></strong>.</p>
<p>They <strong>aren&#39;t complete</strong> and sometimes they <strong>lag behind</strong>, but they should still be your number one resource.</p>
</div></section><section class="slide" data-pos="8-1-3">
<span class="pos">8-1-3</span>
<div class="slidecontent"><p>We&#39;d like to <strong>highlight some different sections</strong>:</p>
<ul>
<li>The <strong><a href="https://angular.io/docs/ts/latest/api/">API reference</a></strong> is probably the most important part</li>
<li>The <strong><a href="https://angular.io/docs/ts/latest/guide/">guides</a> and <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html">advanced</a> sections</strong> together make up what amounts to an <strong>explanatory book</strong>.</li>
<li>Also, don&#39;t miss the official <strong><a href="https://angular.io/cheatsheet">cheat sheet</a></strong> which you should (regularly) print and have lying next to you as you code!</li>
</ul>
</div></section><section class="slide" data-pos="8-1-4">
<span class="pos">8-1-4</span>
<div class="slidecontent"><p>For <strong>third party blogs</strong>, we&#39;d like to <strong>mention two sites</strong>:</p>
<ul>
<li>The <a href="http://blog.thoughtram.io/">Thoughtram Blog</a></li>
<li>The <a href="http://blog.angular-university.io/">Angular University</a></li>
</ul>
</div></section><section class="slide" data-pos="8-1-5">
<span class="pos">8-1-5</span>
<div class="slidecontent"><p>Regarding <strong>books</strong> you&#39;d think there wouldn&#39;t be any ready yet, but there is one! And it is actually <strong>up to date</strong> (for a little while longer...)!</p>
<p>We&#39;re talking about <a href="https://www.manning.com/">Manning Publication</a>&#39;s book <strong><a href="https://www.manning.com/books/angular-2-development-with-typescript">Angular 2 development with TypeScript</a></strong>.</p>
</div></section><section class="slide" data-pos="8-1-6">
<span class="pos">8-1-6</span>
<div class="slidecontent"><p>Despite obviously being <strong>written in parallel with Angular development</strong>, it is actually <strong>pretty good</strong>.</p>
<p>At the time of writing it is still in <strong>early access</strong>, meaning you can <strong>only buy pdf</strong>. But <strong>all content is finished</strong>, and the expected release is in november.</p>
</div></section><section class="slide" data-pos="8-1-7">
<span class="pos">8-1-7</span>
<div class="slidecontent"><p>Beyond that, of course, there&#39;s <strong>no quick fix</strong> for learning the framework.</p>
<p>Except for <strong>taking an Angular class</strong>, but you just did that. :)</p>
<p>So what remains is to <strong>try it out</strong> and get lots of <strong>hands-on experience</strong>.</p>
</div></section><section class="slide" data-pos="8-1-8">
<span class="pos">8-1-8</span>
<div class="slidecontent"><p>And in that endeavour we <strong>wish you the best of luck</strong>!</p>
<p><strong>Thank you</strong> for participating, see you down the road! :)</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 9 / 13</span>
    <h2>Appendix: Web stuff</h2>
    <p>Laying out the tools</p>
</p>
  </div>
  <section class="slide">

<div class="slidecontent"><p>This appendix chapter gathers a <strong>bunch of different good-to-knows</strong> regarding the web in general and JavaScript in particular, that might benefit you while working with Angular.</p>
</div></section>
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. The JavaScript language</li>
<li>2. The web as a platform</li>
<li>3. Node and NPM</li>
<li>4. CSS Selectors</li>
<li>5. Object references</li>
<li>6. Attributes vs Properties</li>
<li>7. Functional programming</li>
<li>8. Statements vs Expressions</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>9-1.</span> The JavaScript language</h3>
      <p>lingua franca of the web</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="9-1-1">
<span class="pos">9-1-1</span>
<div class="slidecontent"><p>So - <strong>JavaScript</strong>! Let&#39;s kick things off with a <strong>chopper view of the language</strong>.</p>
</div></section><section class="slide" data-pos="9-1-2">
<span class="pos">9-1-2</span>
<div class="slidecontent"><p>First, here is an overview of the <strong>different JavaScript versions</strong>:</p>
<p><img src="resources/diagrams/js-versions.svg" alt="versions"></p>
<p>We will be using <strong>the very latest features</strong>, which we will <strong>walk through later</strong>.</p>
</div></section><section class="slide" data-pos="9-1-3">
<span class="pos">9-1-3</span>
<div class="slidecontent"><p>...as well as some <strong>more stuff beyond the borders of JavaScript</strong>, but <strong>that comes later too</strong>!</p>
</div></section><section class="slide list" data-pos="9-1-4">
<span class="pos">9-1-4</span>
<div class="slidecontent">
<p>Since we <strong>can&#39;t trust all browsers to know the latest JS</strong>, we must <strong>convert our code</strong>. We do this either by...</p>
<ul>
<li><span>a</span><strong>polyfilling</strong></li>
<li><span>b</span><strong>transpiling</strong></li>
</ul>
</div></section><section class="slide num numA" data-pos="9-1-5">
<span class="pos">9-1-5</span>
<div class="slidecontent">
<p><strong>Polyfilling</strong> means <strong>adding a homebrew version</strong> of a method if a native one isn&#39;t available. This <strong>can be done programmatically</strong>, like this:</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">Array</span>.isArray = <span class="hljs-built_in">Array</span>.isArray || <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span> + a !== a &amp;&amp; {}.toString.call(a) == <span class="hljs-string">'[object Array]'</span>;
});
</code></pre>
</div></section><section class="slide num numB" data-pos="9-1-6">
<span class="pos">9-1-6</span>
<div class="slidecontent">
<p>But <strong>syntax changes</strong> requires a <strong>transpilation step</strong> that must be done <strong>prior to running the code</strong>. We <strong>cannot do this programmatically</strong>.</p>
</div></section><section class="slide" data-pos="9-1-7">
<span class="pos">9-1-7</span>
<div class="slidecontent"><p>Speaking of JavaScript&#39;s character - are you familiar with the <strong>3 levels of programming</strong>?</p>
<p><img src="resources/diagrams/programmerlevels.svg" alt=""></p>
</div></section><section class="slide question" data-pos="9-1-8">
<span class="pos">9-1-8</span>
<div class="slidecontent">
<p>They were interesting, but <strong>what do they have to do with JavaScript</strong>?</p>
</div></section><section class="slide answer" data-pos="9-1-9">
<span class="pos">9-1-9</span>
<div class="slidecontent">
<p>JavaScript&#39;s flexible nature <strong>encourages and empowers level 2 behaviour</strong>.</p>
<p>So <strong>take care</strong>, and remember:</p>
<blockquote>
<p>With great power comes great responsibility</p>
</blockquote>
</div></section><section class="slide" data-pos="9-1-10">
<span class="pos">9-1-10</span>
<div class="slidecontent"><p>Wielding of that power requires you to <strong>have a grasp JS&#39;s quirks</strong>, of which there are many. </p>
<p>These ones are <strong>especially important</strong>:</p>
<ul>
<li><strong>Loose typing</strong> and <strong>truthiness</strong></li>
<li>The <strong>implicit <code>this</code> parameter</strong></li>
<li><strong>Lexical scoping</strong></li>
<li><strong>closures</strong></li>
</ul>
</div></section><section class="slide" data-pos="9-1-11">
<span class="pos">9-1-11</span>
<div class="slidecontent"><p>A very <strong>good resources for these quirks</strong> is <a href="http://bonsaiden.github.io/JavaScript-Garden/">JavaScript Garden</a>.</p>
<p>For more <strong>general JS references</strong> we recommend <a href="https://developer.mozilla.org/en-US/">MDN</a> (and <strong>not W3Schools</strong>).</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>9-2.</span> The web as a platform</h3>
      <p>this or this or this or</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="9-2-1">
<span class="pos">9-2-1</span>
<div class="slidecontent"><p>Zooming out from JS, we also need to realise a few things regarding <strong>the web as a platform</strong>.</p>
<p>By that we mean building applications with <strong>JavaScript, HTML and CSS</strong>.</p>
</div></section><section class="slide" data-pos="9-2-2">
<span class="pos">9-2-2</span>
<div class="slidecontent"><p>Something that is often <strong>overwhelming to newcomers</strong> is that there is an <strong>abundance of choices</strong> to make, for many different aspects;</p>
<ul>
<li>what <strong>framework</strong> to use</li>
<li>what <strong>build chain</strong> to use</li>
<li>which <strong>JS language flavour</strong> to use</li>
<li>what <strong>CSS preprocessor</strong> to use</li>
<li>what <strong>style rules</strong> to enforce</li>
<li><strong>how to enforce</strong> those rules</li>
</ul>
<p>...and many more.</p>
</div></section><section class="slide" data-pos="9-2-3">
<span class="pos">9-2-3</span>
<div class="slidecontent"><p>And for <strong>each of those choices</strong>, you must consider;</p>
<p><img src="resources/diagrams/choiceaspects-1.svg" alt=""></p>
</div></section><section class="slide" data-pos="9-2-4">
<span class="pos">9-2-4</span>
<div class="slidecontent"><p>...and <strong>also</strong>:</p>
<p><img src="resources/diagrams/choiceaspects-2.svg" alt=""></p>
<p>...and likely a few more that we&#39;ve forgotten.</p>
</div></section><section class="slide" data-pos="9-2-5">
<span class="pos">9-2-5</span>
<div class="slidecontent"><p>Regarding the <strong>choice of framework</strong>, the <strong>most important aspect</strong> is perhaps that of <strong>complexity</strong>:</p>
<p><img src="resources/diagrams/frameworkcomplexity.svg" alt=""></p>
</div></section><section class="slide" data-pos="9-2-6">
<span class="pos">9-2-6</span>
<div class="slidecontent"><p>The one we&#39;ve chosen here, Angular, is of <strong>medium- to heavy weight</strong>.</p>
<p>Which means that it <strong>offers us all we need</strong>, but still <strong>leaves some room to make choices</strong>!</p>
</div></section><section class="slide" data-pos="9-2-7">
<span class="pos">9-2-7</span>
<div class="slidecontent"><p>Observe that there is <strong>no right or wrong</strong> in the complexity choice.</p>
<p>The important thing is to <strong>be aware of where on the scale you are</strong>, and <strong>understand the consequences of that</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>9-3.</span> Node and NPM</h3>
      <p>workbench and pantry</p>
</p>
    </div>
  </section>
  <section class="slide list" data-pos="9-3-1">
<span class="pos">9-3-1</span>
<div class="slidecontent">
<p>In the course we&#39;ll rely heavily on</p>
<ul>
<li><span>a</span>the <strong>JavaScript runtime Node</strong> and </li>
<li><span>b</span>the <strong>package manager npm</strong></li>
</ul>
<p>...so let&#39;s touch briefly on both!</p>
</div></section><section class="slide num numA" data-pos="9-3-2">
<span class="pos">9-3-2</span>
<div class="slidecontent">
<p><a href="https://nodejs.org/en/">Node</a> is mostly associated with <strong>running JavaScript on the server</strong>, but in actuality it is a <strong>JavaScript runtime that can be run anywhere</strong>. Some <strong>differences versus the in-browser runtime</strong> is that</p>
<ul>
<li>Node has <strong>no DOM</strong></li>
<li>Node can <strong>read and write files</strong></li>
<li>Node has <strong>its own module system</strong></li>
</ul>
</div></section><section class="slide" data-pos="9-3-3">
<span class="pos">9-3-3</span>
<div class="slidecontent"><p>There are <strong>two ways to execute JS</strong> with Node. We can enter the <strong>REPL</strong> by typing <code>node</code> in a node terminal...</p>
<p><img src="resources/images/noderepl.png" alt=""></p>
</div></section><section class="slide" data-pos="9-3-4">
<span class="pos">9-3-4</span>
<div class="slidecontent"><p>...or we can <strong>execute JavaScript files</strong> by typing <code>node myfile.js</code> which executes the JS code in <code>myfile.js</code>.</p>
<p>This of course is the <strong>most common usage</strong> of Node.</p>
<p>JS developers frequently use Node to <strong>run code as part of their build chain</strong>.</p>
</div></section><section class="slide num numB" data-pos="9-3-5">
<span class="pos">9-3-5</span>
<div class="slidecontent">
<p>However, Node is also used for <strong>running <code>npm</code></strong>, through which we can <strong>download packages from the online repository</strong> at <a href="https://www.npmjs.com/">https://www.npmjs.com/</a>.</p>
</div></section><section class="slide" data-pos="9-3-6">
<span class="pos">9-3-6</span>
<div class="slidecontent"><p>Allegedly npm is an <strong>acronym for Node Package Manager</strong>, but <strong>npm themselves deny that</strong> through <strong>consistently using lower-case characters</strong>, and through the <strong>top-left corner of their homepage</strong>: </p>
<p><img src="resources/images/npmmeaning.png" alt=""></p>
</div></section><section class="slide" data-pos="9-3-7">
<span class="pos">9-3-7</span>
<div class="slidecontent"><p>We download packages by</p>
<ul>
<li><strong>turning our own code into a package</strong> through adding a <strong><code>package.json</code> file</strong></li>
<li><strong>listing the packages we depend on</strong> in that file</li>
<li>typing <code>npm install</code> to <strong>download all listed dependencies</strong> to <code>node_modules</code></li>
<li><strong>using those modules</strong> in our code!</li>
</ul>
</div></section><section class="slide" data-pos="9-3-8">
<span class="pos">9-3-8</span>
<div class="slidecontent"><p>By having <strong><code>package.json</code> as part of the project</strong>, but <strong>excluding <code>node_modules</code></strong>, we get a <strong>small code repository</strong> which can still be <strong>easily inflated with dependencies</strong>.</p>
<p>And we can still be sure that <strong>everyone has the same dependcies</strong>.</p>
<p>(...at least if we&#39;re careful...)</p>
</div></section><section class="slide" data-pos="9-3-9">
<span class="pos">9-3-9</span>
<div class="slidecontent"><p>A <strong>downloaded published module</strong> will normally <strong>look like this</strong>:</p>
<p><img src="resources/diagrams/modulecontent.svg" alt=""></p>
<p>The <code>package.json</code> file will specify <strong>where in the source the entry point is</strong>.</p>
</div></section><section class="slide" data-pos="9-3-10">
<span class="pos">9-3-10</span>
<div class="slidecontent"><p>So! <strong>Node&#39;s module system</strong> that we mentioned earlier lets us</p>
<ul>
<li><strong>import stuff from other files</strong> by using <code>require</code></li>
<li><strong>export stuff from files</strong> by assigning to <code>module.exports</code></li>
</ul>
</div></section><section class="slide" data-pos="9-3-11">
<span class="pos">9-3-11</span>
<div class="slidecontent"><p>But <strong>now for the beautiful part</strong> - we can <strong>also require packages</strong> from <code>node_modules</code>!</p>
<p>Thus Node and npm together solve both the <strong>code modularisation problem</strong> along with <strong>3rd party code import problem</strong>.</p>
</div></section><section class="slide" data-pos="9-3-12">
<span class="pos">9-3-12</span>
<div class="slidecontent"><p>Here&#39;s the <strong>full truth</strong> about <strong>how we require stuff</strong>:</p>
<p><img src="resources/diagrams/loadmodule.svg" alt=""></p>
</div></section><section class="slide" data-pos="9-3-13">
<span class="pos">9-3-13</span>
<div class="slidecontent"><p>The important part is to realise that there is <strong>no magic involved</strong>, and that Node provides us with a <strong>convenient way to load</strong>...</p>
<ul>
<li><strong>core modules</strong> (like <code>fs</code>, <code>http</code>, etc)</li>
<li><strong>3rd party code</strong> (like <code>angular</code>)</li>
<li><strong>own local modules</strong> (like <code>./src/mycomponent</code>)</li>
</ul>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>9-4.</span> CSS Selectors</h3>
      <p>You know of them, but do you know them?</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="9-4-1">
<span class="pos">9-4-1</span>
<div class="slidecontent"><p>When we say <strong>CSS</strong>, we are actually talking about <strong>two different syntaxes</strong>:</p>
<pre><code class="lang-css"><span class="hljs-selector-tag">div</span> &gt; <span class="hljs-selector-tag">h1</span><span class="hljs-selector-pseudo">:first-child</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#CCC</span>;
  <span class="hljs-attribute">font-style</span>: italic;
}
</code></pre>
<ul>
<li>The line preceeding the brackets is a <strong>selector</strong></li>
<li>The stuff inside the brackets are <strong>style rules</strong> which will be applied to all nodes matching the selector</li>
</ul>
</div></section><section class="slide" data-pos="9-4-2">
<span class="pos">9-4-2</span>
<div class="slidecontent"><p>They are used for two <strong>very different things</strong>:</p>
<ul>
<li><strong>Selectors</strong> allow you to <strong>reference a set of DOM nodes</strong></li>
<li>With <strong>style rules</strong> you <strong>describe what the nodes look like</strong></li>
</ul>
</div></section><section class="slide" data-pos="9-4-3">
<span class="pos">9-4-3</span>
<div class="slidecontent"><p>The <strong>DOM has its own API</strong> for selecting nodes, but it is <strong>really limited and verbose</strong>.</p>
<p>Therefore <strong>jQuery imported CSS selectors to JS</strong>:</p>
<pre><code class="lang-javascript">jQuery(<span class="hljs-string">'div &gt; h1:first-child'</span>).doSomethingWithTheseNodes();
</code></pre>
</div></section><section class="slide" data-pos="9-4-4">
<span class="pos">9-4-4</span>
<div class="slidecontent"><p>This turned out to be a <strong>really good idea</strong>, and the biggest reason behind why <strong>jQuery is now used by half of the internet</strong>.</p>
</div></section><section class="slide" data-pos="9-4-5">
<span class="pos">9-4-5</span>
<div class="slidecontent"><p>Because this was such a good idea, it has now been made into a <strong>native DOM method</strong>:</p>
<pre><code><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelectorAll</span>(<span class="hljs-string">'h1:first-child'</span>).doSomething();
</code></pre><p>There is also a <strong><code>document.querySelector</code></strong> variant that <strong>always returns just 1 node</strong> (or none).</p>
</div></section><section class="slide" data-pos="9-4-6">
<span class="pos">9-4-6</span>
<div class="slidecontent"><p>And, as we will soon see, <strong>CSS selectors are also used in Angular</strong>!</p>
<p>All this make for a very good reason to <strong>brush up on your CSS selector knowledge</strong>, so let&#39;s do that now!</p>
</div></section><section class="slide" data-pos="9-4-7">
<span class="pos">9-4-7</span>
<div class="slidecontent"><p>CSS selectors are <strong>made up by two parts</strong>:</p>
<p><img src="resources/diagrams/css-selector-dissection.svg" alt=""></p>
</div></section><section class="slide" data-pos="9-4-8">
<span class="pos">9-4-8</span>
<div class="slidecontent"><p>Starting with <strong>element descriptions</strong>, they describe elements in <strong>one or more of five different ways</strong>:</p>
<p><img src="resources/diagrams/css-description.svg" alt=""></p>
</div></section><section class="slide" data-pos="9-4-9">
<span class="pos">9-4-9</span>
<div class="slidecontent"><p>These <strong>can be combined</strong> however you see fit. Here is an (exaggerated) example using all of them:</p>
<pre><code><span class="hljs-selector-tag">button</span>[disabled]<span class="hljs-selector-id">#deletemsg</span><span class="hljs-selector-class">.big</span>:first-child
</code></pre><p>This would match all </p>
<ul>
<li>nodes of <strong>type</strong> buttons</li>
<li>that has a disabled <strong>attribute</strong></li>
<li>and <strong>id</strong> is <code>deletemsg</code></li>
<li>and <strong>class</strong> attribute contains &#39;big&#39;</li>
<li>and it is the <strong>first child</strong> of its parent</li>
</ul>
</div></section><section class="slide" data-pos="9-4-10">
<span class="pos">9-4-10</span>
<div class="slidecontent"><p>Now for the <strong>combinators</strong>! There are <strong>4 different different ways</strong> that descriptions can be combined.</p>
<p><img src="resources/diagrams/css-combinators.svg" alt=""></p>
</div></section><section class="slide list" data-pos="9-4-11">
<span class="pos">9-4-11</span>
<div class="slidecontent">
<p>We&#39;ll now <strong>look closer</strong> at one at a time!</p>
<ul>
<li><span>a</span><strong>descendant</strong> combinator</li>
<li><span>b</span><strong>child</strong> combinator</li>
<li><span>c</span><strong>sibling</strong> combinator</li>
<li><span>d</span><strong>adjacent sibling</strong> combinator</li>
</ul>
</div></section><section class="slide num numA" data-pos="9-4-12">
<span class="pos">9-4-12</span>
<div class="slidecontent">
<p>The perhaps most common one is the <strong>descendant combinator</strong>. By having <strong>two descriptions with a space between</strong>...</p>
<pre><code><span class="hljs-selector-tag">div</span> p
</code></pre></div></section><section class="slide" data-pos="9-4-13">
<span class="pos">9-4-13</span>
<div class="slidecontent"><pre><code><span class="hljs-selector-tag">div</span> p
</code></pre><p>...we match all elements that</p>
<ul>
<li><strong>match the last description</strong></li>
<li>have an <strong>ancestor matching the first description</strong>. This can be <strong>any number of generations</strong> up the tree.</li>
</ul>
</div></section><section class="slide" data-pos="9-4-14">
<span class="pos">9-4-14</span>
<div class="slidecontent"><p>It is <strong>unfortunate that the descendant combinators doesn&#39;t have a non-space symbol</strong>, something like this:</p>
<pre><code><span class="hljs-selector-tag">div</span> _ p
</code></pre><p>Whitespace elsewhere in CSS doesn&#39;t have meaning, but here it suddenly does. To help with this, <strong>think of descendant combinators as invisible symbols</strong>!</p>
</div></section><section class="slide num numB" data-pos="9-4-15">
<span class="pos">9-4-15</span>
<div class="slidecontent">
<pre><code><span class="hljs-selector-tag">div</span> &gt; p
</code></pre><p>The <strong>child combinator</strong> is very similar to descendant selector, but here the first selector must match the <strong>parent</strong> and not just any ancestor.</p>
</div></section><section class="slide" data-pos="9-4-16">
<span class="pos">9-4-16</span>
<div class="slidecontent"><p>Thus the child combinator is <strong>smaller in scope</strong> than the descendant combinator.</p>
</div></section><section class="slide num numC" data-pos="9-4-17">
<span class="pos">9-4-17</span>
<div class="slidecontent">
<pre><code><span class="hljs-selector-tag">div</span> ~ p
</code></pre><p>The <strong>sibling combinator</strong> is similar to the descendant combinator, but <strong>works horisontally</strong> instead.</p>
</div></section><section class="slide" data-pos="9-4-18">
<span class="pos">9-4-18</span>
<div class="slidecontent"><pre><code><span class="hljs-selector-tag">div</span> ~ p
</code></pre><p>This means it matches elements that...</p>
<ul>
<li><strong>match the last description</strong></li>
<li>have an <strong>older sibling that matches the first description</strong></li>
</ul>
</div></section><section class="slide num numD" data-pos="9-4-19">
<span class="pos">9-4-19</span>
<div class="slidecontent">
<pre><code><span class="hljs-selector-tag">div</span> + p
</code></pre><p>Finally the <strong>adjacent sibling combinator</strong> works in the exact same way, but requires the <strong>neighbouring older sibling to match the first description</strong>.</p>
</div></section><section class="slide" data-pos="9-4-20">
<span class="pos">9-4-20</span>
<div class="slidecontent"><p>The two <strong>sibling combinators are not often used</strong>, but they are <strong>good at what they do</strong>.</p>
<p>Solving that problem with other means would require <strong>brittle workarounds</strong>, something you often see from web developers who don&#39;t know about them.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>9-5.</span> Object references</h3>
      <p>Any strings attached?</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="9-5-1">
<span class="pos">9-5-1</span>
<div class="slidecontent"><p>In JavaScript, <strong>objects (and therefore also arrays) are references</strong>.</p>
<p>This means that...</p>
<ul>
<li>passing around references <strong>is dangerous</strong></li>
<li>you must be <strong>careful with mutation</strong></li>
<li>know if APIs <strong>copy or mutate</strong></li>
</ul>
</div></section><section class="slide" data-pos="9-5-2">
<span class="pos">9-5-2</span>
<div class="slidecontent"><p>As a <strong>cautionary tale</strong>, have a look at this app:</p>
<p><img src="resources/images/jsonexample-screen.png" alt=""></p>
<p>Clicking a team <strong>gives it a point</strong>, and the headline shows the <strong>current leader</strong>.</p>
</div></section><section class="slide" data-pos="9-5-3">
<span class="pos">9-5-3</span>
<div class="slidecontent"><p>However, in an early version, a <strong>bug</strong> caused the <strong>buttons to change order when the leader changed</strong>.</p>
<p>This was <strong>not the intened behaviour</strong>.</p>
</div></section><section class="slide question" data-pos="9-5-4">
<span class="pos">9-5-4</span>
<div class="slidecontent">
<p>Can you <strong>spot the cause of the bug</strong>?</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> PokemonGoComponent {
  votes = {mystic:<span class="hljs-number">0</span>, instinct: <span class="hljs-number">0</span>, valor: <span class="hljs-number">0</span>}
  list = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.votes).sort()
  <span class="hljs-keyword">get</span> best() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.sort(
      <span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> <span class="hljs-keyword">this</span>.votes[a] &lt; <span class="hljs-keyword">this</span>.votes[b] ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>
    )[<span class="hljs-number">0</span>] <span class="hljs-comment">// best is 1st element in sorted list</span>
  }
  vote(team) {
    <span class="hljs-keyword">this</span>.votes[team]++
  }
}
</code></pre>
</div></section><section class="slide answer" data-pos="9-5-5">
<span class="pos">9-5-5</span>
<div class="slidecontent">
<p>The <strong>offence</strong> is in the <strong><code>best</code> getter</strong>:</p>
<pre><code><span class="hljs-keyword">get</span> best() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.sort(
    (a,b)=&gt; <span class="hljs-keyword">this</span>.votes[a] &lt; <span class="hljs-keyword">this</span>.votes[b] ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>
  )[<span class="hljs-number">0</span>] <span class="hljs-comment">// best is 1st element in sorted list</span>
}
</code></pre><p>The <strong><code>.sort</code> method mutates</strong> <code>this.list</code>, which means that the <strong>buttons would change order</strong>!</p>
</div></section><section class="slide" data-pos="9-5-6">
<span class="pos">9-5-6</span>
<div class="slidecontent"><p>The <strong>problem was fixed</strong> by first <strong>copying the array</strong> using the <strong>non-mutating <code>slice</code> method</strong>:</p>
<pre><code><span class="hljs-keyword">get</span> best() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.slice().sort(
    (a,b)=&gt; <span class="hljs-keyword">this</span>.votes[a] &lt; <span class="hljs-keyword">this</span>.votes[b] ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>
  )[<span class="hljs-number">0</span>] <span class="hljs-comment">// best is 1st element in sorted list</span>
}
</code></pre></div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>9-6.</span> Attributes vs Properties</h3>
      <p>You say potato</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="9-6-1">
<span class="pos">9-6-1</span>
<div class="slidecontent"><p>HTML elements have <strong>attributes</strong> but DOM nodes have <strong>properties</strong>.</p>
<p>Usually, but not always, the <strong>former initializes the latter</strong>:</p>
<p><img src="resources/diagrams/htmlvsdom.svg" alt=""></p>
</div></section><section class="slide" data-pos="9-6-2">
<span class="pos">9-6-2</span>
<div class="slidecontent"><p>We will now <strong>showcase the difference</strong> using this simple page:</p>
<p><img src="resources/images/inputfield.png" alt=""></p>
<p>It is published at <a href="http://blog.krawaller.se/attrvsprops/">http://blog.krawaller.se/attrvsprops</a>.</p>
</div></section><section class="slide" data-pos="9-6-3">
<span class="pos">9-6-3</span>
<div class="slidecontent"><p>If you <strong><code>view source</code></strong> you&#39;ll see this:</p>
<pre><code><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"John Doe"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre><p>Note that the <strong><code>input</code></strong> has the <strong>initial value <code>&quot;John Doe&quot;</code></strong>.</p>
</div></section><section class="slide" data-pos="9-6-4">
<span class="pos">9-6-4</span>
<div class="slidecontent"><p>In the console we can <strong>get a reference to the input field node</strong> like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> field = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"input"</span>);
</code></pre>
</div></section><section class="slide" data-pos="9-6-5">
<span class="pos">9-6-5</span>
<div class="slidecontent"><p>Using that reference we can <strong>confirm the value of the <code>value</code> attribute</strong>:</p>
<pre><code class="lang-javascript">field.getAttribute(<span class="hljs-string">"value"</span>) <span class="hljs-comment">// "John Doe";</span>
</code></pre>
</div></section><section class="slide" data-pos="9-6-6">
<span class="pos">9-6-6</span>
<div class="slidecontent"><p>And we can also <strong>read the <code>value</code> property</strong>:</p>
<pre><code class="lang-javascript">field.value <span class="hljs-comment">// "John Doe";</span>
</code></pre>
</div></section><section class="slide" data-pos="9-6-7">
<span class="pos">9-6-7</span>
<div class="slidecontent"><p>Now <strong>type in the field</strong> to say something else:</p>
<p><img src="resources/images/inputfield2.png" alt=""></p>
</div></section><section class="slide" data-pos="9-6-8">
<span class="pos">9-6-8</span>
<div class="slidecontent"><p>If we <strong>query the attribute again</strong>, we see that it is still <code>John Doe</code>:</p>
<pre><code class="lang-javascript">field.getAttribute(<span class="hljs-string">"value"</span>) <span class="hljs-comment">// "John Doe";</span>
</code></pre>
</div></section><section class="slide" data-pos="9-6-9">
<span class="pos">9-6-9</span>
<div class="slidecontent"><p>But the <strong>property is updated</strong>:</p>
<pre><code class="lang-javascript">field.value <span class="hljs-comment">// "My real name";</span>
</code></pre>
</div></section><section class="slide" data-pos="9-6-10">
<span class="pos">9-6-10</span>
<div class="slidecontent"><p>This reflects the fact that <strong>attributes are characteristics of the original HTML elements</strong>, while <strong>properties belong to the live DOM nodes</strong>.</p>
</div></section><section class="slide" data-pos="9-6-11">
<span class="pos">9-6-11</span>
<div class="slidecontent"><p>To wit:</p>
<ul>
<li><strong>HTML elements have attributes</strong>, and <strong>DOM nodes have properties</strong>.</li>
<li><strong>Attributes often initialize properties</strong> (but not always)</li>
<li><strong>Attributes never change</strong>, but <strong>properties can change</strong>.</li>
</ul>
</div></section><section class="slide question" data-pos="9-6-12">
<span class="pos">9-6-12</span>
<div class="slidecontent">
<p>Ok, this is all very interesting, but <strong>what does this have to do with Angular</strong>?</p>
</div></section><section class="slide answer" data-pos="9-6-13">
<span class="pos">9-6-13</span>
<div class="slidecontent">
<p>Nothing directly, except it is <strong>even easier to mix things up in Angular</strong> because of its use of templates.</p>
</div></section><section class="slide" data-pos="9-6-14">
<span class="pos">9-6-14</span>
<div class="slidecontent"><p>Take this <strong>Angular template bit</strong>:</p>
<pre><code>&lt;<span class="hljs-selector-tag">button</span> [disabled]=<span class="hljs-string">"someFlag"</span>&gt;
</code></pre><ul>
<li>Here <code>disabled</code> is given the value of <code>someFlag</code>.</li>
<li>Whenever <code>someFlag</code> changes, so will <code>disabled</code>.</li>
</ul>
</div></section><section class="slide" data-pos="9-6-15">
<span class="pos">9-6-15</span>
<div class="slidecontent"><p>In essence: when writing Angular templates it <strong>looks like we&#39;re dealing with attributes</strong>.</p>
<p>But we are <strong>actually dealing with properties</strong> (with some exceptions).</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>9-7.</span> Functional programming</h3>
      <p>Jumping down the rabbit hole</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="9-7-1">
<span class="pos">9-7-1</span>
<div class="slidecontent"><p>JavaScript is a <strong>functional language</strong>, which Angular makes good use of.</p>
<p>We&#39;ll now <strong>walk through a quick example</strong> to make sure we <strong>understand the power of this paradigm</strong>!</p>
</div></section><section class="slide" data-pos="9-7-2">
<span class="pos">9-7-2</span>
<div class="slidecontent"><p>So - since <strong>functions are first class citizens</strong>, we can <strong>send them around just like any value</strong>.</p>
<p>Which also means that <strong>a function can take, and/or return, other functions</strong>! Such a function is called a <strong>higher order function</strong>.</p>
</div></section><section class="slide" data-pos="9-7-3">
<span class="pos">9-7-3</span>
<div class="slidecontent"><p>As a contrived <strong>example</strong>, say we have this function:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> spam = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"SPAM!"</span>);
}
</code></pre>
</div></section><section class="slide" data-pos="9-7-4">
<span class="pos">9-7-4</span>
<div class="slidecontent"><p>And then we have this <strong>higher order function</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeater</span>(<span class="hljs-params">func,times</span>)</span>{
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; times; i = i + <span class="hljs-number">1</span>){
    func();
  }
}
</code></pre>
</div></section><section class="slide" data-pos="9-7-5">
<span class="pos">9-7-5</span>
<div class="slidecontent"><p>If we <strong>invoke <code>repeater</code></strong> like this:</p>
<pre><code class="lang-javascript">repeater(spam,<span class="hljs-number">3</span>);
</code></pre>
<p>We would <strong>see this in the console</strong>:</p>
<pre><code><span class="hljs-string">"SPAM!"</span>
<span class="hljs-string">"SPAM!"</span>
<span class="hljs-string">"SPAM!"</span>
</code></pre></div></section><section class="slide" data-pos="9-7-6">
<span class="pos">9-7-6</span>
<div class="slidecontent"><p>To show we can also <strong>return new functions</strong>, take a look at this beauty:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiplier</span>(<span class="hljs-params">func,times</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; times; i = i + <span class="hljs-number">1</span>){
      func();
    }
  };
}
</code></pre>
</div></section><section class="slide" data-pos="9-7-7">
<span class="pos">9-7-7</span>
<div class="slidecontent"><p>Did you see the difference? <code>multiplier</code> doesn&#39;t execute the parameter function, but <strong>returns a new function</strong>!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> tripleSpam = multiplier(spam,<span class="hljs-number">3</span>);
</code></pre>
<p>If we <strong>execute the returned function</strong> we get the triple spam:</p>
<pre><code class="lang-javascript">tripleSpam(); <span class="hljs-comment">// SPAM! SPAM! SPAM!</span>
</code></pre>
</div></section><section class="slide" data-pos="9-7-8">
<span class="pos">9-7-8</span>
<div class="slidecontent"><p>Functional programming is a <strong>really powerful tool</strong>, and something that is likely to <strong>get you hooked once you have learned it</strong>. We warmly encourage you to explore the subject!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>9-8.</span> Statements vs Expressions</h3>
      <p>I say tomato</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="9-8-1">
<span class="pos">9-8-1</span>
<div class="slidecontent"><p>The code we write is made up by <strong>statements</strong> and <strong>expressions</strong>. So what is the difference?</p>
<p><img src="resources/diagrams/stmntvsexpr.svg" alt=""></p>
</div></section><section class="slide" data-pos="9-8-2">
<span class="pos">9-8-2</span>
<div class="slidecontent"><p>For example, consider this line of code:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cost = quantity * price;
</code></pre>
<ul>
<li>The line <strong>is a statement</strong>, declaring a variable and assigning a value</li>
<li>It <strong>contains an expression</strong> <code>quantity * price</code>, and whatever that evaluates to will be assigned to <code>cost</code>.</li>
<li>Does the whole expression have a value? Yes, but it happens to be <code>undefined</code>. So, not really.</li>
</ul>
</div></section><section class="slide" data-pos="9-8-3">
<span class="pos">9-8-3</span>
<div class="slidecontent"><p>The fact that <strong>assignment forms part of a valid expression</strong> in JavaScript is why this code isn&#39;t a syntax error:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">if</span> (count = <span class="hljs-number">12</span>) {
  output(<span class="hljs-string">"That's right, a dozen means 12!"</span>);
}
</code></pre>
</div></section><section class="slide" data-pos="9-8-4">
<span class="pos">9-8-4</span>
<div class="slidecontent"><p>Then there are things in JS which <strong>aren&#39;t expressions but could be</strong>. This is a syntax error:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> suffix = <span class="hljs-keyword">switch</span> (quoty % <span class="hljs-number">10</span>) {
  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-string">'st'</span>
  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-string">'nd'</span>
  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-string">'rd'</span>
  <span class="hljs-keyword">default</span>: <span class="hljs-string">'th'</span>
}
</code></pre>
</div></section><section class="slide" data-pos="9-8-5">
<span class="pos">9-8-5</span>
<div class="slidecontent"><p>Instead we have to do this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> suffix;

<span class="hljs-keyword">switch</span> (quoty % <span class="hljs-number">10</span>) {
  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: suffix = <span class="hljs-string">'st'</span>; <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: suffix = <span class="hljs-string">'nd'</span>; <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: suffix = <span class="hljs-string">'rd'</span>; <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>: suffix = <span class="hljs-string">'th'</span>; <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>Granted, it is probably because JS has fall-through that switches aren&#39;t expressions (which is considered a flaw too).</p>
</div></section><section class="slide" data-pos="9-8-6">
<span class="pos">9-8-6</span>
<div class="slidecontent"><p>Perhaps weirdly, <strong>any expression is a valid statement</strong>. (It&#39;s an &quot;expression statement&quot;.) Consider this line:</p>
<pre><code class="lang-javascript"><span class="hljs-number">2</span>+<span class="hljs-number">3</span>;
</code></pre>
<p>It will be evaluated to 5, but nothing uses that value and there are no side effects. On the Chrome Console you can see the 5.</p>
<p>A famous example of clever usage of this is the strict mode opt-in &quot;magical string&quot;:</p>
<pre><code class="lang-javascript"><span class="hljs-meta">"use strict"</span>;
</code></pre>
</div></section><section class="slide" data-pos="9-8-7">
<span class="pos">9-8-7</span>
<div class="slidecontent"><p>Sometimes JavaScript even taunts us with the statement/expression distinction. There&#39;s both a <strong>function statement</strong> and a <strong>function expression</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">luke</span>(<span class="hljs-params"></span>) </span>{           <span class="hljs-comment">// function statement</span>
}

<span class="hljs-keyword">var</span> leia = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ };  <span class="hljs-comment">// function expression</span>
</code></pre>
<p>Function statements <em>require</em> the function name, which gets installed in the current scope. Function expressions do no such thing.</p>
</div></section><section class="slide" data-pos="9-8-8">
<span class="pos">9-8-8</span>
<div class="slidecontent"><p>Have you thought about the fact that <code>{ }</code> gets used for two completely different things in JavaScript?</p>
<pre><code class="lang-javascript">{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"This is a block!"</span>);
}

<span class="hljs-keyword">var</span> however = {
    <span class="hljs-attr">here</span>: <span class="hljs-string">"these braces denote"</span>,
    <span class="hljs-attr">an</span>: <span class="hljs-string">"object literal!"</span>
};
</code></pre>
<p>How does JavaScript know when it&#39;s supposed to be one or the other? Well, that&#39;s also a statement/expression distinction. See the recurring theme here?</p>
</div></section><section class="slide question" data-pos="9-8-9">
<span class="pos">9-8-9</span>
<div class="slidecontent">
<p>Ok, got it, there are <strong>many nuances</strong> to the difference between statements and expressions.</p>
<p>But isn&#39;t this just <strong>theoretical academics</strong> with <strong>no practical value</strong>?</p>
</div></section><section class="slide answer" data-pos="9-8-10">
<span class="pos">9-8-10</span>
<div class="slidecontent">
<p>No! <strong>Don&#39;t dismiss this</strong>!</p>
<p><strong>Understanding the difference</strong> will give you a <strong>better understanding</strong> of, and <strong>perspective</strong> on, your code!</p>
<p>Also, as we will see soon enough, the <strong>distinction comes into play in Angular</strong>.</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 10 / 13</span>
    <h2>Appendix: ES2015</h2>
    <p>The new shinies</p>
</p>
  </div>
  <section class="slide">

<div class="slidecontent"><p>In this appendix chapter we will more fully <strong>explore the new features in ES2015</strong>!</p>
</div></section>
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. Versatile object definitions</li>
<li>2. Destructuring and rest</li>
<li>3. Versatile function definitions</li>
<li>4. Spreads</li>
<li>5. Modules</li>
<li>6. Classes</li>
<li>7. Decorators</li>
<li>8. Miscellaneous</li>
<li>9. Trying it out</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>10-1.</span> Versatile object definitions</h3>
      <p>defining objects like a boss</p>
</p>
    </div>
  </section>
  <section class="slide list" data-pos="10-1-1">
<span class="pos">10-1-1</span>
<div class="slidecontent">
<p>In ES2015 we got five small but nice features for <strong>defining objects in a smoother way</strong>:</p>
<ul>
<li><span>a</span>dynamic keys</li>
<li><span>b</span>automatic same-key-value</li>
<li><span>c</span>method shorthand</li>
<li><span>d</span>getters</li>
<li><span>e</span>setters</li>
</ul>
</div></section><section class="slide num numA" data-pos="10-1-2">
<span class="pos">10-1-2</span>
<div class="slidecontent">
<p>If we wanted to create an <strong>object with a dynamic key</strong> we had to go about it in a roundabout way before:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> obj = {};
<span class="hljs-keyword">var</span> obj[dynamicKey] = someValue;
</code></pre>
</div></section><section class="slide" data-pos="10-1-3">
<span class="pos">10-1-3</span>
<div class="slidecontent"><p>Now, instead, we can use the <strong>dynamic key syntax</strong> by wrapping it in brackets:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> obj = {[dynamicKey]: someValue};
</code></pre>
</div></section><section class="slide num numB" data-pos="10-1-4">
<span class="pos">10-1-4</span>
<div class="slidecontent">
<p>Also, if our value is in a <strong>variable with the same name as the intended key</strong>, like here:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> person = {
  <span class="hljs-attr">name</span>: name,
  <span class="hljs-attr">age</span>: age
};
</code></pre>
</div></section><section class="slide" data-pos="10-1-5">
<span class="pos">10-1-5</span>
<div class="slidecontent"><p>...ES2015 introduces a <strong>shorthand syntax</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> person = {name, age};
</code></pre>
</div></section><section class="slide num numC" data-pos="10-1-6">
<span class="pos">10-1-6</span>
<div class="slidecontent">
<p>And if we define an <strong>object with a method</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">method</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1,arg2</span>)</span>{
    <span class="hljs-comment">// do advanced stuff</span>
  }
};
</code></pre>
</div></section><section class="slide" data-pos="10-1-7">
<span class="pos">10-1-7</span>
<div class="slidecontent"><p>...ES2015 lets us be less verbose by using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions">method shorthand syntax</a>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> obj = {
  method(arg1,arg2){
    <span class="hljs-comment">// do advanced stuff</span>
  }
};
</code></pre>
</div></section><section class="slide" data-pos="10-1-8">
<span class="pos">10-1-8</span>
<div class="slidecontent"><p>This can also be <strong>combined with the dynamic key syntax</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> obj = {
  [methodName](arg1,arg2){
    <span class="hljs-comment">// do advanced stuff</span>
  }
};
</code></pre>
</div></section><section class="slide num numD" data-pos="10-1-9">
<span class="pos">10-1-9</span>
<div class="slidecontent">
<p>Finally, ES2015 also introduced <strong>getters and setters</strong>.</p>
<p>Let&#39;s look at <strong>getters</strong> first. They are very useful for dealing with <strong>computed properties</strong>.</p>
</div></section><section class="slide" data-pos="10-1-10">
<span class="pos">10-1-10</span>
<div class="slidecontent"><p>Say we&#39;re working with <strong>user objects</strong> like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">"John"</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>
};
</code></pre>
<p>Now we want to implement a <strong>computed property <code>fullName</code></strong>.</p>
</div></section><section class="slide" data-pos="10-1-11">
<span class="pos">10-1-11</span>
<div class="slidecontent"><p>Here&#39;s an <strong>ES3 solution</strong> doing it as a <strong>method</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">"John"</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>,
  <span class="hljs-attr">fullName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName;
  }
}

user.fullName(); <span class="hljs-comment">// John Doe</span>
</code></pre>
</div></section><section class="slide" data-pos="10-1-12">
<span class="pos">10-1-12</span>
<div class="slidecontent"><p>By using an <strong>ES2015 getter</strong> we can access the computed property normally instead:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">"John"</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>,
  get fullName() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName;
  }
}

user.fullName; <span class="hljs-comment">// John Doe, without invocation!</span>
</code></pre>
<p>Cf. <a href="https://en.wikipedia.org/wiki/Uniform_access_principle">uniform access principle</a>.</p>
</div></section><section class="slide" data-pos="10-1-13">
<span class="pos">10-1-13</span>
<div class="slidecontent"><p>You can <strong>see all three syntaxes</strong> in an Angular context in the <a href="resources/supportsite/demos/methodvsgetter" target="_blank">Getter</a> demo!</p>
</div></section><section class="slide num numE" data-pos="10-1-14">
<span class="pos">10-1-14</span>
<div class="slidecontent">
<p>A <strong>setter</strong> let&#39;s you <strong>act upon prop mutation</strong>, for example <strong>logging</strong>...</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> user = {
  set userName(str) {
    log(<span class="hljs-keyword">this</span>._userName + <span class="hljs-string">" changed name to "</span> + str);
    <span class="hljs-keyword">this</span>._userName = str;
  }
}

user.userName = <span class="hljs-string">"Steve"</span>; <span class="hljs-comment">// Bob changed name to Steve</span>
</code></pre>
</div></section><section class="slide" data-pos="10-1-15">
<span class="pos">10-1-15</span>
<div class="slidecontent"><p>...or <strong>validation</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> user = {
  set userName(str) {
    <span class="hljs-keyword">if</span> (str.match(<span class="hljs-regexp">/[^a-z]/</span>)){
      <span class="hljs-keyword">throw</span> <span class="hljs-string">"Name can only contain lowercase letters!"</span>;
    }
    <span class="hljs-keyword">this</span>._userName = str;
  }
}

user.userName = <span class="hljs-string">"Bob the 1 and only"</span>; <span class="hljs-comment">// Name can only contain..</span>
</code></pre>
</div></section><section class="slide question" data-pos="10-1-16">
<span class="pos">10-1-16</span>
<div class="slidecontent">
<p>Did you note that we used a <strong>different property name</strong> inside the setter? The setter was for <code>userName</code>, but inside it we instead set <code>_userName</code>.</p>
<p>Why do you think that is?</p>
</div></section><section class="slide answer" data-pos="10-1-17">
<span class="pos">10-1-17</span>
<div class="slidecontent">
<p>If we mutated the same property inside the setter then that would trigger the setter to be called, which would mutate the property, which would trigger the setter, etc. We would end up in an <strong>infinite loop</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>10-2.</span> Destructuring and rest</h3>
      <p>cherry-picking the raisins from the cookie</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="10-2-1">
<span class="pos">10-2-1</span>
<div class="slidecontent"><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring</a> is a way to pick values from nested structures without having to do the manual digging.</p>
</div></section><section class="slide" data-pos="10-2-2">
<span class="pos">10-2-2</span>
<div class="slidecontent"><p>Let&#39;s say we have an <strong>array of <code>contenders</code></strong>, each represented by an object.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> contenders = [
  {<span class="hljs-attr">name</span>: <span class="hljs-string">"David"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">37</span>},
  {<span class="hljs-attr">name</span>: <span class="hljs-string">"Carl"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">38</span>}
  <span class="hljs-comment">/* and a few others */</span>
];
</code></pre>
<p>They are <strong>sorted by position</strong> so the first contender won, etc.</p>
</div></section><section class="slide" data-pos="10-2-3">
<span class="pos">10-2-3</span>
<div class="slidecontent"><p>If we wanted the <strong>name of the winner</strong> we would do something like this in ES5:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> winnersName = contenders[<span class="hljs-number">0</span>].name;
</code></pre>
</div></section><section class="slide" data-pos="10-2-4">
<span class="pos">10-2-4</span>
<div class="slidecontent"><p>With <strong>destructuring</strong>, we can instead do this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> [{<span class="hljs-attr">name</span>: winnersName}] = contenders;
</code></pre>
<p>Or, combined with the <strong>same-key-value shorthand</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> [{name}] = contenders;
</code></pre>
</div></section><section class="slide" data-pos="10-2-5">
<span class="pos">10-2-5</span>
<div class="slidecontent"><p>Destructuring also allows us to use the powerful <strong>rest</strong> element which can <strong>lump up many array elements into one</strong>, making for some very succinct code:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> [winner, ...losers] = contenders;
</code></pre>
</div></section><section class="slide" data-pos="10-2-6">
<span class="pos">10-2-6</span>
<div class="slidecontent"><p>Note that the rest element <strong>has to be the last one in the array</strong>, so this wouldn&#39;t work:</p>
<pre><code><span class="hljs-keyword">let</span> [...others, superloser] = contenders; <span class="hljs-comment">// syntax error</span>
</code></pre></div></section><section class="slide question" data-pos="10-2-7">
<span class="pos">10-2-7</span>
<div class="slidecontent">
<p>Wait.. Theoretically, <strong>the rest could be placed <em>anywhere</em></strong>, as long as there&#39;s just one. The parser should still be able to figure out what&#39;s what!</p>
<p>Right?</p>
</div></section><section class="slide answer" data-pos="10-2-8">
<span class="pos">10-2-8</span>
<div class="slidecontent">
<p>True. But that would <strong>require lookahead</strong>, which is <strong>complex and more taxing</strong>. And so the choice was made to only allow the rest element in the last position.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>10-3.</span> Versatile function definitions</h3>
      <p>defining function like a boss</p>
</p>
    </div>
  </section>
  <section class="slide list" data-pos="10-3-1">
<span class="pos">10-3-1</span>
<div class="slidecontent">
<p>ES2015 provides <strong>several neat features for defining functions</strong>:</p>
<ul>
<li><span>a</span>default parameter values</li>
<li><span>b</span>rest parameters</li>
<li><span>c</span>destructuring parameters</li>
<li><span>d</span>arrow functions</li>
</ul>
</div></section><section class="slide num numA" data-pos="10-3-2">
<span class="pos">10-3-2</span>
<div class="slidecontent">
<p><strong>Default parameter values</strong> exist in many languages, and was popularised in JS through <a href="">CoffeeScript</a>.</p>
<p>The idea is to <strong>handle optional parameters</strong> in a smoother way.</p>
</div></section><section class="slide" data-pos="10-3-3">
<span class="pos">10-3-3</span>
<div class="slidecontent"><p>Creating a <strong>function with an optional parameter</strong> in ES3 meant we had to do a sometimes tedious dance of initialization:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePerson</span>(<span class="hljs-params">name, age</span>) </span>{
  <span class="hljs-keyword">var</span> age = age || <span class="hljs-string">'unknown'</span>;
  <span class="hljs-comment">// do complex stuff</span>
}
</code></pre>
<p>This may or may not do what you want. (Hint: is <code>0</code> a reasonable value for <code>age</code>?)</p>
</div></section><section class="slide" data-pos="10-3-4">
<span class="pos">10-3-4</span>
<div class="slidecontent"><p>With <strong>default parameter values</strong> we can instead do this: </p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePerson</span>(<span class="hljs-params">name, age = <span class="hljs-string">'unknown'</span></span>) </span>{
  <span class="hljs-comment">// do complex stuff</span>
}
</code></pre>
</div></section><section class="slide num numB" data-pos="10-3-5">
<span class="pos">10-3-5</span>
<div class="slidecontent">
<p>The second new feature, <strong>rest parameters</strong>, is a way of capturing multiple arguments into a single variable like a rest element in a destructuring.</p>
<p>This can often save us from having to do awkward stuff with the not-quite-an-array <code>arguments</code> object.</p>
</div></section><section class="slide" data-pos="10-3-6">
<span class="pos">10-3-6</span>
<div class="slidecontent"><p>Imagine a <code>competition</code> function that is called with all contenders one by one:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">competition</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> contenders = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
  <span class="hljs-keyword">var</span> winner = contenders[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> losers = contenders.slice(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// do something with winner and losers</span>
}
</code></pre>
</div></section><section class="slide" data-pos="10-3-7">
<span class="pos">10-3-7</span>
<div class="slidecontent"><p>Using rest parameters, this function simply becomes:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">competition</span>(<span class="hljs-params">winner, ...losers</span>) </span>{
  <span class="hljs-comment">// do something with winner and losers</span>
}
</code></pre>
</div></section><section class="slide" data-pos="10-3-8">
<span class="pos">10-3-8</span>
<div class="slidecontent"><p>Note that the rest parameter <strong>has to be the last parameter</strong>, just like the rest element, and for the same reason.</p>
</div></section><section class="slide num numC" data-pos="10-3-9">
<span class="pos">10-3-9</span>
<div class="slidecontent">
<p>Remember <strong>destructuring</strong>? We can <strong>use that in signatures</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">introduce</span>(<span class="hljs-params">{name, age}</span>) </span>{
  <span class="hljs-built_in">console</span>.log(name,<span class="hljs-string">"is"</span>,age,<span class="hljs-string">"years old"</span>);
}
<span class="hljs-keyword">var</span> me = {<span class="hljs-attr">name</span>: <span class="hljs-string">"David"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">37</span>};
introduce(me); <span class="hljs-comment">// David is 37 years old</span>
</code></pre>
</div></section><section class="slide num numD" data-pos="10-3-10">
<span class="pos">10-3-10</span>
<div class="slidecontent">
<p>Finally - know how <strong>defining anonymous functions</strong> in JS is rather verbose?</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> mcboatify = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Boaty Mc"</span>+arg+<span class="hljs-string">"Face"</span>;
};
</code></pre>
</div></section><section class="slide" data-pos="10-3-11">
<span class="pos">10-3-11</span>
<div class="slidecontent"><p>With <strong>arrow functions</strong> things feel less heavy:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> mcboatify = <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Boaty Mc"</span> + arg + <span class="hljs-string">"Face"</span>;
};
</code></pre>
</div></section><section class="slide" data-pos="10-3-12">
<span class="pos">10-3-12</span>
<div class="slidecontent"><p>They can become smaller still - if we have <strong>exactly one parameter</strong>, we can <strong>omit the parenthesis</strong> in the signature:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> mcboatify = <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Boaty Mc"</span> + arg + <span class="hljs-string">"Face"</span>;
};
</code></pre>
</div></section><section class="slide" data-pos="10-3-13">
<span class="pos">10-3-13</span>
<div class="slidecontent"><p>Finally, if you <strong>just want to return an expression</strong>, we can <strong>skip brackets and the return keyword</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> mcboatify = <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> <span class="hljs-string">"Boaty Mc"</span> + arg + <span class="hljs-string">"Face"</span>;
</code></pre>
<p>Now the function body consists of a single expression, which will be implicitly returned.</p>
</div></section><section class="slide" data-pos="10-3-14">
<span class="pos">10-3-14</span>
<div class="slidecontent"><p>Note however that if you want to use the <strong>single expression form with an object literal</strong>, we have to <strong>wrap it in parenthesis</strong> to distinguish it from a regular function block:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> createUser = <span class="hljs-function">(<span class="hljs-params">name,age</span>)=&gt;</span> ({name,age})
</code></pre>
</div></section><section class="slide" data-pos="10-3-15">
<span class="pos">10-3-15</span>
<div class="slidecontent"><p>Arrow functions are not only less heavy to write, they are also lighter for the interpreter since they <strong>don&#39;t get an implicit context parameter</strong>.</p>
</div></section><section class="slide" data-pos="10-3-16">
<span class="pos">10-3-16</span>
<div class="slidecontent"><p>Which means that if you refer to <code>this</code> inside an arrow function, it is the <strong>same <code>this</code> as on the outside</strong>.</p>
<pre><code><span class="hljs-keyword">var</span> me = <span class="hljs-keyword">this</span>;
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> === me); <span class="hljs-comment">// true</span>
}, <span class="hljs-number">10</span>)
setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> === me); <span class="hljs-comment">// false</span>
}, <span class="hljs-number">10</span>)
</code></pre></div></section><section class="slide" data-pos="10-3-17">
<span class="pos">10-3-17</span>
<div class="slidecontent"><p>As a final note; arrow functions can beautifully describe the flow for <strong>nested higher order callbacks</strong>. Remember the <strong><code>multiplier</code> example</strong> from the functional programming section?</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiplier</span>(<span class="hljs-params">func,times</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; times; i = i + <span class="hljs-number">1</span>){
      func();
    }
  };
}
</code></pre>
</div></section><section class="slide" data-pos="10-3-18">
<span class="pos">10-3-18</span>
<div class="slidecontent"><p>With arrow functions, that becomes:</p>
<pre><code><span class="hljs-keyword">var</span> multiplier = (<span class="hljs-function"><span class="hljs-keyword">func</span>,<span class="hljs-title">times</span>)=&gt; <span class="hljs-params">()</span></span>=&gt; {
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; times; i = i + <span class="hljs-number">1</span>){
    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>;
  }
}
</code></pre></div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>10-4.</span> Spreads</h3>
      <p>the dark side of rests</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="10-4-1">
<span class="pos">10-4-1</span>
<div class="slidecontent"><p>You have already seen how we use <strong>rest</strong> element/parameter to capture several array elements into a single variable:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> [winner, ...losers] = competitors;
</code></pre>
</div></section><section class="slide" data-pos="10-4-2">
<span class="pos">10-4-2</span>
<div class="slidecontent"><p>Now imagine <strong>the opposite scenario</strong> - we have the <code>winner</code> and <code>losers</code> variables, and want to define <code>competitors</code>. In ES3 this is done like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> competitors = [winner].concat(losers);
</code></pre>
</div></section><section class="slide" data-pos="10-4-3">
<span class="pos">10-4-3</span>
<div class="slidecontent"><p>ES2015 gives us a new options - <strong>spreads</strong>! It looks exactly like rest, but we use it on the <em>right side</em> instead (or when we <em>call</em> a function as opposed to when we define it):</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> competitors = [winner, ...losers];
</code></pre>
<p>We say that we <em>spread</em> the contents of the expression into the outer array.</p>
</div></section><section class="slide" data-pos="10-4-4">
<span class="pos">10-4-4</span>
<div class="slidecontent"><p>Spreads gives us a less verbose way to <strong>copy an object and add properties to it</strong>, which is otherwise done like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> augmentedObj = <span class="hljs-built_in">Object</span>.assign({}, oldObj, newProps);
</code></pre>
</div></section><section class="slide" data-pos="10-4-5">
<span class="pos">10-4-5</span>
<div class="slidecontent"><p>With spreads we can instead do this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> augmentedObj = {...oldObj, ...newProps};
</code></pre>
</div></section><section class="slide" data-pos="10-4-6">
<span class="pos">10-4-6</span>
<div class="slidecontent"><p>Note that while spreads and rests <em>with arrays</em> are in the spec for ES2015, <strong>object spread is still a Stage 3 proposal</strong> (November 2017).</p>
<p>It is <strong>expected to be accepted into an upcoming release</strong> of the language, and is already supported by Babel and the like.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>10-5.</span> Modules</h3>
      <p>getting into the import/export business</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="10-5-1">
<span class="pos">10-5-1</span>
<div class="slidecontent"><p>As we saw earlier, <strong>Node gave us modules</strong> through the <code>require</code> and <code>module.exports</code> globals it provides.</p>
<p>But with ES2015, we got <strong>native modules</strong> for the very first time!</p>
</div></section><section class="slide" data-pos="10-5-2">
<span class="pos">10-5-2</span>
<div class="slidecontent"><p>While <strong>Node modules</strong> followed the <strong>CommonJS module standard</strong>, what was implemented in the language follows <strong>another syntax</strong>, named <strong>ES modules</strong>.</p>
<p>But the <strong>concepts are the same</strong>. While you would do this in <strong>CommonJS</strong>...</p>
<pre><code>// file1.js
module.exports = <span class="hljs-meta">{..}</span>;

//file2.js
<span class="hljs-keyword">var</span> lib = require(<span class="hljs-string">"./file1.js"</span>);
</code></pre></div></section><section class="slide" data-pos="10-5-3">
<span class="pos">10-5-3</span>
<div class="slidecontent"><p>...you would do this with <strong>ES modules</strong>:</p>
<pre><code>// file1.js
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> lib = <span class="hljs-meta">{..}</span>;

//file2.js
<span class="hljs-keyword">import</span> lib <span class="hljs-keyword">from</span> './file1.js'
</code></pre><p>We have to <strong>name our exports</strong> here, otherwise things are <strong>pretty similar</strong>.</p>
</div></section><section class="slide" data-pos="10-5-4">
<span class="pos">10-5-4</span>
<div class="slidecontent"><p>There are <strong>other differences too</strong>, so for the full scope you should <strong>check the MDN docs</strong> for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">import</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export">export</a></p>
</div></section><section class="slide" data-pos="10-5-5">
<span class="pos">10-5-5</span>
<div class="slidecontent"><p>Note that even though this is now <strong>part of the language</strong>, there are <strong>no browsers that implement the functionality yet</strong>.</p>
<p>This is mainly because it <strong>wouldn&#39;t be practical</strong> - we&#39;d get a <strong>gazillion http requests for small files</strong>.</p>
</div></section><section class="slide" data-pos="10-5-6">
<span class="pos">10-5-6</span>
<div class="slidecontent"><p>And since we <strong>likely have a build step anyway</strong> to do minification and transpiling and similar, you can easily <strong>bundle your code into a single file</strong>, too.</p>
<p>But, with the advent of HTTP2, <strong>who knows what the future will hold</strong>!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>10-6.</span> Classes</h3>
      <p>Waiter, there are classes in my JS!</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="10-6-1">
<span class="pos">10-6-1</span>
<div class="slidecontent"><p>Before ES2015, JavaScript used to famously <strong>lack classes</strong>.</p>
<p>This was <strong>not an oversight</strong>. Consider what <strong>classes are normally used for</strong>:</p>
<ul>
<li><strong>resusing functionality</strong> and </li>
<li>setting up <strong>hierarchies</strong></li>
</ul>
</div></section><section class="slide" data-pos="10-6-2">
<span class="pos">10-6-2</span>
<div class="slidecontent"><p>In <strong>JavaScript</strong> this is addressed by</p>
<ul>
<li>simply <strong>grabbing methods</strong> and/or <strong>mixing objects</strong></li>
<li><strong>prototypal &quot;inheritance&quot;</strong>, which should really be called delegation</li>
</ul>
</div></section><section class="slide" data-pos="10-6-3">
<span class="pos">10-6-3</span>
<div class="slidecontent"><p>This means that <strong>classes didn&#39;t really serve a purpose</strong>. Yet they were <strong>still frequently used</strong>, through the weird, bolted-on <strong><code>new</code></strong> syntax which <strong>makes functions behave like constructors</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"David"</span>, <span class="hljs-number">1979</span>);
</code></pre>
</div></section><section class="slide" data-pos="10-6-4">
<span class="pos">10-6-4</span>
<div class="slidecontent"><p>But to really make this <strong>behave like normal classes</strong>...</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> lucas = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">"Lucas"</span>);
lucas instanceOf Dog; <span class="hljs-comment">// true</span>
lucas instanceOf Animal; <span class="hljs-comment">// true</span>
lucas.bark(); <span class="hljs-comment">// Lucas goes woof!</span>
</code></pre>
</div></section><section class="slide" data-pos="10-6-5">
<span class="pos">10-6-5</span>
<div class="slidecontent"><p>...then lots of <strong>jumping through hoops</strong> had to be done:</p>
<pre><code class="lang-javascript">Dog.prototype = <span class="hljs-keyword">new</span> Animal();
Dog.prototype.constructor = Animal;
Dog.prototype.bark = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name, <span class="hljs-string">"goes woof!"</span>);
}
</code></pre>
</div></section><section class="slide" data-pos="10-6-6">
<span class="pos">10-6-6</span>
<div class="slidecontent"><p>To <strong>facilitate &quot;class&quot; use</strong> in JavaScript, <strong>ES2015 introduced the <code>class</code></strong> syntax:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  bark() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name, <span class="hljs-string">"goes woof!"</span>);
  }
}
</code></pre>
<p>Note how <strong>method shorthands</strong> are available in class declarations too!</p>
</div></section><section class="slide" data-pos="10-6-7">
<span class="pos">10-6-7</span>
<div class="slidecontent"><p>But it is important to note that this does <strong>not mean that JavaScript has actual classes</strong>.</p>
<p>Under the hood the same weird <code>prototype</code> and <code>constructor</code> dance happens.</p>
</div></section><section class="slide list" data-pos="10-6-8">
<span class="pos">10-6-8</span>
<div class="slidecontent">
<p>Still, since the <strong>syntax hides the mismatch</strong>, it can be a <strong>convenient way to package functionality</strong>. And Angular makes heavy use of this construct, so let&#39;s <strong>check out some details</strong>! Specifically:</p>
<ul>
<li><span>a</span>constructor</li>
<li><span>b</span>methods</li>
<li><span>c</span>properties</li>
</ul>
</div></section><section class="slide num numA" data-pos="10-6-9">
<span class="pos">10-6-9</span>
<div class="slidecontent">
<p>First off, what <strong>used to go in the fake constructor</strong>...</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name;
}
</code></pre>
</div></section><section class="slide" data-pos="10-6-10">
<span class="pos">10-6-10</span>
<div class="slidecontent"><p>...is now placed in a literal <strong><code>constructor</code> method</strong> in the class declaration:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">this</span>.name = name;
  }
}
</code></pre>
</div></section><section class="slide" data-pos="10-6-11">
<span class="pos">10-6-11</span>
<div class="slidecontent"><p>If you want <strong>the inherited constructor to be invoked too</strong>, you must <strong>do so yourself</strong> with the new <strong><code>super</code> keyword</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">super</span>(name);
    <span class="hljs-keyword">this</span>.nickname = name + <span class="hljs-string">'y boy'</span>;
  }
}
</code></pre>
</div></section><section class="slide num numB" data-pos="10-6-12">
<span class="pos">10-6-12</span>
<div class="slidecontent">
<p>And you&#39;ve <strong>already seen methods</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>() { ... }
  bark() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name,<span class="hljs-string">"goes woof!"</span>);
  }
}
</code></pre>
<p>Similar to object methods, <strong><code>this</code></strong> (normally) <strong>points to the instance</strong>.</p>
</div></section><section class="slide num numC" data-pos="10-6-13">
<span class="pos">10-6-13</span>
<div class="slidecontent">
<p>Finally, as you saw, <strong>properties are normally initialised in the constructor</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-keyword">this</span>.name = name;
  }
}
</code></pre>
</div></section><section class="slide" data-pos="10-6-14">
<span class="pos">10-6-14</span>
<div class="slidecontent"><p>...but when we use <strong>TypeScript</strong> we can also <strong>initialise properties directly on the class declaration</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> Dog {
  numberOfLegs = <span class="hljs-number">4</span>;
}
</code></pre>
<p>This is <strong>likely to become a part of JavaScript syntax</strong> too.</p>
</div></section><section class="slide" data-pos="10-6-15">
<span class="pos">10-6-15</span>
<div class="slidecontent"><p>So, to <strong>recap</strong>:</p>
<ul>
<li>classes are just a <strong>light syntactic sugar</strong> introduced in ES2015</li>
<li>we normally <strong>don&#39;t need them in JavaScript</strong></li>
<li>but they are a <strong>convenient way to bundle related functionality</strong></li>
<li>which <strong>Angular makes heavy use of</strong>!</li>
</ul>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>10-7.</span> Decorators</h3>
      <p>dewhatnow?</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="10-7-1">
<span class="pos">10-7-1</span>
<div class="slidecontent"><p>The <strong>situation around decorators is rather confusing</strong>;</p>
<ul>
<li>There is a <a href="http://tc39.github.io/proposal-decorators/">proposal</a> to add it as a language feature</li>
<li>There is a slightly different <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">implementation in TypeScript</a></li>
<li>There is the parallel idea in <strong><code>Reflect</code></strong></li>
<li>There is <a href="https://github.com/wycats/javascript-decorators/issues/48">disagreement</a> on whether decorators are a good idea at all</li>
<li>There is (was?) something called <a href="http://blog.thoughtram.io/angular/2015/05/03/the-difference-between-annotations-and-decorators.html">annotations</a> that is sort of the same... yet not</li>
</ul>
</div></section><section class="slide" data-pos="10-7-2">
<span class="pos">10-7-2</span>
<div class="slidecontent"><p>Focusing on the <strong>TypeScript implementation</strong>, decorators are a way of decorating a class...</p>
<ul>
<li><strong>declaration</strong></li>
<li><strong>property</strong></li>
<li><strong>getter</strong> or <strong>setter</strong></li>
<li><strong>method</strong></li>
<li><strong>method parameter</strong></li>
</ul>
</div></section><section class="slide" data-pos="10-7-3">
<span class="pos">10-7-3</span>
<div class="slidecontent"><p>As a simple example, imagine that we have a <strong><code>debounce</code> function</strong> that <strong>throttles other functions</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-comment">// ... create a throttled version of `fn`...</span>
  <span class="hljs-keyword">return</span> throttledFn;
}
</code></pre>
</div></section><section class="slide" data-pos="10-7-4">
<span class="pos">10-7-4</span>
<div class="slidecontent"><p>And then we have a class with a <strong>method that is very expensive</strong> to call:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myClass</span> </span>{
  myExpensiveMethod: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// lots of heavy lifting here</span>
  }
}
</code></pre>
</div></section><section class="slide" data-pos="10-7-5">
<span class="pos">10-7-5</span>
<div class="slidecontent"><p><strong>Without decorators</strong> we would do this:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myClass</span> </span>{
  myExpensiveMethod: debounce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// lots of heavy lifting here</span>
  })
}
</code></pre>
</div></section><section class="slide" data-pos="10-7-6">
<span class="pos">10-7-6</span>
<div class="slidecontent"><p><strong>With decorators</strong>, instead, we use the <code>@</code> syntax:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myClass</span> </span>{
  @debounce
  myExpensiveMethod: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// lots of heavy lifting here</span>
  }
}
</code></pre>
<p>The <strong>end result is the same thing</strong>.</p>
</div></section><section class="slide" data-pos="10-7-7">
<span class="pos">10-7-7</span>
<div class="slidecontent"><p>We can also have <strong>decorators that take additional arguments</strong>. For instance <code>debounce</code> could accept a <strong>minimum number of milliseconds</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myClass</span> </span>{
  @debounce(<span class="hljs-number">300</span>)
  myExpensiveMethod: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// lots of heavy lifting here</span>
  }
}
</code></pre>
</div></section><section class="slide" data-pos="10-7-8">
<span class="pos">10-7-8</span>
<div class="slidecontent"><p>In other words, <strong>decorators are just a light syntax sugar</strong>.</p>
<p>But since an Angular app consists mainly of <strong>classes with core functionality sprinkled in</strong>, then <strong>decorators make a lot of sense</strong>.</p>
</div></section><section class="slide" data-pos="10-7-9">
<span class="pos">10-7-9</span>
<div class="slidecontent"><p>This is what a <strong>Hello-World component looks like without them</strong>:</p>
<pre><code class="lang-typescript">AppComponent = Component({
  selector: <span class="hljs-string">'my-app'</span>,
  template: <span class="hljs-string">'&lt;h1&gt;My First Angular App&lt;/h1&gt;'</span>
}).Class({
  <span class="hljs-keyword">constructor</span>: function(<span class="hljs-params"></span>) {},
  <span class="hljs-comment">// other model-specific stuff</span>
});
</code></pre>
</div></section><section class="slide" data-pos="10-7-10">
<span class="pos">10-7-10</span>
<div class="slidecontent"><p>And here it is in <strong>using decorators</strong> (through TypeScript):</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'my-app'</span>,
  template: <span class="hljs-string">'&lt;h1&gt;My First Angular App&lt;/h1&gt;'</span>
})
<span class="hljs-keyword">class</span> AppComponent {
  <span class="hljs-comment">// other model-specific stuff</span>
}
</code></pre>
</div></section><section class="slide" data-pos="10-7-11">
<span class="pos">10-7-11</span>
<div class="slidecontent"><p>If you want to <strong>dig deeper into decorators</strong>, check out...</p>
<ul>
<li>The <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">decorator section</a> of the TypeScript handbook</li>
<li>This <a href="https://github.com/arolson101/typescript-decorators">concice and clear explanation</a> with examples and interactive links</li>
</ul>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>10-8.</span> Miscellaneous</h3>
      <p>odds and ends</p>
</p>
    </div>
  </section>
  <section class="slide list" data-pos="10-8-1">
<span class="pos">10-8-1</span>
<div class="slidecontent">
<p>There&#39;s three more things worth mentioning:</p>
<ul>
<li><span>a</span>declaring variables with <strong><code>let</code></strong></li>
<li><span>b</span>declaring variables with <strong><code>const</code></strong></li>
<li><span>c</span><strong>template strings</strong></li>
</ul>
</div></section><section class="slide num numA" data-pos="10-8-2">
<span class="pos">10-8-2</span>
<div class="slidecontent">
<p>Variables in JavaScript have <strong>functional scope</strong>.</p>
<p>Even if you declare them inside an <strong>if-block in the middle of a function</strong>, the variable is still <strong>visible throughout the entire function</strong>.</p>
</div></section><section class="slide" data-pos="10-8-3">
<span class="pos">10-8-3</span>
<div class="slidecontent"><p>So when you write this...</p>
<pre><code>function myFunc(arg,<span class="hljs-class"><span class="hljs-keyword">lib</span>){</span>
  <span class="hljs-keyword">if</span> (arg === <span class="hljs-number">42</span>){
    var ret = <span class="hljs-class"><span class="hljs-keyword">lib</span>.<span class="hljs-title">method</span>() + 7;</span>
    <span class="hljs-keyword">return</span> ret;
  }
  /<span class="hljs-regexp">/ do sth else
}</span>
</code></pre></div></section><section class="slide" data-pos="10-8-4">
<span class="pos">10-8-4</span>
<div class="slidecontent"><p>...this is what (conceptually) happens:</p>
<pre><code>function myFunc(arg,<span class="hljs-class"><span class="hljs-keyword">lib</span>){</span>
  var ret;
  <span class="hljs-keyword">if</span> (arg === <span class="hljs-number">42</span>){
    ret = <span class="hljs-class"><span class="hljs-keyword">lib</span>.<span class="hljs-title">method</span>() + 7;</span>
    <span class="hljs-keyword">return</span> ret;
  }
  /<span class="hljs-regexp">/ do sth else
}</span>
</code></pre><p>In other words, the <strong>declaration is hoisted to the top</strong>.</p>
</div></section><section class="slide" data-pos="10-8-5">
<span class="pos">10-8-5</span>
<div class="slidecontent"><p>This is generally considered a <strong>design mistake</strong>, and can give rise to <strong>weird bugs</strong>.</p>
<p>ES6 therefore introduces <strong><code>let</code> as an alternative to <code>var</code></strong> for declaring variables, and the <strong>only difference</strong> is that <strong><code>let</code> has block scope</strong>.</p>
</div></section><section class="slide num numB" data-pos="10-8-6">
<span class="pos">10-8-6</span>
<div class="slidecontent">
<p>In most languages there&#39;s a way to <strong>define constants</strong>, meaning a <strong>variable that cannot change</strong>.</p>
<p>This is <strong>missing from JavaScript</strong>.</p>
</div></section><section class="slide" data-pos="10-8-7">
<span class="pos">10-8-7</span>
<div class="slidecontent"><p>A common &quot;hack&quot; is to <strong>name constants in all capitals</strong>:</p>
<pre><code>var SOME_CONST = <span class="hljs-number">42</span><span class="hljs-comment">;</span>
</code></pre><p>But this has <strong>no technical significance</strong>, it is just a hint.</p>
</div></section><section class="slide" data-pos="10-8-8">
<span class="pos">10-8-8</span>
<div class="slidecontent"><p>ES6 therefore introduces <strong><code>const</code> as another alternative to <code>var</code></strong>, and the <strong>only difference</strong> is that you <strong>cannot reassign the value</strong>.</p>
<pre><code>const answer = <span class="hljs-number">42</span><span class="hljs-comment">;</span>
<span class="hljs-attribute">answer</span> = <span class="hljs-number">43</span><span class="hljs-comment">; // throws an error</span>
</code></pre></div></section><section class="slide num numC" data-pos="10-8-9">
<span class="pos">10-8-9</span>
<div class="slidecontent">
<p>Finally, <strong>template strings</strong>!</p>
<pre><code><span class="hljs-keyword">let</span> userTempl = <span class="hljs-string">`
  First name: <span class="hljs-subst">${user.fname}</span>
  Last name: <span class="hljs-subst">${user.lname}</span>
`</span>;
</code></pre></div></section><section class="slide" data-pos="10-8-10">
<span class="pos">10-8-10</span>
<div class="slidecontent"><p>As you saw, template strings...</p>
<ul>
<li>are <strong>defined inside two backticks</strong></li>
<li>can <strong>contain linebreaks</strong></li>
<li>allow <strong>interpolation inside ${}</strong></li>
</ul>
</div></section><section class="slide" data-pos="10-8-11">
<span class="pos">10-8-11</span>
<div class="slidecontent"><p>There&#39;s also a <strong>semi-secret way to invoke functions with templates</strong>. Here&#39;s an example from <a href="https://github.com/yoshuawuyts/choo">Choo</a>:</p>
<pre><code><span class="xml">html`
  <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app"</span>&gt;</span>
    Count: $</span><span class="hljs-template-variable">{state.counter.count}</span><span class="xml">
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">$</span></span></span><span class="hljs-template-variable">{(e) =&gt; send('counter:increment')}</span><span class="xml"><span class="hljs-tag">&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>`</span>
</code></pre><p>The <strong><code>html</code> function is invoked</strong> with the templates and interpolated values.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>10-9.</span> Trying it out</h3>
      <p>Toe into the water</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="10-9-1">
<span class="pos">10-9-1</span>
<div class="slidecontent"><p>As a <strong>light-weight exercise</strong> during the upcoming break, let&#39;s <strong>try some of the ES6 stuff out</strong>!</p>
</div></section><section class="slide list" data-pos="10-9-2">
<span class="pos">10-9-2</span>
<div class="slidecontent">
<p>We&#39;ll do this in <strong>two different parts</strong>:</p>
<ul>
<li><span>a</span>writing and <strong>running ES6 code</strong></li>
<li><span>b</span>checking <strong>how it translates to ES5</strong></li>
</ul>
</div></section><section class="slide num numA" data-pos="10-9-3">
<span class="pos">10-9-3</span>
<div class="slidecontent">
<p>An easy way to <strong>run ES6 code</strong> is by using <a href="http://es6fiddle.net/">es6fiddle.net</a>. Write <strong>ES6 code in the left column</strong>, and see the <strong>output to the right</strong>.</p>
<p><img src="resources/images/es6fiddle.png" alt=""></p>
</div></section><section class="slide" data-pos="10-9-4">
<span class="pos">10-9-4</span>
<div class="slidecontent"><p>Through a dropdown you can access a number of <strong>ready-made examples</strong> which are a good starting point for experimenting.</p>
</div></section><section class="slide" data-pos="10-9-5">
<span class="pos">10-9-5</span>
<div class="slidecontent"><p>If you have a <strong>modern version of Chrome</strong> you can also <strong>run ES2015 code in the console</strong>!</p>
<p><img src="resources/images/es2015inconsole.png" alt=""></p>
</div></section><section class="slide num numB" data-pos="10-9-6">
<span class="pos">10-9-6</span>
<div class="slidecontent">
<p>To see the <strong>ES5 equivalent</strong>, we&#39;ll use <a href="https://babeljs.io/repl">babeljs.io/repl</a>. The right column here shows <strong>ES5 translation instead of output</strong>.</p>
<p><img src="resources/images/babelrepl.png" alt=""></p>
</div></section><section class="slide" data-pos="10-9-7">
<span class="pos">10-9-7</span>
<div class="slidecontent"><p>A good way to get started is to <strong>copy the ES6fiddle examples</strong> and <strong>see what they translate to</strong>!</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 11 / 13</span>
    <h2>Appendix: NgModules</h2>
    <p>fitting the pieces together</p>
</p>
  </div>
  
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. Introducing NgModule</li>
<li>2. Module scoping</li>
<li>3. Module motivation</li>
<li>4. Root module</li>
<li>5. AoT vs JiT</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>11-1.</span> Introducing NgModule</h3>
      <p>or package or barrel or glob or</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="11-1-1">
<span class="pos">11-1-1</span>
<div class="slidecontent"><p>When AngularJS came out, there was <strong>no native module solution</strong> for JavaScript.</p>
<p>AngularJS therefore <strong>included a module system as part of the framework</strong>.</p>
</div></section><section class="slide" data-pos="11-1-2">
<span class="pos">11-1-2</span>
<div class="slidecontent"><p><strong>Initially</strong> this was seen as a <strong>big advantage</strong> of AngularJS.</p>
<p>But <strong>after ES6 introduced native modules</strong>, having to work with the AngularJS modules <strong>felt stale and limited</strong>.</p>
</div></section><section class="slide" data-pos="11-1-3">
<span class="pos">11-1-3</span>
<div class="slidecontent"><p>That&#39;s just <strong>one of many examples</strong> of how <strong>time ran away from AngularJS</strong>.</p>
<p>Which is also the motivation behind the new Angular: <strong>keep the good ideas</strong> but <strong>take advantage of modern features</strong>.</p>
</div></section><section class="slide" data-pos="11-1-4">
<span class="pos">11-1-4</span>
<div class="slidecontent"><p>So in Angular we expected to <strong>use native modules</strong>, and not having to deal with a parallel homebrew solution.</p>
<p>And, indeed, <strong>this was the case</strong>...</p>
</div></section><section class="slide" data-pos="11-1-5">
<span class="pos">11-1-5</span>
<div class="slidecontent"><p>...<strong>until one of the last release candidates</strong>, which <strong>introduced <code>NgModules</code></strong>.</p>
<p>Now, suddenly, we would <strong>modularise our code using ES6 modules</strong> as usual, but that code was in turn <strong>split into <code>NgModules</code></strong>.</p>
</div></section><section class="slide" data-pos="11-1-6">
<span class="pos">11-1-6</span>
<div class="slidecontent"><p>And, of course, this is <strong>exactly</strong> the kind of thing we <strong>wanted to get away from</strong>!</p>
</div></section><section class="slide" data-pos="11-1-7">
<span class="pos">11-1-7</span>
<div class="slidecontent"><p>Unsurprisingly this addition was <strong>heavily critisized</strong>, both for <strong>coming so late</strong> and for being a</p>
<blockquote>
<p>   solution in search of a problem</p>
</blockquote>
</div></section><section class="slide question" data-pos="11-1-8">
<span class="pos">11-1-8</span>
<div class="slidecontent">
<p>But, so, <strong>why did they do it</strong>?</p>
</div></section><section class="slide answer" data-pos="11-1-9">
<span class="pos">11-1-9</span>
<div class="slidecontent">
<p>Many reasons! However, before we delve into that we&#39;ll first take a look at <strong>how <code>NgModules</code> work</strong>!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>11-2.</span> Module scoping</h3>
      <p>lines of sight</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="11-2-1">
<span class="pos">11-2-1</span>
<div class="slidecontent"><p>An <strong><code>NgModule</code></strong>, similar to modules in AngularJS, is mainly a <strong>scoped container for application parts</strong>.</p>
</div></section><section class="slide" data-pos="11-2-2">
<span class="pos">11-2-2</span>
<div class="slidecontent"><p>Let&#39;s say we have these <strong>three NgModules</strong>:</p>
<p><img src="resources/diagrams/modules.svg" alt=""></p>
<ul>
<li><strong><code>Module1</code></strong> defines <code>CompA</code> and <code>CompB</code></li>
<li><strong><code>Module2</code></strong> defines <code>CompC</code></li>
<li><strong><code>RootModule</code></strong> defines <code>RootComp</code></li>
</ul>
</div></section><section class="slide" data-pos="11-2-3">
<span class="pos">11-2-3</span>
<div class="slidecontent"><p>Now, if <strong><code>RootModule</code> imports the other two</strong>:</p>
<p><img src="resources/diagrams/modulesusage.svg" alt=""></p>
</div></section><section class="slide" data-pos="11-2-4">
<span class="pos">11-2-4</span>
<div class="slidecontent"><p>...then the <strong>lines of sight</strong> will be:</p>
<p><img src="resources/diagrams/modulesusagelines.svg" alt=""></p>
<ul>
<li><strong><code>RootComp</code></strong> can use everything</li>
<li><strong><code>CompA</code> and <code>CompB</code></strong> can use each other</li>
<li><strong><code>CompC</code></strong> can&#39;t use any other component</li>
</ul>
</div></section><section class="slide" data-pos="11-2-5">
<span class="pos">11-2-5</span>
<div class="slidecontent"><p>But if <strong><code>CompB</code> isn&#39;t exported</strong>:</p>
<p><img src="resources/diagrams/modulesusagehidden.svg" alt=""></p>
</div></section><section class="slide" data-pos="11-2-6">
<span class="pos">11-2-6</span>
<div class="slidecontent"><p>...then the <strong>lines of sight become</strong>:</p>
<p><img src="resources/diagrams/modulesusagehiddenlines.svg" alt=""></p>
<ul>
<li><strong><code>RootComp</code></strong> can use <code>CompA</code> and <code>CompC</code></li>
<li><strong><code>CompA</code> and <code>CompB</code></strong> can use each other</li>
<li><strong><code>CompC</code></strong> can&#39;t use any other component</li>
</ul>
</div></section><section class="slide" data-pos="11-2-7">
<span class="pos">11-2-7</span>
<div class="slidecontent"><p>Here&#39;s the code for <strong><code>Module1</code></strong> in the final version of the example:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@NgModule</span>({
  exports:      [ CompA ],
  declarations: [ CompA, CompB ]
})
<span class="hljs-keyword">class</span> Module1 {}
</code></pre>
<p>Note how <strong>only <code>CompA</code> is exported</strong>.</p>
</div></section><section class="slide" data-pos="11-2-8">
<span class="pos">11-2-8</span>
<div class="slidecontent"><p>And for completion, here&#39;s <strong><code>Module2</code></strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@NgModule</span>({
  exports:      [ CompC ],
  declarations: [ CompC ]
})
<span class="hljs-keyword">class</span> Module2 {}
</code></pre>
</div></section><section class="slide" data-pos="11-2-9">
<span class="pos">11-2-9</span>
<div class="slidecontent"><p>...and <strong><code>RootModule</code></strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@NgModule</span>({
  imports:      [ Module1, Module2 ],
  declarations: [ RootComp ],
  bootstrap:    [ RootComp ]
})
<span class="hljs-keyword">class</span> RootModule {}
</code></pre>
</div></section><section class="slide" data-pos="11-2-10">
<span class="pos">11-2-10</span>
<div class="slidecontent"><p>We could <strong>summarize the sight rules</strong> like this -</p>
<p>A <strong>component can see</strong>:</p>
<ul>
<li>all other <strong>components defined in the same module</strong></li>
<li>all <strong>exported components in imported modules</strong></li>
</ul>
</div></section><section class="slide" data-pos="11-2-11">
<span class="pos">11-2-11</span>
<div class="slidecontent"><p>Although we&#39;ve just talked about components, the <strong>same thing applies to <code>Directives</code> and <code>Pipes</code></strong>.</p>
</div></section><section class="slide question" data-pos="11-2-12">
<span class="pos">11-2-12</span>
<div class="slidecontent">
<p>Wait - <strong>what&#39;s the point</strong> of <strong>defining but not exporting</strong> something?</p>
</div></section><section class="slide answer" data-pos="11-2-13">
<span class="pos">11-2-13</span>
<div class="slidecontent">
<p>Likely what you&#39;re not exporting is an <strong>implementation detail of something you ARE exporting</strong>.</p>
<p>In our example, <strong><code>CompB</code> is probably used by <code>CompA</code></strong>, but <strong>wouldn&#39;t make sense to use on its own</strong> or anywhere else.</p>
</div></section><section class="slide question" data-pos="11-2-14">
<span class="pos">11-2-14</span>
<div class="slidecontent">
<p>Also - what if we are creating a 3rd party <strong>library of components</strong>? Won&#39;t it be a 
<strong>headache for the root module to export all components</strong>?</p>
</div></section><section class="slide answer" data-pos="11-2-15">
<span class="pos">11-2-15</span>
<div class="slidecontent">
<p>It would be, if not for the fact that we can <strong>export modules</strong>. So the <strong>root module</strong> of such a library would <strong>look like this</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@NgModule</span>({
  imports: [ Module1, Module2, Module3, ... ],
  exports: [ Module1, Module2, Module3, ... ]
})
<span class="hljs-keyword">class</span> RootModule {}
</code></pre>
</div></section><section class="slide question" data-pos="11-2-16">
<span class="pos">11-2-16</span>
<div class="slidecontent">
<p>And, <strong>why are modules classes</strong> anyway? Would we <strong>ever write something inside the class declaration</strong> for an <code>NgModule</code>?</p>
</div></section><section class="slide answer" data-pos="11-2-17">
<span class="pos">11-2-17</span>
<div class="slidecontent">
<p>No, we never would. They likely went with that just to have a <strong>consistent look</strong> with how <strong>other application parts are defined</strong>, that is, <strong>class declarations</strong> with <strong>decorated metadata</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>11-3.</span> Module motivation</h3>
      <p>Digging into the why</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="11-3-1">
<span class="pos">11-3-1</span>
<div class="slidecontent"><p><strong>Before <code>NgModules</code></strong> were added to Angular, <strong>components could declare dependencies</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  directives: [ComponentB],
  template: <span class="hljs-string">'...'</span>
})
<span class="hljs-keyword">class</span> ComponentA {...}
</code></pre>
<p>Now <strong><code>ComponentA</code> could use <code>ComponentB</code></strong> in its template.</p>
</div></section><section class="slide" data-pos="11-3-2">
<span class="pos">11-3-2</span>
<div class="slidecontent"><p>With the introduction of <code>NgModule</code>, <strong>this API was deprecated</strong>. Now <strong>all components must belong to an <code>NgModule</code></strong>, and <strong>only <code>NgModule</code> scope allows access</strong>.</p>
</div></section><section class="slide question" data-pos="11-3-3">
<span class="pos">11-3-3</span>
<div class="slidecontent">
<p>This seems <strong>more cumbersome</strong> in every way. <strong>Why</strong> did they make this change?</p>
</div></section><section class="slide answer" data-pos="11-3-4">
<span class="pos">11-3-4</span>
<div class="slidecontent">
<p>There are <strong>many different reasons</strong>.</p>
<p>And note that since <strong>they knew there would be backlash</strong>, they likely thought this through more than once.</p>
</div></section><section class="slide list" data-pos="11-3-5">
<span class="pos">11-3-5</span>
<div class="slidecontent">
<p>Let&#39;s go over <strong>three of the reasons</strong> behind <code>NgModule</code>:</p>
<ul>
<li><span>a</span>a tool for you to <strong>modularise your codebase</strong></li>
<li><span>b</span><strong>scope selectors</strong> to lessen risk of clash</li>
<li><span>c</span>allow easier <strong>static dependency analysis</strong> when the templates are compiled</li>
</ul>
</div></section><section class="slide num numA" data-pos="11-3-6">
<span class="pos">11-3-6</span>
<div class="slidecontent">
<p><code>NgModules</code> are an <strong>Angular-specific way to organise your code</strong>, often in a thematic way.</p>
</div></section><section class="slide" data-pos="11-3-7">
<span class="pos">11-3-7</span>
<div class="slidecontent"><p>For <strong>example</strong>, a <strong>forum app</strong> might consist of a <strong><code>ThreadModule</code></strong>, a <strong><code>FrontpageModule</code></strong> and an <strong><code>AdminModule</code></strong>, which are then all brought in by a root <strong><code>AppModule</code></strong>.</p>
</div></section><section class="slide num numB" data-pos="11-3-8">
<span class="pos">11-3-8</span>
<div class="slidecontent">
<p>Also, <strong><code>NgModules</code> reduce risk of selector clashes</strong>. If <strong>two components have the same selector</strong>, that works fine as long as you <strong>cannot see both of them</strong>.</p>
</div></section><section class="slide question" data-pos="11-3-9">
<span class="pos">11-3-9</span>
<div class="slidecontent">
<p>Returning to the scoping example - what components could <strong>safely have the same selector</strong>?</p>
<p><img src="resources/diagrams/modulesusagehiddenlines.svg" alt=""></p>
</div></section><section class="slide answer" data-pos="11-3-10">
<span class="pos">11-3-10</span>
<div class="slidecontent">
<p>Only <strong><code>CompB</code> and <code>CompC</code></strong>, since <strong>no module sees both of them</strong>.</p>
</div></section><section class="slide num numC" data-pos="11-3-11">
<span class="pos">11-3-11</span>
<div class="slidecontent">
<p>The third and final reason: <strong><code>NgModules</code> make static analysis easier</strong>, especially for AoT compilation.</p>
<p>More information <a href="https://github.com/angular/angular/issues/10552#issuecomment-241556913">here</a>.</p>
</div></section><section class="slide question" data-pos="11-3-12">
<span class="pos">11-3-12</span>
<div class="slidecontent">
<p>The <strong>first reason seems really weak</strong>, and the <strong>second seems periferal</strong>. Is it fair to say that the <strong>third reason is the most important one</strong>?</p>
</div></section><section class="slide answer" data-pos="11-3-13">
<span class="pos">11-3-13</span>
<div class="slidecontent">
<p>Yes, absolutely. It might <strong>seem not to matter for small / simple apps</strong>, but as soon as you</p>
<ul>
<li><strong>scale up</strong> or do</li>
<li><strong>advanced bootstrapping</strong> or</li>
<li><strong>lazy loading</strong>,</li>
</ul>
<p>...it becomes <strong>really important</strong>.</p>
</div></section><section class="slide" data-pos="11-3-14">
<span class="pos">11-3-14</span>
<div class="slidecontent"><p>So, really, the <strong>Angular team deserves credit</strong> for making a <strong>necessary but tough decision</strong> that they knew would <strong>cause lots of backlash</strong>, and would only be <strong>understood by a minority</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>11-4.</span> Root module</h3>
      <p>Where it all begins</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="11-4-1">
<span class="pos">11-4-1</span>
<div class="slidecontent"><p>So, <strong>Angular applications</strong> are made up by <strong>one or more <code>NgModule</code>:s</strong>.</p>
<p>Of these, exactly 1 is a <strong>root module</strong>. Let&#39;s find out what those are!</p>
</div></section><section class="slide" data-pos="11-4-2">
<span class="pos">11-4-2</span>
<div class="slidecontent"><p>As the name suggests, the root module is <strong>the root of the application</strong>. More precisely, it&#39;s <strong>the <code>NgModule</code> we bootstrap from</strong>:</p>
<pre><code><span class="hljs-selector-tag">platformBrowserDynamic</span>()<span class="hljs-selector-class">.bootstrapModule</span>(AppModule);
</code></pre><p>Usually this module is <strong>called <code>AppModule</code></strong>, although the name has no technical meaning.</p>
</div></section><section class="slide" data-pos="11-4-3">
<span class="pos">11-4-3</span>
<div class="slidecontent"><p>For a module to be boostrappable it must <strong>say which component to bootstrap from</strong>, so that&#39;s another trait of a root module. This is done in the <strong><code>bootstrap</code> property</strong>:</p>
<pre><code><span class="hljs-variable">@NgModule</span>({
    <span class="hljs-attribute">imports</span>:      [ BrowserModule ],
    <span class="hljs-attribute">declarations</span>: [ AppComponent ],
    <span class="hljs-attribute">bootstrap</span>:    [ AppComponent ] <span class="hljs-comment">// &lt;--- bootstrap comp!</span>
})
class AppModule {}
</code></pre></div></section><section class="slide" data-pos="11-4-4">
<span class="pos">11-4-4</span>
<div class="slidecontent"><p>The root module is also responsible for <strong>importing global dependencies</strong>. If we&#39;re running in the browser we need <strong><code>BrowserModule</code></strong>, so that&#39;s another root module giveaway:</p>
<pre><code><span class="hljs-variable">@NgModule</span>({
    <span class="hljs-attribute">imports</span>:      [ BrowserModule ], <span class="hljs-comment">// &lt;--- global browser stuff</span>
    <span class="hljs-attribute">declarations</span>: [ AppComponent ],
    <span class="hljs-attribute">bootstrap</span>:    [ AppComponent ]
})
class AppModule {}
</code></pre></div></section><section class="slide" data-pos="11-4-5">
<span class="pos">11-4-5</span>
<div class="slidecontent"><p>One the <strong>small scale</strong> of the demos and exercises in this course there really is <strong>no need for more modules beyond the root module</strong>, so we will simply let that one <strong>import and declare everything</strong>.</p>
</div></section><section class="slide" data-pos="11-4-6">
<span class="pos">11-4-6</span>
<div class="slidecontent"><p>But in a larger app the <strong>scoping becomes important</strong>, and at that point you have to <strong>plan out what the <code>RootModule</code> should provide</strong> for the rest.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>11-5.</span> AoT vs JiT</h3>
      <p>Prebaked vs Made to order</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="11-5-1">
<span class="pos">11-5-1</span>
<div class="slidecontent"><p>We&#39;ve already mentioned the <strong>two options for template compilation</strong> a few times:</p>
<table class="deflist">
  <tbody>
    <tr>
      <td>AoT</td><td>Compile <strong>Ahead of Time</strong> in a build step</td>
    </tr>
    <tr>
      <td>JiT</td><td>Compile <strong>Just in Time</strong> in the browser</td>
    </tr>
  </tbody>
</table></div></section><section class="slide" data-pos="11-5-2">
<span class="pos">11-5-2</span>
<div class="slidecontent"><p>To revisit the infrastructure chain, we either do this (<strong>AoT</strong>):</p>
<p><img src="resources/diagrams/chain-precomp-highlight.svg" alt=""></p>
</div></section><section class="slide" data-pos="11-5-3">
<span class="pos">11-5-3</span>
<div class="slidecontent"><p>...or this (<strong>JiT</strong>):</p>
<p><img src="resources/diagrams/chain-webpack-highlight.svg" alt=""></p>
</div></section><section class="slide" data-pos="11-5-4">
<span class="pos">11-5-4</span>
<div class="slidecontent"><p>The <strong>advantage of build-step compilation</strong> is that we get a <strong>smaller package</strong></p>
<p>The price for that advantage is <strong>added build complexity</strong>.</p>
</div></section><section class="slide" data-pos="11-5-5">
<span class="pos">11-5-5</span>
<div class="slidecontent"><p>We&#39;ll now take a look at <strong>what the two approaches look like in practice</strong>!</p>
</div></section><section class="slide" data-pos="11-5-6">
<span class="pos">11-5-6</span>
<div class="slidecontent"><p>We have <strong>already been doing JiT</strong> in previous examples:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> AppModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./main.ts'</span>;
platformBrowserDynamic().bootstrapModule(AppModule);
</code></pre>
<p>Inside the <strong><code>bootstrapModule</code></strong> code, the <strong>template compilation</strong> is taken care of.</p>
</div></section><section class="slide" data-pos="11-5-7">
<span class="pos">11-5-7</span>
<div class="slidecontent"><p>Look again at our <strong>JiT</strong> setup:</p>
<pre><code><span class="hljs-keyword">import</span> AppModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./main.ts'</span>;
platformBrowserDynamic().bootstrapModule(AppModule);
</code></pre><p>In <strong>AoT</strong>, that would become the following:</p>
<pre><code><span class="hljs-keyword">import</span> AppModuleNgFactory <span class="hljs-keyword">from</span> <span class="hljs-string">'./main.ngfactory'</span>;
platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);
</code></pre></div></section><section class="slide" data-pos="11-5-8">
<span class="pos">11-5-8</span>
<div class="slidecontent"><p>The <strong><code>main.ngfactory</code></strong> file is created by the <code>ngc</code> command line tool, which lives in the <code>@angular/compiler-cli</code> package.</p>
<p>See more details in the <a href="https://angular.io/guide/aot-compiler">official Ahead-of-Time compilation guide</a>!</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 12 / 13</span>
    <h2>Appendix: Directives</h2>
    <p>From molecules to atoms</p>
</p>
  </div>
  <section class="slide">

<div class="slidecontent"><p>This appendix chapter takes a <strong>closer look at directives</strong> - what kinds are there, and <strong>how do we make our own</strong>?</p>
</div></section>
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. Node manipulation</li>
<li>2. Server safety</li>
<li>3. Consorting with the host</li>
<li>4. Case study - host</li>
<li>5. Structure directives</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>12-1.</span> Node manipulation</h3>
      <p>regaining control</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="12-1-1">
<span class="pos">12-1-1</span>
<div class="slidecontent"><p>So - directives! We&#39;ve seen that there are <strong>three different kinds</strong>:</p>
<ul>
<li><strong>Components</strong> who have their own template</li>
<li><strong>Structure directives</strong> who also change the HTML structure</li>
<li>regular <strong>Directives</strong> who just manipulate the element they&#39;re attached to</li>
</ul>
</div></section><section class="slide" data-pos="12-1-2">
<span class="pos">12-1-2</span>
<div class="slidecontent"><p>Most of the <strong>built-in directives</strong> we&#39;ve been using, except for the <code>*</code>-prefixed <code>ngIf</code> and <code>ngFor</code>, belong to the <strong>latter category</strong>.</p>
<p>Let&#39;s now talk about <strong>custom directives</strong> in that category, starting with: <strong>what&#39;s the point</strong>?</p>
</div></section><section class="slide" data-pos="12-1-3">
<span class="pos">12-1-3</span>
<div class="slidecontent"><p>A big <strong>reason for using a framework</strong> is to not having to <strong>deal with the DOM</strong>. And indeed, with Angular, you don&#39;t have to.</p>
<p>But <strong>sometimes you need to</strong>! How, then, do we <strong>take back control</strong> from Angular?</p>
</div></section><section class="slide" data-pos="12-1-4">
<span class="pos">12-1-4</span>
<div class="slidecontent"><p>A <strong>common scenario</strong> is that we want to use <strong>some other library</strong> that needs DOM access. For instance, we might have a <strong>jQuery plugin</strong> that we want to attach to an element.</p>
<p>So, how do we go about getting a <strong>reference to an element</strong>?</p>
</div></section><section class="slide" data-pos="12-1-5">
<span class="pos">12-1-5</span>
<div class="slidecontent"><p>The key is the <strong>built-in dependency called <code>ElementRef</code></strong>. If we define our <code>@Directive</code>&#39;s class constructor like this...</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> myElement: ElementRef</span>){}
</code></pre>
<p>...we can access that reference elsewhere:</p>
<pre><code class="lang-typescript">someClickHandler(){
  <span class="hljs-comment">// do stuff with this.myElement.nativeElement</span>
}
</code></pre>
</div></section><section class="slide" data-pos="12-1-6">
<span class="pos">12-1-6</span>
<div class="slidecontent"><p>Alternatively, if it is a one-off mutation, <strong>do it straight in the constructor</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> myElement: ElementRef</span>){
  <span class="hljs-keyword">this</span>.myElement.nativeElement.doSomethingUseful();
}
</code></pre>
<p>Note that this is <strong>safe if we&#39;re in a directive</strong>, while a <strong>component should use a lifecycle hook</strong> to ensure we have been rendered.</p>
</div></section><section class="slide" data-pos="12-1-7">
<span class="pos">12-1-7</span>
<div class="slidecontent"><p>For an example that <strong>uses this technique to wrap a jQuery plugin</strong>, check out the <a href="resources/supportsite/demos/elementmanip" target="_blank">Element manipulation</a> demo.</p>
<p>Or - another common example - <strong>setting autofocus to an element</strong> which you can see in the <a href="resources/supportsite/demos/autofocus" target="_blank">Autofocus</a> demo.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>12-2.</span> Server safety</h3>
      <p>Cut the cord to the DOM</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="12-2-1">
<span class="pos">12-2-1</span>
<div class="slidecontent"><p>The <strong><code>autofocus</code> demo</strong> we saw earlier was <strong>implemented like this</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> Focus {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> elRef: ElementRef</span>) {}
  ngOnInit() {
    <span class="hljs-keyword">this</span>.elRef.nativeElement.focus()
  }
}
</code></pre>
</div></section><section class="slide" data-pos="12-2-2">
<span class="pos">12-2-2</span>
<div class="slidecontent"><p>There is <strong>one big drawback</strong> with that code; what happens if we attempt to <strong>render this app on the server</strong>?</p>
<p>There <strong>won&#39;t be a DOM node</strong>, so presumably things will go boom.</p>
</div></section><section class="slide" data-pos="12-2-3">
<span class="pos">12-2-3</span>
<div class="slidecontent"><p>The solution is to <strong>communicate intent</strong> of node manipulation instead of actually performing it.</p>
<p>That way, <strong>if we&#39;re on the server</strong>, those <strong>intents can simply be ignored</strong>.</p>
</div></section><section class="slide" data-pos="12-2-4">
<span class="pos">12-2-4</span>
<div class="slidecontent"><p>We accomplish this by using the <strong><code>Renderer</code></strong> as proxy:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> Focus {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> rndr: Renderer, <span class="hljs-keyword">public</span> elRef: ElementRef</span>) {}
  ngOnInit() {
    <span class="hljs-keyword">this</span>.rndr.invokeElementMethod(
      <span class="hljs-keyword">this</span>.elRef.nativeElement, <span class="hljs-string">'focus'</span>, []
    );
  }
}
</code></pre>
</div></section><section class="slide question" data-pos="12-2-5">
<span class="pos">12-2-5</span>
<div class="slidecontent">
<p>Wait - why is this:</p>
<pre><code><span class="hljs-keyword">this</span>.rndr.invokeElementMethod(
  <span class="hljs-keyword">this</span>.elRef.nativeElement, <span class="hljs-string">'focus'</span>, []
);
</code></pre><p>...so much better than this?</p>
<pre><code>this<span class="hljs-selector-class">.elRef</span><span class="hljs-selector-class">.nativeElement</span><span class="hljs-selector-class">.focus</span>()
</code></pre></div></section><section class="slide answer" data-pos="12-2-6">
<span class="pos">12-2-6</span>
<div class="slidecontent">
<p>Since the <code>Renderer</code> is injected, we can have a <strong>special server version</strong> which simply <strong>doesn&#39;t do anything</strong> in <code>invokeElementMethod</code>.</p>
</div></section><section class="slide" data-pos="12-2-7">
<span class="pos">12-2-7</span>
<div class="slidecontent"><p>While, if we used the first version...</p>
<pre><code>this<span class="hljs-selector-class">.elRef</span><span class="hljs-selector-class">.nativeElement</span><span class="hljs-selector-class">.focus</span>()
</code></pre><p>...we would have to make <strong>mock elements</strong> to prevent errors, which would be <strong>much more complicated</strong>.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>12-3.</span> Consorting with the host</h3>
      <p>let me count the ways</p>
</p>
    </div>
  </section>
  <section class="slide list" data-pos="12-3-1">
<span class="pos">12-3-1</span>
<div class="slidecontent">
<p>We&#39;re now going to look at <strong>three ways to interact with the host</strong> element:</p>
<ul>
<li><span>a</span>Referencing the element</li>
<li><span>b</span>Listening to events</li>
<li><span>c</span>Binding to properties</li>
</ul>
</div></section><section class="slide num numA" data-pos="12-3-2">
<span class="pos">12-3-2</span>
<div class="slidecontent">
<p>First off, by <strong>asking for an <code>ElementRef</code> in the constructor</strong> we can get a reference to the host element:</p>
<pre><code><span class="hljs-keyword">class</span> {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> el: ElementRef</span>){}
  <span class="hljs-comment">/* rest of the code can access `this.el` */</span>
}
</code></pre></div></section><section class="slide" data-pos="12-3-3">
<span class="pos">12-3-3</span>
<div class="slidecontent"><p>On <code>this.el</code> we find the <strong><code>nativeElement</code> property</strong> which <strong>points to the actual DOM node</strong>.</p>
</div></section><section class="slide num numB" data-pos="12-3-4">
<span class="pos">12-3-4</span>
<div class="slidecontent">
<p>So just saw how we can use <strong><code>ElementRef</code></strong> to <strong>access the parent node to which the directive is attached</strong>.</p>
<p>Theoretically, that&#39;s all we need to do whatever we want, including <strong>attaching eventhandlers</strong>.</p>
</div></section><section class="slide" data-pos="12-3-5">
<span class="pos">12-3-5</span>
<div class="slidecontent"><p>Here&#39;s what that could look like when <strong>using the reference</strong>:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
  <span class="hljs-keyword">constructor</span>(<span class="hljs-keyword">private</span> el: ElementRef){}
  handleClick() { <span class="hljs-comment">/* do something */</span> }
  ngOnInit() {
    <span class="hljs-keyword">this</span>.el.nativeElement.addEventListener(
      <span class="hljs-string">'click'</span>,<span class="hljs-keyword">this</span>.handleClick
    )
  }
}
</code></pre><p>...but reverting to the <strong>regular DOM API</strong> like this feels very <strong>primitive</strong>!</p>
</div></section><section class="slide" data-pos="12-3-6">
<span class="pos">12-3-6</span>
<div class="slidecontent"><p>Angular therefore offers a shorthand through the <strong><code>HostListener</code></strong> decorator:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
  <span class="hljs-meta">@HostListener(<span class="hljs-meta-string">'click'</span>)</span> handleClick() { <span class="hljs-comment">/* do something */</span> }
}
</code></pre></div></section><section class="slide num numC" data-pos="12-3-7">
<span class="pos">12-3-7</span>
<div class="slidecontent">
<p>Similarly, using the ref to <strong>control host properties</strong> would be convoluted:</p>
<pre><code><span class="hljs-keyword">class</span> {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> el: ElementRef</span>){}
  active: <span class="hljs-built_in">boolean</span>
  updateHost() {
    <span class="hljs-keyword">let</span> method = <span class="hljs-keyword">this</span>.active ? <span class="hljs-string">'add'</span> : <span class="hljs-string">'remove'</span>;
    <span class="hljs-keyword">this</span>.el.nativeElement.classList[method](<span class="hljs-string">'highlighted'</span>)
  }
  <span class="hljs-comment">/* and some code to update `active` */</span>
}
</code></pre></div></section><section class="slide" data-pos="12-3-8">
<span class="pos">12-3-8</span>
<div class="slidecontent"><p>Therefore there is a powerful shorthand to <strong>bind to host properties</strong>:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> {</span>
  <span class="hljs-meta">@HostBinding</span>(<span class="hljs-string">'class.highlighted'</span>) <span class="hljs-string">active:</span> <span class="hljs-keyword">boolean</span>
  <span class="hljs-comment">/* and some code to update `active` */</span>
}
</code></pre><p>Much slicker, and again, note how <strong>no reference is needed</strong>!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>12-4.</span> Case study - host</h3>
      <p>Putting the host to the test</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="12-4-1">
<span class="pos">12-4-1</span>
<div class="slidecontent"><p>To internalise what we just walked through, lets <strong>convert a component to use these APIs</strong>!</p>
</div></section><section class="slide" data-pos="12-4-2">
<span class="pos">12-4-2</span>
<div class="slidecontent"><p>Here&#39;s the <strong>template</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">class.highlighted</span>]=<span class="hljs-string">"flag"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"toggle"</span>&gt;</span>
  someKindOfContent
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>When <strong><code>flag</code> is true</strong> the <strong><code>highlighted</code> class is set</strong>.</p>
</div></section><section class="slide" data-pos="12-4-3">
<span class="pos">12-4-3</span>
<div class="slidecontent"><p>Here&#39;s the <strong>component</strong> with the <strong>event handler</strong> and <strong>state</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> {
  flag: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>
  toggle(){
    <span class="hljs-keyword">this</span>.flag = !<span class="hljs-keyword">this</span>.flag;
  }
}
</code></pre>
</div></section><section class="slide" data-pos="12-4-4">
<span class="pos">12-4-4</span>
<div class="slidecontent"><p>The <strong>entire definition</strong> (almost):</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Component</span>({
  template: <span class="hljs-string">`&lt;div [class.highlighted]="flag" (click)="toggle"&gt;
    someKindOfContent
  &lt;/div&gt;`</span>,
  styles: [<span class="hljs-string">'.highlight {background-color: red;}'</span>]
})
<span class="hljs-keyword">class</span> {
  flag: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>
  toggle(){
    <span class="hljs-keyword">this</span>.flag = !<span class="hljs-keyword">this</span>.flag;
  }
}
</code></pre>
</div></section><section class="slide" data-pos="12-4-5">
<span class="pos">12-4-5</span>
<div class="slidecontent"><p>In essence; <strong>clicking the component toggles the <code>highlighted</code> class</strong>.</p>
<p>Now imagine that we have <strong>many components behave in the same way</strong>. Let&#39;s therefore <strong>move the behaviour to a directive</strong>!</p>
</div></section><section class="slide" data-pos="12-4-6">
<span class="pos">12-4-6</span>
<div class="slidecontent"><p>We want to be able to use it like thus:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">highlighttoggle</span>&gt;</span>someKindOfContent<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="12-4-7">
<span class="pos">12-4-7</span>
<div class="slidecontent"><p>That means we need <strong>something like this</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Directive</span>({ selector: <span class="hljs-string">'[highlighttoggle]'</span> })
<span class="hljs-keyword">class</span> {}
</code></pre>
</div></section><section class="slide" data-pos="12-4-8">
<span class="pos">12-4-8</span>
<div class="slidecontent"><p>Our directive must <strong>house the flag state</strong> and <strong>have a method to toggle it</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Directive</span>({ selector: <span class="hljs-string">'[highlighttoggle]'</span> })
<span class="hljs-keyword">class</span> {
  flag: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>
  toggle(){
    <span class="hljs-keyword">this</span>.flag = !<span class="hljs-keyword">this</span>.flag
  }
}
</code></pre>
</div></section><section class="slide" data-pos="12-4-9">
<span class="pos">12-4-9</span>
<div class="slidecontent"><p>We <strong>make the method run</strong> whenever the <strong>host is clicked</strong> by adding the <strong><code>HostListener</code></strong> decorator:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Directive</span>({ selector: <span class="hljs-string">'[highlighttoggle]'</span> })
<span class="hljs-keyword">class</span> {
  flag: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>
  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'click'</span>) toggle(){
    <span class="hljs-keyword">this</span>.flag = !<span class="hljs-keyword">this</span>.flag
  }
}
</code></pre>
</div></section><section class="slide" data-pos="12-4-10">
<span class="pos">12-4-10</span>
<div class="slidecontent"><p>And finally <strong>bind the flag to the host class</strong> using <strong><code>HostBinding</code></strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Directive</span>({ selector: <span class="hljs-string">'[highlighttoggle]'</span> })
<span class="hljs-keyword">class</span> {
  <span class="hljs-meta">@HostBinding</span>(<span class="hljs-string">'class.highlighted'</span>) flag: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>
  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'click'</span>) toggle(){
    <span class="hljs-keyword">this</span>.flag = !<span class="hljs-keyword">this</span>.flag
  }
}
</code></pre>
<p>Try this out in the <a href="resources/supportsite/demos/highlighter" target="_blank">Highlighter Directive</a> demo!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>12-5.</span> Structure directives</h3>
      <p>Redrawing the map</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="12-5-1">
<span class="pos">12-5-1</span>
<div class="slidecontent"><p><strong>Structure directives</strong> are a common label applied to directives that <strong>change the template</strong> of the elements they are attached to.</p>
</div></section><section class="slide" data-pos="12-5-2">
<span class="pos">12-5-2</span>
<div class="slidecontent"><p>You&#39;ve already seen <strong><code>ngFor</code></strong> and <strong><code>ngIf</code></strong>, two <strong>built-in structure directives</strong>.</p>
</div></section><section class="slide list" data-pos="12-5-3">
<span class="pos">12-5-3</span>
<div class="slidecontent">
<p>Let&#39;s consider <strong>what we would need</strong> to implement such a directive!</p>
<ul>
<li><span>a</span>we need <strong>the original template</strong></li>
<li><span>b</span>we need <strong>the host container</strong></li>
</ul>
</div></section><section class="slide num numA" data-pos="12-5-4">
<span class="pos">12-5-4</span>
<div class="slidecontent">
<p>For example, in the case of <code>ngFor</code>, we must have a <strong>reference to the host template</strong> in order to be able to <strong>repeat it once per item</strong> in the list.</p>
</div></section><section class="slide" data-pos="12-5-5">
<span class="pos">12-5-5</span>
<div class="slidecontent"><p>We achieve this through injecting a <strong><code>templateRef</code></strong> from <code>@angular/core</code>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> templateRef: TemplateRef&lt;<span class="hljs-built_in">any</span>&gt;</span>)
</code></pre>
</div></section><section class="slide num numB" data-pos="12-5-6">
<span class="pos">12-5-6</span>
<div class="slidecontent">
<p>We also need a way to <strong>communicate to the host view container</strong> what we have decided that the content should be.</p>
<p>Again using <code>ngFor</code> as an example, when we have repeated the template once per item we need <strong>somewhere to pass them off to</strong>!</p>
</div></section><section class="slide" data-pos="12-5-7">
<span class="pos">12-5-7</span>
<div class="slidecontent"><p>This is the role fulfilled by the <strong><code>ViewContainerRef</code></strong>, also injected from <code>@angular/core</code>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> viewContainer: ViewContainerRef</span>)
</code></pre>
</div></section><section class="slide" data-pos="12-5-8">
<span class="pos">12-5-8</span>
<div class="slidecontent"><p>Now that we have the pieces, let&#39;s use them to <strong>implement an <code>unless</code> directive</strong>!</p>
<p>It should function as a <strong>direct inverse to <code>ngIf</code></strong>...</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">unless</span>=<span class="hljs-string">"flag"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>...and <strong>only show the content if the expression is false</strong>.</p>
</div></section><section class="slide" data-pos="12-5-9">
<span class="pos">12-5-9</span>
<div class="slidecontent"><p>Remember, the <strong><code>*</code> is just a shorthand</strong> for the full template syntax:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">unless</span>=<span class="hljs-string">"flag"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre></div></section><section class="slide" data-pos="12-5-10">
<span class="pos">12-5-10</span>
<div class="slidecontent"><p>Let&#39;s <strong>get started</strong> by <strong>creating a <code>Directive</code> definition</strong>!</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Directive</span>({})
<span class="hljs-keyword">class</span> UnlessDirective {}
</code></pre>
</div></section><section class="slide" data-pos="12-5-11">
<span class="pos">12-5-11</span>
<div class="slidecontent"><p>We want our directive to be <strong>applied to all elements with an <code>unless</code> attribute</strong>, so we set up the corresponding <strong>selector</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Directive</span>({ selector: <span class="hljs-string">'[unless]'</span> })
<span class="hljs-keyword">class</span> UnlessDirective {}
</code></pre>
</div></section><section class="slide" data-pos="12-5-12">
<span class="pos">12-5-12</span>
<div class="slidecontent"><p>Since we know we need the <strong>template</strong> and the <strong>host view</strong>, let&#39;s <strong>inject both in the constructor</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Directive</span>({ selector: <span class="hljs-string">'[unless]'</span> })
<span class="hljs-keyword">class</span> UnlessDirective {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> templateRef: TemplateRef&lt;<span class="hljs-built_in">any</span>&gt;,
    <span class="hljs-keyword">private</span> viewContainer: ViewContainerRef
  </span>) { }
}
</code></pre>
</div></section><section class="slide" data-pos="12-5-13">
<span class="pos">12-5-13</span>
<div class="slidecontent"><p>We also need to <strong>register the <code>unless</code> property as an input</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Directive</span>({ selector: <span class="hljs-string">'[unless]'</span> })
<span class="hljs-keyword">class</span> UnlessDirective {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"> ... </span>) { }
  <span class="hljs-meta">@Input</span>() <span class="hljs-keyword">set</span> unless(condition: <span class="hljs-built_in">boolean</span>) {}
}
</code></pre>
</div></section><section class="slide" data-pos="12-5-14">
<span class="pos">12-5-14</span>
<div class="slidecontent"><p>And, <strong>depending on the truthiness of the condition</strong>, we either want to <strong>display the template</strong> or simply <strong>display nothing</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Input</span>() <span class="hljs-keyword">set</span> unless(condition: <span class="hljs-built_in">boolean</span>) {
  <span class="hljs-keyword">if</span> (!condition)
    <span class="hljs-comment">// show the template as per normal</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-comment">// show nothing!</span>
}
</code></pre>
</div></section><section class="slide" data-pos="12-5-15">
<span class="pos">12-5-15</span>
<div class="slidecontent"><p>We accomplish this through the <strong><code>.createEmbeddedView</code> and <code>.clear</code> methods of <code>viewContainer</code></strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Input</span>() <span class="hljs-keyword">set</span> unless(condition: <span class="hljs-built_in">boolean</span>) {
  <span class="hljs-keyword">if</span> (!condition)
    <span class="hljs-keyword">this</span>.viewContainer.createEmbeddedView(<span class="hljs-keyword">this</span>.templateRef);
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">this</span>.viewContainer.clear();
}
</code></pre>
</div></section><section class="slide" data-pos="12-5-16">
<span class="pos">12-5-16</span>
<div class="slidecontent"><p>Here&#39;s the <strong>full code</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Directive</span>({ selector: <span class="hljs-string">'[unless]'</span> })
<span class="hljs-keyword">class</span> UnlessDirective {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> templateRef: TemplateRef&lt;<span class="hljs-built_in">any</span>&gt;,
    <span class="hljs-keyword">private</span> viewContainer: ViewContainerRef
  </span>) { }
  <span class="hljs-meta">@Input</span>() <span class="hljs-keyword">set</span> unless(condition: <span class="hljs-built_in">boolean</span>) {
    <span class="hljs-keyword">if</span> (!condition)
      <span class="hljs-keyword">this</span>.viewContainer.createEmbeddedView(<span class="hljs-keyword">this</span>.templateRef);
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">this</span>.viewContainer.clear();
  }
}
</code></pre>
<p>See this in action in the <a href="resources/supportsite/demos/unless" target="_blank">Unless Directive</a> demo!</p>
</div></section>
</section>

  </div>
  
</div>
<div class="chaptercontainer">
  <div class="chapterstart">
    <span>chapter 13 / 13</span>
    <h2>Appendix: various NG</h2>
    <p>Give me more, give me more</p>
</p>
  </div>
  <section class="slide">

<div class="slidecontent"><p>This appendix chapter collects <strong>various specific API:s</strong> in the Angular framework.</p>
</div></section>
  <div class="chaptersectionlist">
  <h3>Sections in this chapter:</h3>
  <ul>
    <li>1. Pipes</li>
<li>2. Routing</li>
<li>3. Animations</li>
<li>4. Testing Angular</li>
  </ul>
</div>

  <div class="chaptersections">
    <section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>13-1.</span> Pipes</h3>
      <p>a.k.a. filters</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="13-1-1">
<span class="pos">13-1-1</span>
<div class="slidecontent"><p>Pipes are primarily a way to <strong>transform strings</strong>, although they can also be used on other values.</p>
<p>In other words, a regular <strong>pure function*</strong>!</p>
<p><img src="resources/diagrams/pipe.svg" alt=""></p>
</div></section><section class="slide" data-pos="13-1-2">
<span class="pos">13-1-2</span>
<div class="slidecontent"><p><strong>AngularJS called them filters</strong>, but this was a bit <strong>confusing</strong> since</p>
<ul>
<li>they <strong>didn&#39;t necessarily filter</strong> anything</li>
<li>there was a <strong>filter named filter</strong> :)</li>
</ul>
</div></section><section class="slide" data-pos="13-1-3">
<span class="pos">13-1-3</span>
<div class="slidecontent"><p>Angular has the <strong>same special syntax</strong> for pipes as AngularJS:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The party is planned to be at {{partyDate | formatDate}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</code></pre>
<p>The bracket contents is <strong>equivalent</strong> to:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">formatDate</span><span class="hljs-params">(partyDate)</span></span>
</code></pre></div></section><section class="slide" data-pos="13-1-4">
<span class="pos">13-1-4</span>
<div class="slidecontent"><p>When your want <strong>arguments</strong>, list them after <strong>colons</strong>:</p>
<pre><code class="lang-html">The party is at {{partyDate | formatDate : &#39;dd/mm&#39;}}
</code></pre>
<p>Now the brackets translate to:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">formatDate</span><span class="hljs-params">(partyDate, <span class="hljs-string">'dd/mm'</span>)</span></span>
</code></pre></div></section><section class="slide question" data-pos="13-1-5">
<span class="pos">13-1-5</span>
<div class="slidecontent">
<p>But, as we said, <strong>pipes are just functions</strong>. Was it really <strong>necessary to invent this new syntax</strong>?</p>
</div></section><section class="slide answer" data-pos="13-1-6">
<span class="pos">13-1-6</span>
<div class="slidecontent">
<p>Perhaps not, but there are <strong>two good reasons</strong> for it!</p>
<p>First off, here we <strong>know that <code>formatDate</code> is a <code>Pipe</code></strong>:</p>
<pre><code>{{partyDate | formatDate : <span class="hljs-string">'dd/mm'</span>}}
</code></pre><p>While here it could be <strong>any function</strong> in the same scope:</p>
<pre><code class="lang-javascript">formatDate(partyDate, <span class="hljs-string">'dd/mm'</span>)
</code></pre>
</div></section><section class="slide" data-pos="13-1-7">
<span class="pos">13-1-7</span>
<div class="slidecontent"><p>Secondly, we can <strong>have many pipes</strong>:</p>
<pre><code>{{partyDate | formatDate : <span class="hljs-string">'dd/mm'</span> | frameWithNotes}}
</code></pre><p>which we have to <strong>write in reverse order</strong> in regular code:</p>
<pre><code class="lang-javascript">frameWithNotes( formatDate(partyDate, <span class="hljs-string">'dd/mm'</span>) )
</code></pre>
</div></section><section class="slide" data-pos="13-1-8">
<span class="pos">13-1-8</span>
<div class="slidecontent"><p>To <strong>see a pipe in action</strong> and <strong>how they are registered</strong>, check out the <a href="resources/supportsite/demos/pipe" target="_blank">Pipe</a> demo!</p>
</div></section><section class="slide" data-pos="13-1-9">
<span class="pos">13-1-9</span>
<div class="slidecontent"><p>There are of course a number of <strong>built-in pipes</strong>, such as <strong><code>DatePipe</code></strong>, <strong><code>UpperCasePipe</code></strong> and <strong><code>CurrencyPipe</code></strong> among others.</p>
<p>Note that you <strong>must import the NgModules they reside in</strong> to be able to use them!</p>
</div></section><section class="slide" data-pos="13-1-10">
<span class="pos">13-1-10</span>
<div class="slidecontent"><p>The built-in <strong><code>Async</code></strong> pipe deserves a <strong>special mention</strong>, as it can be a <strong>huge code saver</strong> in the right circumstances. </p>
<p>Check it out in the <a href="resources/supportsite/demos/asyncpipe" target="_blank">Async Pipe</a> demo.</p>
</div></section><section class="slide" data-pos="13-1-11">
<span class="pos">13-1-11</span>
<div class="slidecontent"><p>Notable <strong>omissions</strong> among the built-in pipes are equivalents to <strong><code>filter</code> and <code>orderBy</code></strong> from AngularJS.</p>
<p>Find out exactly <strong>why</strong> they were omitted in the <a href="https://angular.io/docs/ts/latest/guide/pipes.html#!#no-filter-pipe">Filter omission explanation</a> in the official docs.</p>
</div></section><section class="slide" data-pos="13-1-12">
<span class="pos">13-1-12</span>
<div class="slidecontent"><p>A final note: by default pipes are <strong>pure</strong>, meaning they are <strong>only applied when a change to the input is detected</strong>.</p>
<p>But sometimes you might need the pipe to <strong>always be applied on every rerender</strong>. If so, set <code>pure</code> to false:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@Pipe</span>({
  name: <span class="hljs-string">'myPipe'</span>,
  pure: <span class="hljs-literal">false</span>
})
</code></pre>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>13-2.</span> Routing</h3>
      <p>Finding the way</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="13-2-1">
<span class="pos">13-2-1</span>
<div class="slidecontent"><p>Before we say anything, a word of warning - the <strong>Angular router has received many makeovers</strong>, so make sure any online material is up to date, otherwise you risk being severely confused.</p>
</div></section><section class="slide" data-pos="13-2-2">
<span class="pos">13-2-2</span>
<div class="slidecontent"><p>Also, there are whispers that the great reception of the <strong>recent overhaul of the React Router</strong> might cause even further changes, so, <strong>don&#39;t get too attached to the API</strong>!</p>
</div></section><section class="slide" data-pos="13-2-3">
<span class="pos">13-2-3</span>
<div class="slidecontent"><p>Partly because of this we <strong>won&#39;t dig too deep into the router in this course</strong>, but we still want you to <strong>get a sense for how it is working</strong>.</p>
<p>So now we&#39;ll <strong>walk through the basic functionality</strong> which <strong>covers the vast majority of use cases</strong>.</p>
</div></section><section class="slide list" data-pos="13-2-4">
<span class="pos">13-2-4</span>
<div class="slidecontent">
<p>Here&#39;s <strong>what we&#39;ll cover</strong>:</p>
<ul>
<li><span>a</span>routes definition</li>
<li><span>b</span>installing the routes</li>
<li><span>c</span>select strategy</li>
<li><span>d</span>providing an outlet</li>
<li><span>e</span>navigating</li>
<li><span>f</span>parameters</li>
</ul>
</div></section><section class="slide num numA" data-pos="13-2-5">
<span class="pos">13-2-5</span>
<div class="slidecontent">
<p>Here&#39;s a <strong>simple routes definition example</strong>: </p>
<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> routes = [
  {path: <span class="hljs-string">''</span>, component: HomeComponent},
  {path: <span class="hljs-string">'product/:tool'</span>, component: ProductComponent}
]
</code></pre>
<p>As you can see we are <strong>connecting paths to components</strong>.</p>
</div></section><section class="slide" data-pos="13-2-6">
<span class="pos">13-2-6</span>
<div class="slidecontent"><p>The syntax might <strong>seem verbose</strong>, but the reason for having an array of objects is to accommodate <strong>lots of other functionality</strong> - child routes, extra settings, data, etc.</p>
</div></section><section class="slide num numB" data-pos="13-2-7">
<span class="pos">13-2-7</span>
<div class="slidecontent">
<p>We <strong>make our app use the routes</strong> by importing the result of <strong>feeding <code>routes</code> to a <code>RouterModule</code> method</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@NgModule</span>({
    imports: [ BrowserModule, RouterModule.forRoot(routes) ],
    ...
</code></pre>
<p>Now we&#39;re <strong>navigating from the root</strong>, but we could <strong>also use routes from a child component</strong>.</p>
</div></section><section class="slide num numC" data-pos="13-2-8">
<span class="pos">13-2-8</span>
<div class="slidecontent">
<p>When we make a <strong>SPA</strong>, by definition, we <strong>don&#39;t want the browser to reload between pages</strong>. Yet we still want the user to be able to <strong>use browser controls</strong>!</p>
<p>We must therefore employ <strong>some kind of strategy</strong> that marries <strong>internal navigation with the browser address bar</strong>.</p>
</div></section><section class="slide" data-pos="13-2-9">
<span class="pos">13-2-9</span>
<div class="slidecontent"><p>There are primarily three ways to <strong>handle navigation in a SPA</strong>:</p>
<table class="deflist">
  <tr>
    <td><a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API"><code>pushState</code></a></td>
    <td>Makes the URL look &quot;real&quot;</td>
  </tr>
  <tr>
    <td>hash navigation</td>
    <td>Using the trailing <code>#something</code> part of the URL</td>
  </tr>
  <tr>
    <td>in memory</td>
    <td>Means browser controls won&#39;t work</td>
  </tr>
</table>

<p>Of course there are <strong>lots more details</strong> that we&#39;re skipping over here.</p>
</div></section><section class="slide" data-pos="13-2-10">
<span class="pos">13-2-10</span>
<div class="slidecontent"><p>We <strong>select strategy</strong> by <strong>registering the corresponding provider</strong> in the route-providing module:</p>
<pre><code class="lang-typescript"><span class="hljs-meta">@NgModule</span>({
    imports: [ BrowserModule, RouterModule.forRoot(routes) ],
    providers: [
      {provide: LocationStrategy, useClass: HashLocationStrategy}
    ],
    ...
</code></pre>
<p>The router will then <strong>handle navigation accordingly</strong>.</p>
</div></section><section class="slide num numD" data-pos="13-2-11">
<span class="pos">13-2-11</span>
<div class="slidecontent">
<p>Obviously we must also <strong>render the matched component</strong> somewhere! The Router does this through the <strong><code>ng-output</code> directive</strong>, meaning the <strong>root component template</strong> can look something like this:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My amazing app<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>© Edument 2016 → end of time<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
</code></pre><p>Effectively functioning as a <strong>master template</strong>!</p>
</div></section><section class="slide num numE" data-pos="13-2-12">
<span class="pos">13-2-12</span>
<div class="slidecontent">
<p>There are <strong>two ways to navigate</strong>;</p>
<ul>
<li>either <strong>programatically</strong> or through</li>
<li>normal <strong>anchor elements</strong>.</li>
</ul>
</div></section><section class="slide" data-pos="13-2-13">
<span class="pos">13-2-13</span>
<div class="slidecontent"><p>To <strong>navigate programatically</strong> we <strong>inject the router</strong> and call its <code>navigate</code> method:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">class</span> MyComponent {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: Router</span>){}
  someEventHandler(){
    <span class="hljs-keyword">this</span>.router.navigate([someUrl,scndPartOfUrl]);
  }
}
</code></pre>
<p>Like earlier, the seemingly <strong>verbose syntax</strong> is there to accomodate a <strong>complex API</strong>!</p>
</div></section><section class="slide" data-pos="13-2-14">
<span class="pos">13-2-14</span>
<div class="slidecontent"><p>We can also <strong>navigate by anchor elements</strong>, but that entails using the <strong><code>routerLink</code> directive instead of the normal <code>href</code> attribute</strong>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"['/heroes/batman']"</span>&gt;</span>Batman<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre>
<p>The directive also contains ways to <strong>add CSS classes to active links</strong>, etc.</p>
</div></section><section class="slide num numF" data-pos="13-2-15">
<span class="pos">13-2-15</span>
<div class="slidecontent">
<p>Finally, a word about <strong>parameters</strong>! Maybe you spotted them in the <code>routes</code> example earlier?</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> routes = [
  {path: <span class="hljs-string">''</span>, component: HomeComponent},
  {path: <span class="hljs-string">'product/:tool'</span>, component: ProductComponent}
]
</code></pre>
<p>As in so many other routing solutions, <strong>parameters are defined by colon prefixes</strong>.</p>
</div></section><section class="slide" data-pos="13-2-16">
<span class="pos">13-2-16</span>
<div class="slidecontent"><p>We <strong>access the current parameters</strong> by injecting the <strong><code>ActivatedRoute</code></strong> service:</p>
<pre><code><span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">UserComponent</span> {
  <span class="hljs-attribute">userId</span>: string
  <span class="hljs-built_in">constructor</span>(route: ActivatedRoute){
    this.userId = route.snapshot.params[<span class="hljs-string">'user'</span>]
  }
}
</code></pre></div></section><section class="slide" data-pos="13-2-17">
<span class="pos">13-2-17</span>
<div class="slidecontent"><p>We <strong>covered a lot of ground</strong>, but left <strong>many details unsaid</strong>. Still, what you saw is the gist of the gist.</p>
<p><strong>Try it out</strong> in the <a href="resources/supportsite/demos/router" target="_blank">Router</a> demo, or <strong>read more</strong> in the <a href="https://angular.io/docs/ts/latest/guide/router.html">Router section</a> of the official docs.</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>13-3.</span> Animations</h3>
      <p>marquees and blinks?</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="13-3-1">
<span class="pos">13-3-1</span>
<div class="slidecontent"><p>In <strong>AngularJS</strong>, animations were done through <strong>framework-generated CSS classes</strong> to which you would hook up <strong>CSS <code>transitions</code> or <code>keyframes</code></strong>.</p>
<p><strong>Angular</strong>, however, gives you a <strong>completely different setup</strong> where you get <strong>full programmatic control</strong>!</p>
</div></section><section class="slide" data-pos="13-3-2">
<span class="pos">13-3-2</span>
<div class="slidecontent"><p>It builds on the foundation of <strong><a href="https://developer.mozilla.org/en-US/docs/Web/API/Animation">Web Animations</a></strong>, a new API for <strong>controlling animations from JS</strong>.</p>
<p>Since this is <strong>still experimental</strong>, we need a <strong><a href="https://www.npmjs.com/package/web-animations-js">polyfill</a></strong> to make it work.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"web-animations.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
</div></section><section class="slide" data-pos="13-3-3">
<span class="pos">13-3-3</span>
<div class="slidecontent"><p>There are two parts to animations; we <strong>tag the elements we want to animate</strong> using the animation-specific <code>@animName</code> syntax, <strong>binding that to an expression</strong>:</p>
<pre><code>&lt;<span class="hljs-selector-tag">div</span> [@mode]=<span class="hljs-string">"styleMode"</span>&gt;
</code></pre></div></section><section class="slide" data-pos="13-3-4">
<span class="pos">13-3-4</span>
<div class="slidecontent"><p>Then we add a <strong>corresponding animation definition</strong> within the <strong><code>animations</code> array of the metadata</strong>:</p>
<pre><code class="lang-typescript">animations: [
  trigger(<span class="hljs-string">'mode'</span>, [
    state(<span class="hljs-string">'day'</span>, style(objWithStyles)),
    state(<span class="hljs-string">'night'</span>, style(anotherObjWithStyles)),
    transition(<span class="hljs-string">'* =&gt; *'</span>, animate(<span class="hljs-string">'100ms ease-in'</span>)),
  ])
],
</code></pre>
</div></section><section class="slide" data-pos="13-3-5">
<span class="pos">13-3-5</span>
<div class="slidecontent"><p>From that we can deduce that...</p>
<ul>
<li>we have <strong>one <code>trigger</code> per <code>@animName</code></strong></li>
<li>the <strong>possibles values of the bound expression</strong> translate to <strong>different animation states</strong></li>
<li>we <strong>control how to transition between states</strong></li>
</ul>
</div></section><section class="slide" data-pos="13-3-6">
<span class="pos">13-3-6</span>
<div class="slidecontent"><p>Regarding <strong>transitions</strong>: in the example we used the <strong>wildcard <code>*</code> syntax</strong>...</p>
<pre><code><span class="hljs-function"><span class="hljs-title">transition</span><span class="hljs-params">(<span class="hljs-string">'* =&gt; *'</span>, animate(<span class="hljs-string">'100ms ease-in'</span>)</span></span>)
</code></pre><p>...but we can be <strong>more specific</strong>:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">transition</span><span class="hljs-params">(<span class="hljs-string">'day =&gt; night'</span>, animate(<span class="hljs-string">'100ms ease-in'</span>)</span></span>),
<span class="hljs-function"><span class="hljs-title">transition</span><span class="hljs-params">(<span class="hljs-string">'night =&gt; day'</span>, animate(<span class="hljs-string">'300ms ease-out'</span>)</span></span>),
</code></pre></div></section><section class="slide" data-pos="13-3-7">
<span class="pos">13-3-7</span>
<div class="slidecontent"><p>You can <strong>see this in action</strong> in the <a href="resources/supportsite/demos/animation" target="_blank">Animation</a> demo!</p>
</div></section><section class="slide" data-pos="13-3-8">
<span class="pos">13-3-8</span>
<div class="slidecontent"><p>Of course, it wouldn&#39;t be called animations if we didn&#39;t have the ability to define <strong>keyframes</strong>.</p>
<p>That is, <strong>intermediate states</strong> and not just the target state.</p>
</div></section><section class="slide" data-pos="13-3-9">
<span class="pos">13-3-9</span>
<div class="slidecontent"><p>This is done by <strong>passing keyframes to the <code>animate</code> method</strong> instead of just a string:</p>
<pre><code><span class="hljs-selector-tag">transition</span>(<span class="hljs-string">'* =&gt; day'</span>, animate(<span class="hljs-number">300</span>, keyframes([
  style({ <span class="hljs-attribute">backgroundColor</span>: <span class="hljs-string">'#F57171'</span>, <span class="hljs-attribute">offset</span>: <span class="hljs-number">0.5</span>}),
  style({ <span class="hljs-attribute">backgroundColor</span>: <span class="hljs-string">'#DCEDF2'</span>, <span class="hljs-attribute">color</span>: <span class="hljs-string">'black'</span>, <span class="hljs-attribute">offset</span>: <span class="hljs-number">1</span> })
])))
</code></pre><p><strong>Try this</strong> in the <a href="resources/supportsite/demos/animation_keyframes" target="_blank">Animation Keyframes</a> demo.</p>
</div></section><section class="slide" data-pos="13-3-10">
<span class="pos">13-3-10</span>
<div class="slidecontent"><p>By the way, <strong>where all the helper methods comings from</strong>? Surprisingly, <code>@angular/core</code>!</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> {
  Component, trigger, state, style, transition, animate
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
</code></pre>
</div></section><section class="slide" data-pos="13-3-11">
<span class="pos">13-3-11</span>
<div class="slidecontent"><p>The API is <strong>even more powerful</strong> than we&#39;ve showed here - see the <a href="https://angular.io/docs/ts/latest/guide/animations.html">official guide</a> for more details.</p>
</div></section><section class="slide" data-pos="13-3-12">
<span class="pos">13-3-12</span>
<div class="slidecontent"><p>Speaking of power - remember that <strong>most animation needs</strong> can be fulfilled with <strong>dynamic classes and regular CSS</strong>.</p>
<p>Normally we <strong>don&#39;t need the animation API</strong>.</p>
</div></section><section class="slide" data-pos="13-3-13">
<span class="pos">13-3-13</span>
<div class="slidecontent"><p>But if you want to...</p>
<ul>
<li>animate <strong>entering / leaving elements</strong> (by using the magical <strong><code>&quot;void&quot;</code> target state</strong>)</li>
<li>have <strong>dynamic props</strong> in the animation</li>
</ul>
<p>...then the <strong>animate API is your friend</strong>!</p>
</div></section>
</section>
<section class="chaptersection">
  <section class="sectionheader">
    <div>
      <h3><span>13-4.</span> Testing Angular</h3>
      <p>TDD, BDD, FFS</p>
</p>
    </div>
  </section>
  <section class="slide" data-pos="13-4-1">
<span class="pos">13-4-1</span>
<div class="slidecontent"><p>We&#39;ll walk you through the basic flow for <strong>unit testing Angular components</strong>.</p>
<p>If you are not familiar with <strong>unit tests</strong> and <strong>integration tests</strong>, or testing at all, <strong>now is the time to raise your hand and ask</strong>! :)</p>
</div></section><section class="slide" data-pos="13-4-2">
<span class="pos">13-4-2</span>
<div class="slidecontent"><p>Commonly people use <strong><a href="http://jasmine.github.io/">Jasmine</a> to write assertions</strong> in their Angular tests.</p>
<p>We have however strived to <strong>focus solely on the Angular-specific parts</strong>, so we won&#39;t go into detail on how to write assertions.</p>
</div></section><section class="slide" data-pos="13-4-3">
<span class="pos">13-4-3</span>
<div class="slidecontent"><p>At the heart of Angular testing are the <strong>testing utilities</strong>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> {
  ComponentFixture, <span class="hljs-comment">// interface for test components</span>
  TestBed <span class="hljs-comment">// set up mock modules with custom dependencies</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core/testing'</span>;
<span class="hljs-keyword">import</span> {
  By <span class="hljs-comment">// helper for querying template output</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="hljs-keyword">import</span> {
  DebugElement <span class="hljs-comment">// interface for queried element</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
</code></pre>
</div></section><section class="slide list" data-pos="13-4-4">
<span class="pos">13-4-4</span>
<div class="slidecontent">
<p>We&#39;ll now work through a <strong>common testing flow</strong>:</p>
<ul>
<li><span>a</span><strong>unit test setup</strong></li>
<li><span>b</span><strong>test module creation</strong></li>
<li><span>c</span><strong>create component instance</strong></li>
<li><span>d</span><strong>test template output</strong></li>
<li><span>e</span><strong>manipulate the instance</strong></li>
</ul>
</div></section><section class="slide num numA" data-pos="13-4-5">
<span class="pos">13-4-5</span>
<div class="slidecontent">
<p>We start off our test by <strong>creating variables</strong> to hold...</p>
<ul>
<li>the <strong>component fixture</strong></li>
<li>the <strong>component itself</strong></li>
</ul>
<pre><code class="lang-typescript"><span class="hljs-keyword">let</span> fixture: ComponentFixture&lt;MyComponent&gt;;
<span class="hljs-keyword">let</span> comp: MyComponent;
</code></pre>
</div></section><section class="slide num numB" data-pos="13-4-6">
<span class="pos">13-4-6</span>
<div class="slidecontent">
<p>Next we <strong>spin up a testing module</strong>:</p>
<pre><code class="lang-typescript">TestBed.configureTestingModule({
  declarations: [ MyComponent ]
});
</code></pre>
<p>Here we would also put <strong>mock providers</strong>.</p>
</div></section><section class="slide num numC" data-pos="13-4-7">
<span class="pos">13-4-7</span>
<div class="slidecontent">
<p>We can now use the module to <strong>instantiate the component</strong>...</p>
<pre><code class="lang-typescript">fixture = TestBed.createComponent(MyComponent);
</code></pre>
</div></section><section class="slide" data-pos="13-4-8">
<span class="pos">13-4-8</span>
<div class="slidecontent"><p>...and <strong>access the instance</strong>:</p>
<pre><code class="lang-typescript">comp = fixture.componentInstance;
</code></pre>
<p>With access to the instance we can <strong>manipulate properties</strong> and <strong>call methods</strong>, and do whatever assertions we want!</p>
</div></section><section class="slide num numD" data-pos="13-4-9">
<span class="pos">13-4-9</span>
<div class="slidecontent">
<p>If we want to <strong>test the template output</strong>, we&#39;d use the <code>By</code> helper:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">let</span> elem:DebugElement = fixture.debugElement.query(
  By.css(<span class="hljs-string">'.twain'</span>) <span class="hljs-comment">// `By` can query through lots of means</span>
);
</code></pre>
<p>We can now <strong>do assertions on <code>elem.nativeElement</code></strong>.</p>
</div></section><section class="slide num numE" data-pos="13-4-10">
<span class="pos">13-4-10</span>
<div class="slidecontent">
<p>To <strong>test the component</strong> we <strong>manipulate the instance</strong>. However, you have to <strong>manually trigger the change cycle</strong> after you manipulate something:</p>
<pre><code class="lang-typescript">comp.someMethod();
fixture.detectChanges();
</code></pre>
<p>Now you can do your assertions.</p>
</div></section><section class="slide" data-pos="13-4-11">
<span class="pos">13-4-11</span>
<div class="slidecontent"><p>Instead, if we want to, we can <strong>configure the test module to detect changes automatically</strong>:</p>
<pre><code class="lang-typescript">TestBed.configureTestingModule({
  declarations: [ MyComponent ],
  providers: [
    { provide: ComponentFixtureAutoDetect, useValue: <span class="hljs-literal">true</span> }
  ]
})
</code></pre>
</div></section><section class="slide" data-pos="13-4-12">
<span class="pos">13-4-12</span>
<div class="slidecontent"><p>...and that&#39;s pretty much <strong>how you unit test Angular</strong>!</p>
<p>We need to know about Jasmine (for writing assertions) and Karma (for running the tests) too, but that&#39;s a <strong>story for another time</strong>.</p>
</div></section><section class="slide" data-pos="13-4-13">
<span class="pos">13-4-13</span>
<div class="slidecontent"><p>A final word regarding <strong>E2E-tests</strong> - the primary tool is <strong><a href="https://github.com/angular/protractor">Protractor</a></strong>. Yes, the <strong>same as for AngularJS</strong>!</p>
<p>However the <strong>current support is flaky</strong>, which is no surprise given how quickly Angular has changed.</p>
</div></section>
</section>

  </div>
  
</div>

  </div>
  <div id="indexes">
    <div class="lookupindex linklist">
  <h2>External links</h2>
  <div class="lookuplist">
    <div><span>10-1-7</span><span>method shorthand syntax</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions</a></div><div><span>10-1-12</span><span>uniform access principle</span><a href="https://en.wikipedia.org/wiki/Uniform_access_principle">https://en.wikipedia.org/wiki/Uniform_access_principle</a></div><div><span>10-2-1</span><span>Destructuring</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</a></div><div><span>10-5-4</span><span>export</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export</a></div><div><span>10-5-4</span><span>import</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import</a></div><div><span>10-7-1</span><span>annotations</span><a href="http://blog.thoughtram.io/angular/2015/05/03/the-difference-between-annotations-and-decorators.html">http://blog.thoughtram.io/angular/2015/05/03/the-difference-between-annotations-and-decorators.html</a></div><div><span>10-7-1</span><span>disagreement</span><a href="https://github.com/wycats/javascript-decorators/issues/48">https://github.com/wycats/javascript-decorators/issues/48</a></div><div><span>10-7-1</span><span>implementation in TypeScript</span><a href="https://www.typescriptlang.org/docs/handbook/decorators.html">https://www.typescriptlang.org/docs/handbook/decorators.html</a></div><div><span>10-7-1</span><span>proposal</span><a href="http://tc39.github.io/proposal-decorators/">http://tc39.github.io/proposal-decorators/</a></div><div><span>10-7-11</span><span>concice and clear explanation</span><a href="https://github.com/arolson101/typescript-decorators">https://github.com/arolson101/typescript-decorators</a></div><div><span>10-7-11</span><span>decorator section</span><a href="https://www.typescriptlang.org/docs/handbook/decorators.html">https://www.typescriptlang.org/docs/handbook/decorators.html</a></div><div><span>10-8-11</span><span>Choo</span><a href="https://github.com/yoshuawuyts/choo">https://github.com/yoshuawuyts/choo</a></div><div><span>10-9-3</span><span>es6fiddle.net</span><a href="http://es6fiddle.net/">http://es6fiddle.net/</a></div><div><span>10-9-6</span><span>babeljs.io/repl</span><a href="https://babeljs.io/repl">https://babeljs.io/repl</a></div><div><span>1-4-5</span><span>@angular</span><a href="https://www.npmjs.com/package/@angular/core">https://www.npmjs.com/package/@angular/core</a></div><div><span>1-4-5</span><span>angular</span><a href="https://www.npmjs.com/package/angular">https://www.npmjs.com/package/angular</a></div><div><span>1-4-5</span><span>angular/angular</span><a href="https://github.com/angular/angular">https://github.com/angular/angular</a></div><div><span>1-4-5</span><span>angular/angular.js</span><a href="https://github.com/angular/angular.js">https://github.com/angular/angular.js</a></div><div><span>11-3-11</span><span>here</span><a href="https://github.com/angular/angular/issues/10552#issuecomment-241556913">https://github.com/angular/angular/issues/10552#issuecomment-241556913</a></div><div><span>11-5-8</span><span>official Ahead-of-Time compilation guide</span><a href="https://angular.io/guide/aot-compiler">https://angular.io/guide/aot-compiler</a></div><div><span>13-1-11</span><span>Filter omission explanation</span><a href="https://angular.io/docs/ts/latest/guide/pipes.html#!#no-filter-pipe">https://angular.io/docs/ts/latest/guide/pipes.html#!#no-filter-pipe</a></div><div><span>13-2-17</span><span>Router section</span><a href="https://angular.io/docs/ts/latest/guide/router.html">https://angular.io/docs/ts/latest/guide/router.html</a></div><div><span>13-3-2</span><span>Web Animations</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Animation">https://developer.mozilla.org/en-US/docs/Web/API/Animation</a></div><div><span>13-3-2</span><span>polyfill</span><a href="https://www.npmjs.com/package/web-animations-js">https://www.npmjs.com/package/web-animations-js</a></div><div><span>13-3-11</span><span>official guide</span><a href="https://angular.io/docs/ts/latest/guide/animations.html">https://angular.io/docs/ts/latest/guide/animations.html</a></div><div><span>13-4-2</span><span>Jasmine</span><a href="http://jasmine.github.io/">http://jasmine.github.io/</a></div><div><span>13-4-13</span><span>Protractor</span><a href="https://github.com/angular/protractor">https://github.com/angular/protractor</a></div><div><span>2-1-1</span><span>CoreJS</span><a href="https://www.npmjs.com/package/core-js">https://www.npmjs.com/package/core-js</a></div><div><span>2-2-1</span><span>CoffeeScript</span><a href="http://coffeescript.org">http://coffeescript.org</a></div><div><span>2-2-1</span><span>TypeScript</span><a href="http://typescriptlang.org">http://typescriptlang.org</a></div><div><span>2-2-16</span><span>whole course just about TypeScript</span><a href="https://edument.se/education/categories/webdevelopment/typescript">https://edument.se/education/categories/webdevelopment/typescript</a></div><div><span>2-3-1</span><span>ZoneJS</span><a href="https://github.com/angular/zone.js">https://github.com/angular/zone.js</a></div><div><span>2-4-1</span><span>Reflect Metadata</span><a href="https://www.npmjs.com/package/reflect-metadata">https://www.npmjs.com/package/reflect-metadata</a></div><div><span>2-6-1</span><span>SystemJS</span><a href="https://github.com/systemjs/systemjs">https://github.com/systemjs/systemjs</a></div><div><span>2-6-10</span><span>Quickstart</span><a href="https://angular.io/docs/ts/latest/quickstart.html">https://angular.io/docs/ts/latest/quickstart.html</a></div><div><span>3-2-5</span><span>Shadow DOM</span><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM">https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM</a></div><div><span>3-4-6</span><span>CoffeeScript</span><a href="http://coffeescript.org/">http://coffeescript.org/</a></div><div><span>4-2-9</span><span>Template statement</span><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#!#template-statements">https://angular.io/docs/ts/latest/guide/template-syntax.html#!#template-statements</a></div><div><span>4-3-2</span><span>full list of methods</span><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html</a></div><div><span>4-5-3</span><span>Angular Augury</span><a href="https://augury.angular.io/">https://augury.angular.io/</a></div><div><span>5-1-4</span><span>Web Components</span><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">https://developer.mozilla.org/en-US/docs/Web/Web_Components</a></div><div><span>5-2-11</span><span>source code</span><a href="https://github.com/angular/angular/blob/2.0.2/modules/%40angular/common/src/directives/ng_if.ts#L9-L51">https://github.com/angular/angular/blob/2.0.2/modules/%40angular/common/src/directives/ng_if.ts#L9-L51</a></div><div><span>5-2-13</span><span>official API docs</span><a href="https://angular.io/docs/ts/latest/api/">https://angular.io/docs/ts/latest/api/</a></div><div><span>5-3-14</span><span>go look</span><a href="https://github.com/angular/angular/blob/2.0.2/modules/%40angular/forms/src/directives/ng_model.ts#L108">https://github.com/angular/angular/blob/2.0.2/modules/%40angular/forms/src/directives/ng_model.ts#L108</a></div><div><span>7-2-2</span><span>Forms section in the official docs</span><a href="https://angular.io/docs/ts/latest/guide/forms.html">https://angular.io/docs/ts/latest/guide/forms.html</a></div><div><span>7-2-6</span><span>source code</span><a href="https://github.com/angular/angular/blob/2.0.2/modules/%40angular/forms/src/directives/ng_form.ts#L62">https://github.com/angular/angular/blob/2.0.2/modules/%40angular/forms/src/directives/ng_form.ts#L62</a></div><div><span>8-1-2</span><span>official docs</span><a href="https://angular.io/docs/ts/latest/">https://angular.io/docs/ts/latest/</a></div><div><span>8-1-3</span><span>API reference</span><a href="https://angular.io/docs/ts/latest/api/">https://angular.io/docs/ts/latest/api/</a></div><div><span>8-1-3</span><span>advanced</span><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html">https://angular.io/docs/ts/latest/guide/ngmodule.html</a></div><div><span>8-1-3</span><span>cheat sheet</span><a href="https://angular.io/cheatsheet">https://angular.io/cheatsheet</a></div><div><span>8-1-3</span><span>guides</span><a href="https://angular.io/docs/ts/latest/guide/">https://angular.io/docs/ts/latest/guide/</a></div><div><span>8-1-4</span><span>Angular University</span><a href="http://blog.angular-university.io/">http://blog.angular-university.io/</a></div><div><span>8-1-4</span><span>Thoughtram Blog</span><a href="http://blog.thoughtram.io/">http://blog.thoughtram.io/</a></div><div><span>8-1-5</span><span>Angular 2 development with TypeScript</span><a href="https://www.manning.com/books/angular-2-development-with-typescript">https://www.manning.com/books/angular-2-development-with-typescript</a></div><div><span>8-1-5</span><span>Manning Publication</span><a href="https://www.manning.com/">https://www.manning.com/</a></div><div><span>9-1-11</span><span>JavaScript Garden</span><a href="http://bonsaiden.github.io/JavaScript-Garden/">http://bonsaiden.github.io/JavaScript-Garden/</a></div><div><span>9-1-11</span><span>MDN</span><a href="https://developer.mozilla.org/en-US/">https://developer.mozilla.org/en-US/</a></div><div><span>9-3-2</span><span>Node</span><a href="https://nodejs.org/en/">https://nodejs.org/en/</a></div>
  </div>
</div>

  </div>
</div>

</body>
</html>
